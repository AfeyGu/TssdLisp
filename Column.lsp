(lib::lsp "MyFan.lsp")
(Defun coin (sm tf ti tr lv / rhatch ps p1 p2 ss si smx e lp ll a inst co pl x1 y1 x2 
             y2 lac lpo ssh
            ) 
  (defun rhatch (ss / e e1 si react pl s pt1 pt2 ang dis) 
    (defun react (e / el tf tf1 i) 
      (setq tf t)
      (if (setq e (entget e)) 
        (progn 
          (foreach x e 
            (setq i (car x))
            (if (equal x '(102 . "{ACAD_REACTORS")) (setq tf nil))
            (if (zerop i) (setq tf1 (= (cdr x) "HATCH")))
            (if (and tf1 (or (= i 71) (= i 97))) (setq x (cons i 0)))
            (if (and tf1 (= i 330) (not (ssmemb (cdr x) ss))) (react (cdr x)))
            (if (and tf (/= i 330)) (setq el (cons x el)))
            (if (equal x '(102 . "}")) (setq tf t))
          )
          (entmod (reverse el))
        )
      )
    )
    (setq si 0)
    (while (setq e (ssname ss si)) 
      (setq si (1+ si)
            pl (&DRAG e 10)
      )
      (if (= 2 (length pl)) 
        (setq pt1 (car pl)
              pt2 (last pl)
              dis (distance pt1 pt2)
              an  (angle pt1 pt2)
              pl  (list (polar pt1 (- an _pi2) (* 0.5 dis)) 
                        (polar pt1 (+ an _pi2) (* 0.5 dis))
                        (polar pt2 (+ an _pi2) (* 0.5 dis))
                        (polar pt2 (- an _pi2) (* 0.5 dis))
                  )
        )
      )
      (if 
        (setq s (ssget "cp" 
                       pl
                       (list (cons 8 (&LJIG "平面柱子尺寸")) '(0 . "DIMENSION"))
                )
        )
        (ss::del s)
      )
      (if (> (&DRAG e 39) 0) 
        (progn 
          (if (setq e1 (&DRAG e 330)) (progn (react e) (react e1) (entdel e1)))
        )
      )
    )
  )
  (Defun inst (p0 lv / r r1 e e1 l) 
    (if (atom (setq r (cadr lv))) 
      (progn (setq p0 (mapcar '+ p0 (car lv))) 
             (entmake 
               (list '(0 . "Lwpolyline") 
                     '(100 . "AcDbEntity")
                     '(67 . 0)
                     (cons 8 lac)
                     '(100 . "AcDbPolyline")
                     '(90 . 2)
                     '(70 . 1)
                     (cons 43 pl)
                     (cons 10 (@wcs (list (- (car p0) r) (cadr p0))))
                     (cons 40 pl)
                     (cons 41 pl)
                     '(42 . 1.0)
                     (cons 10 (@wcs (list (+ (car p0) r) (cadr p0))))
                     (cons 40 pl)
                     (cons 41 pl)
                     '(42 . 1.0)
               )
             )
             (setq e (entlast))
             (if (setq r1 (caddr lv)) 
               (progn 
                 (entmake 
                   (list '(0 . "Lwpolyline") 
                         '(100 . "AcDbEntity")
                         '(67 . 0)
                         (cons 8 lac)
                         '(100 . "AcDbPolyline")
                         '(90 . 2)
                         '(70 . 1)
                         (cons 43 pl)
                         co
                         (cons 10 (@wcs (list (- (car p0) r1) (cadr p0))))
                         (cons 40 pl)
                         (cons 41 pl)
                         '(42 . 1.0)
                         (cons 10 (@wcs (list (+ (car p0) r1) (cadr p0))))
                         (cons 40 pl)
                         (cons 41 pl)
                         '(42 . 1.0)
                   )
                 )
                 (setq e1 (entlast))
               )
               (setq e1 nil)
             )
      )
      (progn 
        (if (equal (car lv) (last lv) 1.0) (setq lv (reverse (cdr (reverse lv)))))
        (setq lpo (list '(0 . "Lwpolyline") 
                        '(100 . "AcDbEntity")
                        '(67 . 0)
                        (cons 8 lac)
                        '(100 . "AcDbPolyline")
                        (cons 90 (length lv))
                        '(70 . 1)
                        (cons 43 pl)
                  )
        )
        (foreach p lv 
          (setq p   (mapcar '+ p0 p)
                p   (@wcs p)
                lpo (append lpo 
                            (list (cons 10 p) 
                                  (cons 40 pl)
                                  (cons 41 pl)
                                  '(42 . 0.0)
                            )
                    )
          )
          (if ti (setq l (cons p l)))
        )
        (entmake lpo)
        (setq e  (entlast)
              e1 nil
        )
      )
    )
    (cond 
      ((and tf e1)
       (@htas t)
       (command ".bhatch" "p" "s" "s" e e1 "" "")
       (@htas nil)
       (ssadd (entlast) ssh)
      )
      (tf
       (@htas t)
       (command ".bhatch" "p" "s" "s" e "" "")
       (@htas nil)
       (ssadd (entlast) ssh)
      )
    )
  )
  (defun tidy (a) 
    (while (> a (- pi 1e-6)) (setq a (- a pi)))
    (while (minusp (+ a 1e-6)) (setq a (+ a pi)))
    a
  )
  (defun rot (tf p0 l1 l2 lp / a a1 a2 l ang emx emy dis) 
    (cond 
      ((atom (cadr l1))
       (setq a (angle (car l1) p0)
             a (tidy a)
       )
      )
      ((atom (cadr l2))
       (setq a (angle (car l2) p0)
             a (tidy a)
       )
      )
      (t
       (setq a1 (angle (car l1) (cadr l1))
             a2 (angle (car l2) (cadr l2))
             a1 (tidy a1)
             a2 (tidy a2)
             a  (min a1 a2)
       )
      )
    )
    (if (not (equal a 0 1e-6)) 
      (if tf 
        (setq lp (mapcar 
                   '(lambda (p) 
                      (polar '(0 0 0) 
                             (+ a (angle '(0 0 0) p))
                             (distance p '(0 0 0))
                      )
                    )
                   lp
                 )
        )
        (progn 
          (if (= ex 0) 
            (setq ang 0
                  dis 0
            )
            (setq dis (sqrt (+ (* ex ex) (* ey ey)))
                  ang (atan (/ (abs ey) (abs ex) 1.0))
            )
          )
          (cond 
            ((and (< ex 0) (> ey 0)) (setq ang (+ ang _pi2)))
            ((and (< ex 0) (< ey 0)) (setq ang (+ ang pi)))
            ((and (> ex 0) (< ey 0)) (setq ang (+ ang (* 1.5 pi))))
          )
          (setq emx (- (* dis (cos (+ ang a))) ex)
                emy (- (* dis (sin (+ ang a))) ey)
          )
          (if (/= hzh 8) 
            (setq lp (mapcar '(lambda (p) (list (+ (car p) emx) (+ (cadr p) emy))) 
                             lp
                     )
            )
            (if (= (length lp) 2) 
              (setq lp (list (list (+ (car (car lp)) emx) (+ (cadr (car lp)) emy)) 
                             (cadr lp)
                       )
              )
              (setq lp (list (list (+ (car (car lp)) emx) (+ (cadr (car lp)) emy)) 
                             (cadr lp)
                             (caddr lp)
                       )
              )
            )
          )
        )
      )
    )
    lp
  )
  (setq pl (&GSYS "多义线宽度")
        pl (* (cadr (&SWAP t)) (if pl pl 0.5))
  )
  (if ti (setq pl 0))
  (if (= pl 0) (setq lac (&LJIG "平面柱子" t)) (setq lac (&LJIG "平面柱子粗线" t)))
  (setq co '(39 . 1))
  (setvar "plinewid" pl)
  (if tf (&LJIG "平面柱子填充" t))
  (while 
    (if sm 
      (setq p2 nil
            p1 (&OSNP "\r点取柱插入点<退出>: ")
      )
      (and (setq p1 (&OSNP "\r点取柱插入区域第一角点<退出>: ")) 
           (setq p2 (&OSNP p1 "\r点取柱插入区域第二角点<退出>: " t))
           (progn 
             (if 
               (setq ss (ssget "c" 
                               p1
                               p2
                               (list 
                                 (cons 8 
                                       (&LJIG 
                                         "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线,平面构造柱,平面构造柱粗线,平面构造柱虚线,平面构造柱粗虚线"
                                       )
                                 )
                                 '(0 . "lwpolyline")
                               )
                        )
               )
               (progn (rhatch ss) (ss::del ss))
             )
             (setq ss (ssget "c" 
                             p1
                             p2
                             (list (cons 8 (&LJIG "平面轴线")) 
                                   '(0 . "line,arc,circle")
                             )
                      )
             )
           )
           (setq si  0
                 smx (sslength ss)
           )
           (> smx 1)
      )
    )
    (setq ssh (ssadd))
    (if p2 
      (progn 
        (while (< si smx) 
          (setq e  (ssname ss si)
                si (1+ si)
                lp (if (= (&DRAG e 0) "LINE") 
                     (cons (list (&DRAG 10) (&DRAG 11)) lp)
                     (cons (list (&DRAG 10) (&DRAG 40) (&DRAG 50) (&DRAG 51)) lp)
                   )
          )
        )
        (setq p1 (@u2dcs p1)
              p2 (@u2dcs p2)
              x1 (car p1)
              x2 (car p2)
              y1 (cadr p1)
              y2 (cadr p2)
        )
        (if (> x1 x2) (&PMLAY "x1" "x2"))
        (if (> y1 y2) (&PMLAY "y1" "y2"))
        (while (setq p1 (car lp)) 
          (foreach p2 (setq lp (cdr lp)) 
            (foreach p (apply '&ORDR (append p1 p2)) 
              (if 
                (and (<= x1 (car (@u2dcs p)) x2) 
                     (<= y1 (cadr (@u2dcs p)) y2)
                     (not (@memb p ll (* 0.01 &sp)))
                )
                (progn (inst p (rot tr p p1 p2 lv)) (setq ll (cons p ll)))
              )
            )
          )
        )
      )
      (inst p1 lv)
    )
    (setq ll nil)
    (if (> (sslength ssh) 0) (command ".draworder" ssh "" "b"))
  )
)
(setfunhelp "c:Chyzh" "Tssd" "CHYZH")
(Defun c:Chyzh (/ l ex ey hzh) 
  (defun #do_edit () 
    (cond 
      ((= $key "er")
       (if (#isnum 10. 10000) 
         (progn (set_tile "sr" $value) 
                (if (and (= ty "rc") (> et er)) 
                  (progn (setq et er) 
                         (set_tile "et" (&RTXT et))
                         (set_tile "st" (&RTXT et))
                  )
                )
         )
       )
      )
      ((and (= $key "et") (= ty "rm"))
       (&PMLAY "et" "ea")
       (if (#isnum 3. nil) (set_tile "st" (&RTXT (* 10 et))))
       (&PMLAY "et" "ea")
      )
      ((= $key "et") (if (#isnum 0. (float er)) (set_tile "st" $value)))
      ((= $key "ex") (if (#isnum nil nil) (set_tile "sx" $value)))
      ((= $key "ey") (if (#isnum nil nil) (set_tile "sy" $value)))
    )
    (#drw_img)
  )
  (defun #do_sld (/ st vl) 
    (#cls)
    (cond 
      ((and (= $key "st") (= ty "rm"))
       (setq vl (/ (atoi $value) 10))
       (if (and (< vl 3)) 
         (progn (setq ea 3) 
                (set_tile "et" "3")
                (set_tile "st" "30")
                (set_tile "error" "**最小边数为: 3")
         )
         (progn (set_tile "et" (&RTXT vl)) (setq ea vl))
       )
      )
      ((= $key "st")
       (if (> (atof $value) er) 
         (progn (setq et er) 
                (set_tile "et" (&RTXT er))
                (set_tile "st" (&RTXT er))
                (set_tile "error" "**壁厚应当小于半径！")
         )
         (progn (set_tile "et" $value) (setq et (atof $value)))
       )
      )
      ((setq st (strcat "e" (substr $key 2)))
       (set_tile st $value)
       (set (read st) (atof $value))
       (if (and (= st "er") (= ty "rc") (> et er)) 
         (progn (setq et er) (set_tile "et" (&RTXT et)) (set_tile "st" (&RTXT et)))
       )
      )
    )
    (#drw_img)
  )
  (defun #do_rad (/ st vl vs) 
    (if (= (setq ty (get_tile "ty")) "rc") 
      (progn (if (> et er) (setq et er)) 
             (setq st "壁厚"
                   vl et
                   vs et
             )
      )
      (setq st "边数"
            vl ea
            vs (* 10 ea)
      )
    )
    (set_tile "sw" st)
    (set_tile "et" (&RTXT vl))
    (set_tile "st" (&RTXT vs))
    (#drw_img)
  )
  (defun getpt (xc yc r n / a0 a1 lp) 
    (setq a0 (/ (+ pi pi) (if (minusp r) (- n) n)))
    (cond 
      ((zerop (rem n 4))
       (setq a1 (* 0.5 a0)
             r  (abs r)
             lp (list (polar (list xc yc) a1 r))
       )
      )
      ((zerop (rem n 2))
       (setq a1 0
             r  (abs r)
             lp (list (list (+ xc r) yc))
       )
      )
      (t
       (setq a1 (* (if (minusp r) -0.5 0.5) pi)
             lp (list (list xc (+ yc r)))
             r  (abs r)
       )
      )
    )
    (repeat n 
      (setq a1 (+ a1 a0)
            lp (cons (polar (list xc yc) a1 r) lp)
      )
    )
    (reverse lp)
  )
  (defun #drw_img (/ xc yc lp p1 p2) 
    (if (> isc (/ x0 er 1.)) (setq isc (/ x0 er 1.)))
    (start_image "img")
    (fill_image 0 0 w0 h0 -2)
    (vector_image x0 0 x0 h0 253)
    (vector_image 0 y0 w0 y0 253)
    (setq xc (+ x0 (fix (* ex isc)))
          yc (- y0 (fix (* ey isc)))
    )
    (vector_image xc (- yc 10) xc (+ 10 yc) 1)
    (vector_image (- xc 10) yc (+ xc 10) yc 1)
    (setq lp (getpt xc yc (* er isc -1) (if (= ty "rc") 30 (fix ea)))
          p1 (car lp)
    )
    (foreach p2 lp 
      (vector_image (fix (car p1)) 
                    (fix (cadr p1))
                    (fix (car p2))
                    (fix (cadr p2))
                    2
      )
      (setq p1 p2)
    )
    (if (and (= ty "rc") (/= et 0) (/= et er)) 
      (progn 
        (setq lp (getpt xc yc (* (- et er) isc) 30)
              p1 (car lp)
        )
        (foreach p2 lp 
          (vector_image (fix (car p1)) 
                        (fix (cadr p1))
                        (fix (car p2))
                        (fix (cadr p2))
                        3
          )
          (setq p1 p2)
        )
      )
    )
    (end_image)
  )
  (defun shdcl (/ er et ea w0 x0 h0 y0 tf ti isc ty sm) 
    (if (and (setq ty (&GPTS "Tssd/Dcl_Myj/CirColu")) (/= ty "")) 
      (progn (mapcar 'set '(ty er et ea ex ey tf ti) (&PLCN ty "\t")) 
             (setq er (atoi er)
                   et (atoi et)
                   ea (atoi ea)
                   ex (atoi ex)
                   ey (atoi ey)
             )
      )
      (setq ty "rc"
            er 200
            et 200
            ea 6
            ex 0
            ey 0
            tf "0"
            ti "1"
      )
    )
    (if (= ty "rc") (setq hzh 8) (setq hzh 9))
    (if (new_dialog "ddcolur" (lib::dcl "Column")) 
      (progn 
        (setq w0  (dimx_tile "img")
              x0  (/ w0 2)
              h0  (dimy_tile "img")
              y0  (/ h0 2)
              isc (/ y0 600 1.)
        )
        (set_tile "er" (&RTXT er))
        (set_tile "sr" (&RTXT er))
        (set_tile "ex" (&RTXT ex))
        (set_tile "sx" (&RTXT ex))
        (set_tile "ey" (&RTXT ey))
        (set_tile "sy" (&RTXT ey))
        (set_tile "ty" ty)
        (set_tile "tf" tf)
        (set_tile "ti" ti)
        (#do_rad)
        (action_tile "er" "(#do_edit)")
        (action_tile "et" "(#do_edit)")
        (action_tile "ex" "(#do_edit)")
        (action_tile "ey" "(#do_edit)")
        (action_tile "sr" "(#do_sld)")
        (action_tile "st" "(#do_sld)")
        (action_tile "sx" "(#do_sld)")
        (action_tile "sy" "(#do_sld)")
        (action_tile "rc" "(setq hzh 8)(#do_rad)")
        (action_tile "rm" "(setq hzh 9)(#do_rad)")
        (action_tile "tf" "(setq tf $value)")
        (action_tile "ti" "(setq ti $value)")
        (action_tile "sigl" "(done_dialog 1)")
        (action_tile "mult" "(done_dialog 2)")
        (action_tile "help" "(help \"Tssd\" \"CHYZH\")")
        (if (/= (setq sm (start_dialog)) 0) 
          (progn 
            (&GLAY 
              "Tssd/Dcl_Myj/CirColu"
              (strcat ty 
                      "\t"
                      (&RTXT er)
                      "\t"
                      (&RTXT et)
                      "\t"
                      (&RTXT ea)
                      "\t"
                      (&RTXT ex)
                      "\t"
                      (&RTXT ey)
                      "\t"
                      tf
                      "\t"
                      ti
              )
            )
            (&SWAP T)
            (cond 
              ((and (= ty "rc") (/= et 0) (/= er et))
               (list (= sm 1) 
                     (= tf "1")
                     (= ti "1")
                     nil
                     (list (list (* &sc ex) (* &sc ey)) 
                           (* &sc er)
                           (* &sc (- er et))
                     )
               )
              )
              ((= ty "rc")
               (list (= sm 1) 
                     (= tf "1")
                     (= ti "1")
                     nil
                     (list (list (* &sc ex) (* &sc ey)) (* &sc er))
               )
              )
              (t
               (list (= sm 1) 
                     (= tf "1")
                     (= ti "1")
                     nil
                     (getpt (* &sc ex) (* &sc ey) (* &sc er) ea)
               )
              )
            )
          )
        )
      )
    )
  )
  (if (and (> (&UTXT) -1) (setq l (shdcl))) (apply 'coin l))
  (&TSTY)
)
(setfunhelp "c:Chfzh" "Tssd" "CHFZH")
(Defun c:Chfzh (/ l #do_edit #do_edit #dwg_img getpt mcol shdcl ex ey er exx eyy err) 
  (defun #do_pop (/ l6) 
    (mapcar 'mode_tile 
            '("x1" "x2" "x3" "y1" "y2" "y3")
            (nth (atoi pl) 
                 '((1 0 1 1 0 1)
                   (0 0 0 0 0 0)
                   (0 0 0 0 0 0)
                   (0 0 0 1 0 0)
                   (1 0 0 0 0 1)
                   (0 0 1 0 0 0)
                  )
            )
    )
    (#drw_img)
  )
  (defun #do_edit (/ dist a1 a2) (#isnum 0 10000) (#drw_img))
  (defun zhupy (/ dist a1 a2) 
    (setq exx (get_tile "ex")
          ex  (atof exx)
          eyy (get_tile "ey")
          ey  (atof eyy)
          err (get_tile "er")
          er  (atof err)
    )
    (setq dist (sqrt (+ (* ex ex) (* ey ey))))
    (if (and (/= ex 0) (/= ey 0)) 
      (progn (setq a1 (* 180 (/ (atan (/ ey ex)) pi))) 
             (if (< ex 0) (setq a1 (+ a1 180)) (if (< ey 0) (setq a1 (+ a1 360))))
      )
      (if (and (= ex 0) (= ey 0)) 
        (setq a1 0.0)
        (if (= ex 0) 
          (if (> ey 0) (setq a1 90.0) (setq a1 -90.0))
          (if (> ex 0) (setq a1 0.0) (setq a1 180.0))
        )
      )
    )
    (setq a2 (+ er a1)
          a2 (* (/ a2 180.0) pi)
          ex (* dist (cos a2))
          ey (* dist (sin a2))
    )
    (#drw_img)
  )
  (defun getpt (xc yc x1 x2 x3 y1 y2 y3 a0 / lp) 
    (setq lp (list (list (- xc x2 x1) (+ yc y2 y1)) 
                   (list (- xc x2) (+ yc y2 y1))
                   (list (+ xc x2) (+ yc y2 y1))
                   (list (+ xc x2 x3) (+ yc y2 y1))
                   (list (- xc x2 x1) (+ yc y2))
                   (list (- xc x2) (+ yc y2))
                   (list (+ xc x2) (+ yc y2))
                   (list (+ xc x2 x3) (+ yc y2))
                   (list (- xc x2 x1) (- yc y2))
                   (list (- xc x2) (- yc y2))
                   (list (+ xc x2) (- yc y2))
                   (list (+ xc x2 x3) (- yc y2))
                   (list (- xc x2 x1) (- yc y2 y3))
                   (list (- xc x2) (- yc y2 y3))
                   (list (+ xc x2) (- yc y2 y3))
                   (list (+ xc x2 x3) (- yc y2 y3))
             )
    )
    (if (not (zerop a0)) 
      (setq a0 (/ (* a0 pi) 180)
            lp (mapcar 
                 '(lambda (p / a d) 
                    (setq a (angle (list xc yc) p)
                          d (distance (list xc yc) p)
                          p (polar (list xc yc) (+ a a0) d)
                    )
                  )
                 lp
               )
      )
    )
    (mapcar '(lambda (x) (nth x lp)) 
            (nth (atoi pl) 
                 '((5 6 10 9 5)
                   (0 3 7 6 10 11 15 12 8 9 5 4 0)
                   (1 2 6 7 11 10 14 13 9 8 4 5 1)
                   (4 7 11 10 14 13 9 8 4)
                   (1 2 6 7 11 9 1)
                   (0 2 14 12 8 9 5 4 0)
                  )
            )
    )
  )
  (defun #drw_img (/ xc yc lp p1 p2) 
    (setq lp  (/ w0 (max (+ x1 x2 x3) (+ y1 y2 y3)) 1.)
          isc (min isc lp)
          xc  (+ x0 (fix (* ex isc)))
          yc  (- y0 (fix (* ey isc)))
          lp  (getpt 
                xc
                yc
                (fix (* x1 isc))
                (fix (* isc x2 0.5))
                (fix (* x3 isc))
                (fix (* y1 isc -1))
                (fix (* isc y2 -0.5))
                (fix (* y3 isc -1))
                (- er)
              )
    )
    (start_image "img")
    (fill_image 0 0 w0 h0 -2)
    (vector_image x0 0 x0 h0 253)
    (vector_image 0 y0 w0 y0 253)
    (vector_image xc (- yc 10) xc (+ 10 yc) 1)
    (vector_image (- xc 10) yc (+ xc 10) yc 1)
    (setq p1 (car lp))
    (foreach p2 (cdr lp) 
      (vector_image (fix (car p1)) 
                    (fix (cadr p1))
                    (fix (car p2))
                    (fix (cadr p2))
                    2
      )
      (setq p1 p2)
    )
    (end_image)
  )
  (defun shdcl (/ er h0 isc w0 x0 x1 x2 x3 y0 y1 y2 y3 pl tff tfi tfr sm) 
    (if (and (setq pl (&GPTS "Tssd/Dcl_Myj/RectColu")) (/= pl "")) 
      (progn 
        (mapcar 'set '(pl x1 x2 x3 y1 y2 y3 ex ey er tff tfi tfr) (&PLCN pl "\t"))
        (if (null tfr) (setq tfr "0"))
        (setq x1 (atoi x1)
              x2 (atoi x2)
              x3 (atoi x3)
              y1 (atoi y1)
              y2 (atoi y2)
              y3 (atoi y3)
              ex (atoi ex)
              ey (atoi ey)
              er (atoi er)
        )
      )
      (setq pl  "0"
            x1  200
            x2  500
            x3  200
            y1  200
            y2  500
            y3  200
            ex  0
            ey  0
            er  0
            tff "0"
            tfi "1"
            tfr "0"
      )
    )
    (if (new_dialog "ddcoluc" (lib::dcl "Column")) 
      (progn 
        (setq w0  (dimx_tile "img")
              x0  (/ w0 2)
              h0  (dimy_tile "img")
              y0  (/ h0 2)
              isc (/ y0 600.)
        )
        (set_tile "pl" pl)
        (set_tile "x1" (&RTXT x1))
        (set_tile "x2" (&RTXT x2))
        (set_tile "x3" (&RTXT x3))
        (set_tile "y1" (&RTXT y1))
        (set_tile "y2" (&RTXT y2))
        (set_tile "y3" (&RTXT y3))
        (set_tile "ex" (&RTXT ex))
        (set_tile "ey" (&RTXT ey))
        (set_tile "er" (&RTXT er))
        (set_tile "fill" tff)
        (set_tile "intl" tfi)
        (set_tile "rote" tfr)
        (zhupy)
        (#do_pop)
        (foreach x '("x1" "x2" "x3" "y1" "y2" "y3") (action_tile x "(#do_edit)"))
        (action_tile "ex" "(#isnum nil nil)(zhupy)")
        (action_tile "ey" "(#isnum nil nil)(zhupy)")
        (action_tile "er" "(#isnum 0. 360.)(zhupy)")
        (action_tile "pl" "(setq pl $value) (#do_pop)")
        (action_tile "fill" "(setq tff $value)")
        (action_tile "intl" "(setq tfi $value)")
        (action_tile "rote" "(setq tfr $value)")
        (action_tile "sigl" "(zhupy)(done_dialog 1)")
        (action_tile "mult" "(zhupy)(done_dialog 2)")
        (action_tile "help" "(help \"Tssd\" \"CHFZH\")")
        (if (/= (setq sm (start_dialog)) 0) 
          (progn 
            (&GLAY 
              "Tssd/Dcl_Myj/RectColu"
              (strcat pl 
                      "\t"
                      (&RTXT x1)
                      "\t"
                      (&RTXT x2)
                      "\t"
                      (&RTXT x3)
                      "\t"
                      (&RTXT y1)
                      "\t"
                      (&RTXT y2)
                      "\t"
                      (&RTXT y3)
                      "\t"
                      exx
                      "\t"
                      eyy
                      "\t"
                      err
                      "\t"
                      tff
                      "\t"
                      tfi
                      "\t"
                      tfr
              )
            )
            (&SWAP t)
            (list (= sm 1) 
                  (= tff "1")
                  (= tfi "1")
                  (= tfr "1")
                  (getpt 
                    (* &sc ex)
                    (* &sc ey)
                    (* &sc x1)
                    (* &sc x2 0.5)
                    (* &sc x3)
                    (* &sc y1)
                    (* &sc y2 0.5)
                    (* &sc y3)
                    er
                  )
            )
          )
        )
      )
    )
  )
  (if (and (> (&UTXT) -1) (setq l (shdcl))) (apply 'coin l))
  (&TSTY)
)
(setfunhelp "c:Zhtsh" "Tssd" "ZHTSH")
(Defun c:Zhtsh (/ e e1 la ps si smx ss ssh) 
  (if 
    (and (> (&UTXT) -1) 
         (setq la (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面构造柱粗虚线"))
         (setq ss (&DSTR 
                    "\n选择要填实的柱子<退出>："
                    (list (cons 8 la) '(0 . "lwpolyline") '(39 . 0))
                  )
         )
    )
    (progn (&LJIG "平面柱子填充" t) 
           (setq smx (sslength ss)
                 si  0
           )
           (while (< si smx) 
             (setq e  (ssname ss si)
                   si (1+ si)
             )
             (if (/= (&DRAG e 102) "{ACAD_REACTORS") 
               (progn (@htas t) 
                      (if 
                        (and (setq e1 (entnext e)) 
                             (= (&DRAG e1 0) "LWPOLYLINE")
                             (> (&DRAG 39) 0)
                        )
                        (command ".-bhatch" "p" "s" "s" e e1 "" "")
                        (command ".-bhatch" "p" "s" "s" e "" "")
                      )
                      (&DCOL (entlast))
                      (@htas nil)
               )
             )
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Zhkx" "Tssd" "ZHKX")
(Defun c:Zhkx (/ la ss rhatch si tf e ptl p0 p1 pt dist s) 
  (defun rhatch (ss / e e1 tf si react) 
    (defun react (e / el tf tf1 i) 
      (setq tf t)
      (if (setq e (entget e)) 
        (progn 
          (foreach x e 
            (setq i (car x))
            (if (equal x '(102 . "{ACAD_REACTORS")) (setq tf nil))
            (if (zerop i) (setq tf1 (= (cdr x) "HATCH")))
            (if (and tf1 (or (= i 71) (= i 97))) (setq x (cons i 0)))
            (if (and tf1 (= i 330) (not (ssmemb (cdr x) ss))) (react (cdr x)))
            (if (and tf (/= i 330)) (setq el (cons x el)))
            (if (equal x '(102 . "}")) (setq tf t))
          )
          (entmod (reverse el))
        )
      )
    )
    (setq si 0
          tf t
    )
    (while (setq e (ssname ss si)) 
      (setq si (1+ si))
      (if (setq e1 (&DRAG e 330)) 
        (progn (setq tf nil) (react e) (react e1) (entdel e1))
      )
    )
    tf
  )
  (if 
    (and (> (&UTXT) -1) 
         (setq la (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面构造柱粗虚线"))
         (setq ss (&DSTR 
                    "\n选择要空心的柱子<退出>："
                    (list (cons 8 la) '(0 . "lwpolyline") '(39 . 0))
                  )
         )
    )
    (progn (setq si 0) 
           (while (setq e (ssname ss si)) 
             (setq si  (1+ si)
                   ptl (&DRAG e 10)
                   s   nil
             )
             (if (= 2 (length ptl)) 
               (setq p0   (car ptl)
                     p1   (last ptl)
                     pt   (&N2S p0 p1)
                     dist (* 0.5 (distance p0 p1))
                     ptl  (list p0 
                                (polar pt _pi2 dist)
                                p1
                                (polar pt (* 1.5 pi) dist)
                          )
               )
             )
             (setq s (ssget "cp" 
                            ptl
                            (list (cons 8 (&LJIG "平面柱子填充")) (cons 0 "HATCH"))
                     )
             )
             (if s 
               (progn 
                 (if (<= (read (@substr (getvar "acadver") 1 4)) 16.0) 
                   (setq tf (rhatch ss))
                   (setq tf t)
                 )
                 (if tf (ss::del s))
               )
             )
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Jxchl" "Tssd" "JXCHL")
(defun c:Jxchl (/ e l lp si smx ss p1 p2 tfz coltrim) 
  (defun coltrim (p1 p2 lp / pout a a1 a2 e e48 e6 el la lay ll lp1 lx p3 r r0 si smx 
                  ss st s erl
                 ) 
    (defun poutl (p llp / tf r lp) 
      (while (and (null tf) (setq lp (car llp))) 
        (setq llp (cdr llp)
              tf  (if (atom (setq r (cadr lp))) 
                    (< (distance p (car lp)) r)
                    (@pinl p lp -1.)
                  )
        )
      )
      (null tf)
    )
    (setq la  (&LJIG 
                (strcat "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线," 
                        "平面连梁,平面连梁实线,平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
                )
              )
          lay la
    )
    (if (setq ss (ssget "c" p1 p2 (list (cons 8 la) '(0 . "line,arc")))) 
      (progn 
        (setq si  0
              smx (sslength ss)
              st  "\r正在处理交线: "
        )
        (princ (strcat "\n开始【交线处理】，共选择了梁(或墙)线" (itoa smx) "根。\n"))
        (while (< si smx) 
          (if (zerop (rem si 10)) (princ (strcat st (itoa si))))
          (setq e   (ssname ss si)
                el  (entget e)
                si  (1+ si)
                la  (assoc 8 el)
                e6  (assoc 6 el)
                e48 (assoc 48 el)
          )
          (if (null e6) (setq e6 '(6 . "bylayer")))
          (if (null e48) (setq e48 '(48 . 1.0)))
          (if (= (&DRAG e 0) "LINE") 
            (progn 
              (setq p1  (&DRAG 10)
                    p2  (&DRAG 11)
                    lx  nil
                    lp1 nil
              )
              (foreach l lp 
                (if (listp (cadr l)) 
                  (setq erl l)
                  (setq erl (list (polar (car l) 0 (* 0.5 (cadr l))) 
                                  (polar (car l) _pi2 (* 0.5 (cadr l)))
                                  (polar (car l) pi (* 0.5 (cadr l)))
                                  (polar (car l) (* 1.5 pi) (* 0.5 (cadr l)))
                            )
                  )
                )
                (if (setq s (ssget "wp" erl (list (cons 8 lay)))) (ss::del s))
                (setq p3 (car l)
                      ll nil
                )
                (if (atom (setq r (cadr l))) 
                  (setq ll (&ORDR p1 p2 p3 r))
                  (foreach p4 (cdr l) 
                    (if (setq p3 (inters p1 p2 p3 p4)) (setq ll (cons p3 ll)))
                    (setq p3 p4)
                  )
                )
                (if ll (setq lp1 (cons l lp1)))
                (foreach p ll (setq lx (cons (cons (distance p p1) p) lx)))
              )
              (if lx 
                (progn 
                  (setq lx (mapcar 'cdr (@ran3 lx))
                        lx (append lx (list p2))
                  )
                  (entdel e)
                  (foreach p2 lx 
                    (if (and (> (distance p1 p2) 1.) (poutl (&N2S p1 p2) lp1)) 
                      (entmake 
                        (list '(0 . "line") 
                              la
                              e6
                              e48
                              (cons 10 (@wcs p1))
                              (cons 11 (@wcs p2))
                        )
                      )
                    )
                    (setq p1 p2)
                  )
                )
              )
            )
            (progn 
              (setq p1  (&DRAG 10)
                    r0  (&DRAG 40)
                    a1  (&DRAG 50)
                    a2  (&DRAG 51)
                    lx  nil
                    lp1 nil
              )
              (foreach l lp 
                (setq p3 (car l)
                      ll nil
                )
                (if (atom (setq r (cadr l))) 
                  (setq ll (&ORDR p1 r0 a1 a2 p3 r))
                  (foreach p4 (cdr l) 
                    (setq ll (append ll (&ORDR p1 r0 a1 a2 p3 p4))
                          p3 p4
                    )
                  )
                )
                (if ll (setq lp1 (cons l lp1)))
                (foreach p ll 
                  (setq a (angle p1 p))
                  (if (< a (- a1 1e-4)) (setq a (+ a pi pi)))
                  (setq lx (cons (cons (- a a1) a) lx))
                )
              )
              (if lx 
                (progn 
                  (setq lx (mapcar 'cdr (@ran3 lx))
                        lx (append lx (list a2))
                  )
                  (entdel e)
                  (foreach a2 lx 
                    (if 
                      (and (> (- a2 a1) 1e-3) 
                           (poutl (polar p1 (* 0.5 (+ a1 a2)) r0) lp1)
                      )
                      (entmake 
                        (list '(0 . "arc") 
                              la
                              e6
                              e48
                              (cons 10 (@wcs p1))
                              (cons 40 r0)
                              (cons 50 (@wcs a1))
                              (cons 51 (@wcs a2))
                        )
                      )
                    )
                    (setq a1 a2)
                  )
                )
              )
            )
          )
        )
        (princ "\r交线处理完毕!                   \n")
      )
    )
  )
  (if 
    (and (> (&UTXT) -1) 
         (princ "\n用窗口选择要进行交线处理的区域: ")
         (setq p1 (&OSNP "\n窗口第一角<退出>: "))
         (setq p2 (&OSNP p1 "\t另一角<退出>: " t))
         (progn (setq tfz (@zoome 0 (list p1 p2))) t)
         (setq ss (ssget "c" 
                         p1
                         p2
                         (list 
                           (cons 8 
                                 (&LJIG 
                                   "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线,详图柱子,详图柱子粗线,详图柱子虚线,详图柱子粗虚线"
                                 )
                           )
                           '(0 . "lwpolyline")
                           '(39 . 0)
                         )
                  )
         )
    )
    (progn 
      (setq smx (sslength ss)
            si  0
      )
      (while (< si smx) 
        (setq e  (ssname ss si)
              si (1+ si)
              l  (&DRAG e 10)
        )
        (if (or (equal (&DRAG 42) '(1 1)) (equal (&DRAG 42) '(-1 -1))) 
          (setq l (list (&N2S (car l) (cadr l)) 
                        (* 0.5 (distance (car l) (cadr l)))
                  )
          )
          (if (not (equal (car l) (last l))) (setq l (cons (last l) l)))
        )
        (setq lp (cons l lp))
      )
      (coltrim p1 p2 lp)
      (if tfz (command "zoom" "p"))
    )
  )
  (&TSTY)
)
(setfunhelp "c:Zhchcbzh" "Tssd" "ZHCHCBZH")
(defun c:Zhchcbzh (/ a1 a2 e e42 lcp ldm lep lp mm ndim p1 p2 pc pvc r sdm si sl ss 
                   tfz vh getan mxdis dimang cpudimp dimp1 dimln
                  ) 
  (Defun getan (e p0) 
    (if (= (&DRAG e 0) "LINE") 
      (- (angle (&DRAG 10) (&DRAG 11)) _pi2)
      (angle p0 (&DRAG 10))
    )
  )
  (Defun mxdis (p a lp / l pt px) 
    (setq pt (polar p (+ a _pi2) 100)
          l  nil
    )
    (foreach px lp (setq l (cons (&MIDP px p pt) l)))
    (setq l (@ran2 l))
    (list (car l) (last l))
  )
  (Defun dimang (lcp lep / a1 a2 d d0 e e1 e2 l la le p1 p2 pt sax sl) 
    (if 
      (setq sax (ssget "cp" lcp (list (cons 8 (&LJIG "平面轴线")) '(0 . "LINE,ARC"))))
      (progn (setq sl (sslength sax)) 
             (while (> sl 0) 
               (setq sl (1- sl)
                     e  (ssname sax sl)
                     le (cons e le)
               )
             )
             (while 
               (setq e1 (car le)
                     le (cdr le)
               )
               (foreach e2 le 
                 (if (and (setq pt (car (&ORDR e1 e2))) (@pinl pt lcp (- mm))) 
                   (setq le nil
                         a1 (getan e1 pt)
                         a2 (getan e2 pt)
                   )
                   (setq pt nil)
                 )
               )
             )
      )
    )
    (cond 
      (pt)
      ((atom (cadr lep))
       (setq a1 0
             a2 _pi2
             pt nil
       )
      )
      (T
       (setq p1 (last lep))
       (if (equal p1 (car lep) mm) (setq lep (cdr lep)))
       (setq d0 -100
             la nil
       )
       (foreach p2 lep 
         (setq a2 (angle p1 p2))
         (if (> a2 pi) (setq a2 (- a2 pi)))
         (if (not (@memb a2 la 0.01)) 
           (progn 
             (setq la (cons a2 la)
                   l  (mxdis p2 a2 lep)
                   d  (abs (- (cadr l) (car l)))
             )
             (cond 
               ((minusp d0)
                (setq d0 d
                      a1 a2
                )
               )
               ((equal d d0 mm)
                (if (< (abs (sin a2)) (abs (sin a1))) (setq a1 a2))
               )
               ((< d0 d)
                (setq d0 d
                      a1 a2
                )
               )
             )
           )
         )
         (setq p1 p2)
       )
       (setq a2 (+ a1 _pi2)
             pt nil
       )
      )
    )
    (list pt a1 a2)
  )
  (Defun dimp1 (pc p0 ax x1 x2 ldy / ay) 
    (setq ay (+ ax _pi2))
    (mapcar 
      '(lambda (at dy / pt p1 p2 l1 l2) 
         (setq pt (polar p0 ay dy)
               p1 (polar pt ax x1)
               p2 (polar pt ax x2)
               pt (polar (&N2S p1 p2) (- at _pi2) (* 8 &sp))
               l1 (list (@tidy at) pt p1)
               l2 (list p2)
         )
         (if pc (setq l2 (cons (inters p1 p2 pc (polar pc ay 100) nil) l2)))
         (append l1 l2)
       )
      (list ax (+ ax pi))
      ldy
    )
  )
  (Defun cpudimp (pc ax lep / lx ly p0 r) 
    (setq p0 (car lep))
    (if (atom (setq r (cadr lep))) 
      (dimp1 pc p0 ax (- r) r (list (- r) r))
      (progn 
        (setq lx (mxdis p0 ax lep)
              ly (mxdis p0 (+ ax _pi2) lep)
        )
        (dimp1 pc p0 ax (car lx) (cadr lx) ly)
      )
    )
  )
  (Defun dimln (l / a p1 p2 pt dim1) 
    (Defun dim1 (ang p13 p14 p10) 
      (if (> (distance p13 p14) (* 0.5 &sc)) 
        (entmake 
          (list '(0 . "DIMENSION") 
                '(100 . "AcDbEntity")
                '(100 . "AcDbDimension")
                (cons 10 (@wcs p10))
                '(11 0. 0. 0.)
                '(70 . 32)
                '(100 . "AcDbAlignedDimension")
                (cons 13 (@wcs p13))
                (cons 14 (@wcs p14))
                (cons 50 ang)
                '(100 . "AcDbRotatedDimension")
          )
        )
      )
    )
    (mapcar 'set '(a pt p1 p2) l)
    (dim1 a p1 p2 pt)
    (if (= (length l) 5) (dim1 a p2 (last l) pt))
  )
  (if 
    (and (> (&UTXT) -1) 
         (setq sl (list (cons 8 (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线")) 
                        '(0 . "lwpolyline")
                        '(39 . 0)
                  )
         )
         (if (setq ss (ssget "i" sl)) 
           t
           (progn (&CHSC 1) (setq ss (&DSTR "\n选择要标注的柱子<退出>: " sl)) (&CHSC))
         )
    )
    (progn 
      (setq si   0
            sl   (sslength ss)
            ndim (atoi (&GPTS "appdata/tssd/ColDim/type"))
            pvc  (getvar "viewctr")
            vh   (getvar "viewsize")
            mm   (* 0.01 &sp)
      )
      (&LJIG "平面柱子尺寸" t)
      (&GVAL)
      (while (< si sl) 
        (setq e   (ssname ss si)
              si  (1+ si)
              lp  (&DRAG e 10)
              e42 (&DRAG 42)
        )
        (cond 
          ((or (equal e42 '(1.0 1.0)) (equal e42 '(-1.0 -1.0)))
           (setq p1  (car lp)
                 p2  (cadr lp)
                 r   (* 0.5 (distance p1 p2))
                 pc  (&N2S p1 p2)
                 lcp (@arpl pc r nil nil)
                 lep (list pc r)
           )
          )
          ((> (length lp) 2)
           (setq lcp lp
                 lep lp
           )
          )
          (t (setq lcp nil))
        )
        (if lcp 
          (progn (setq tfz (or (@zoome &sp lcp) tfz)) 
                 (mapcar 'set '(p1 a1 a2) (dimang lcp lep))
                 (setq ldm (@ran4 (append (cpudimp p1 a1 lep) (cpudimp p1 a2 lep))))
                 (if (> (abs (sin (caar ldm))) (abs (sin (caadr ldm)))) 
                   (setq ldm (cons (last ldm) ldm))
                 )
                 (setq e   (entlast)
                       sdm (ssadd)
                 )
                 (dimln (nth (if (zerop (logand ndim 1)) 0 2) ldm))
                 (dimln (nth (if (zerop (logand ndim 2)) 1 3) ldm))
                 (while (setq e (entnext e)) (ssadd e sdm))
                 (&CODE sdm)
          )
        )
      )
      (if tfz (command ".zoom" "c" pvc vh))
    )
  )
  (&TSTY)
)
(setfunhelp "c:Zhywfd" "Tssd" "Zhywfd")
(defun c:Zhywfd (/ ss layC layD layA layT sca sp spp en pl) 
  (defun scale (pl / updim findgroup sss sA sD sT pintl pint ptl an ow el) 
    (Defun newp (p0 p) (polar p0 (angle p0 p) (* sca (distance p p0))))
    (defun updim (e / e3 el p10 p11 p13 p13n p14 p14n p15 p15n sd1 sc1) 
      (setq el  (entget e)
            e3  (&DRAG e 3)
            p10 (&DRAG e 10)
            p11 (&DRAG e 11)
            p13 (&DRAG e 13)
            p14 (&DRAG e 14)
      )
      (cond 
        ((wcmatch e3 "TSSD*")
         (&GVAL spp)
         (setq el   (subst (cons 3 (getvar "dimstyle")) (assoc 3 el) el)
               p13n (newp pint p13)
               p14n (newp pint p14)
               el   (subst (cons 13 (@wcs p13n)) (assoc 13 el) el)
               el   (subst (cons 14 (@wcs p14n)) (assoc 14 el) el)
         )
         (if (< (distance p13 p10) (distance p14 p10)) 
           (setq p10 (polar p13n (angle p13 p10) (distance p13 p10)))
           (setq p10 (polar p14n (angle p14 p10) (distance p14 p10)))
         )
         (setq p13 (&N2S p13 p14)
               p14 (&N2S p13n p14n)
               p11 (polar p14 (angle p13 p11) (distance p13 p11))
               el  (subst (cons 10 (@wcs p10)) (assoc 10 el) el)
               el  (subst (cons 11 (@wcs p11)) (assoc 11 el) el)
         )
         (entmod el)
        )
        ((wcmatch e3 "TSAN*")
         (&GVAL spp t)
         (setq el  (subst (cons 3 (getvar "dimstyle")) (assoc 3 el) el)
               p15 (&DRAG e 15)
         )
         (if (= (logand (&DRAG 70) 5) 5) 
           (setq p13n (newp pint p13)
                 p14n (newp pint p14)
                 p15n (newp pint p15)
                 p10  (newp pint p10)
                 p11  (newp pint p11)
                 el   (subst (cons 13 (@wcs p13n)) (assoc 13 el) el)
                 el   (subst (cons 14 (@wcs p14n)) (assoc 14 el) el)
                 el   (subst (cons 15 (@wcs p15n)) (assoc 15 el) el)
                 el   (subst (cons 10 (@wcs p10)) (assoc 10 el) el)
                 el   (subst (cons 11 (@wcs p11)) (assoc 11 el) el)
           )
           (setq p13 (&N2S p10 p15)
                 p10 (newp pint p10)
                 p15 (newp pint p15)
                 p14 (&N2S p10 p15)
                 p11 (polar p14 (angle p13 p11) (distance p13 p11))
                 el  (subst (cons 10 (@wcs p10)) (assoc 10 el) el)
                 el  (subst (cons 11 (@wcs p11)) (assoc 11 el) el)
                 el  (subst (cons 15 (@wcs p15)) (assoc 15 el) el)
           )
         )
         (entmod el)
        )
      )
    )
    (defun findgroup (s / sss e ee el e1 flag entl p10 p11 pt) 
      (setq sss (ssadd))
      (while (setq e (ssname s 0)) 
        (ssdel e s)
        (setq el (entget e)
              e1 (cdr (assoc 330 el))
        )
        (setq p10 (&DRAG e 10)
              p11 (&DRAG e 11)
        )
        (if (> (distance pint p10) (distance pint p11)) 
          (setq pt p11)
          (setq pt p10)
        )
        (if e1 
          (progn 
            (setq el   (entget e1)
                  flag (strcase (cdr (assoc 0 el)))
            )
            (if (wcmatch flag "GROUP") 
              (progn 
                (while (setq e (cdr (assoc 340 el))) 
                  (setq el (subst (cons 341 "旧") (assoc 340 el) el))
                  (ssadd e sss)
                )
                (command ".Move" sss "" pt (newp pint pt))
              )
            )
          )
        )
      )
    )
    (if (setq sA (ssget "cp" pl (list (cons 0 "LINE,ARC") (cons 8 layA)))) 
      (if (= (sslength sA) 2) 
        (if (= (length (setq pintl (&ORDR (ssname sA 0) (ssname sA 1)))) 1) 
          (setq pint (car pintl))
        )
      )
    )
    (if (not pint) (setq pint (&MGRP en)))
    (if pint 
      (progn (command ".Undo" "Mark") 
             (setq ow (&DRAG en 43))
             (command ".Scale" en "" pint 1.01)
             (setq ptl (&DRAG en 10))
             (if 
               (or (equal (&DRAG en 42) (list 1 1)) 
                   (equal (&DRAG en 42) (list -1 -1))
               )
               (setq p1  (car ptl)
                     p2  (cadr ptl)
                     an  (angle p1 p2)
                     dis (* 0.5 (distance p1 p2))
                     ptl (list p1 
                               (polar p1 (+ an _pi2) dis)
                               (polar p2 (+ an _pi2) dis)
                               p2
                               (polar p2 (- an _pi2) dis)
                               (polar p1 (- an _pi2) dis)
                               p1
                         )
               )
             )
             (command ".Undo" "Back")
             (setq sD (ssget "cp" ptl (list (cons 8 layD)))
                   sT (ssget "cp" ptl (list (cons 0 "LINE") (cons 8 layT)))
             )
             (command ".Scale" en "" pint sca)
             (foreach l (entget en) 
               (if (member (car l) '(40 41 43)) (setq l (cons (car l) ow)))
               (setq el (cons l el))
             )
             (entmod (reverse el))
             (if sT (findgroup sT))
             (if sD (while (setq e (ssname sD 0)) (updim e) (ssdel e sD)))
      )
    )
  )
  (if (< (&UTXT) 0) (exit))
  (setq layC (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线")
        layD (&LJIG "平面柱子尺寸")
        layA (&LJIG "平面轴线")
        layT (&LJIG "平面柱子编号")
  )
  (setq ss (&DSTR "\n选择要进行放大的柱子<退出>: " (list (cons 0 "LWPOLYLINE") (cons 8 layC))))
  (if ss 
    (progn (initget 6) 
           (setq sp (getint 
                      (strcat "\n输入现有图纸的绘图比例 1: <" (itoa (fix (/ &sp &sc))) ">")
                    )
           )
           (if (not sp) (setq sp (/ &sp &sc)))
           (initget 7)
           (setq spp (getint "\n输入柱子的放大后的绘图比例 1: "))
           (setq sca (/ sp spp 1.))
           (if (/= sca 1.) 
             (while (setq en (ssname ss 0)) 
               (ssdel en ss)
               (setq pl (&DRAG en 10))
               (scale pl)
             )
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Dzhbzh" "Tssd" "Dzhbzh")
(defun c:Dzhbzh (/ p_l dcl lay ss si str zg en el lay1 pt pt1 s flag fl no str cx) 
  (defun p_l (el / p pl epx epy pt dxy mdxy p0 len) 
    (setq epx 0
          epy 0
    )
    (while (setq p (cdr (assoc 10 el))) 
      (setq p   (@ucs p)
            pl  (append pl (list p))
            el  (subst (cons 11 "旧") (assoc 10 el) el)
            epx (+ epx (car p))
            epy (+ epy (cadr p))
      )
    )
    (if (equal (abs (cdr (assoc 42 el))) 1 1e-3) 
      (setq p0  (&N2S (car pl) (cadr pl))
            len (* 0.5 (distance (car pl) (cadr pl)))
            p0  (polar p0 (* 0.25 pi) len)
      )
      (progn 
        (setq len  (length pl)
              epx  (/ epx len)
              epy  (/ epy len)
              pt   (list epx epy)
              mdxy (+ (- (car (car pl)) epx) (- (cadr (car pl)) epy))
        )
        (while (setq p (car pl)) 
          (setq pl  (cdr pl)
                dxy (+ (- (car p) epx) (- (cadr p) epy))
          )
          (if (>= dxy mdxy) 
            (setq p0   p
                  mdxy dxy
            )
          )
        )
      )
    )
    p0
  )
  (defun dcl (/ csh hdsj what dia vslide) 
    (defun vslide (name img / x y) 
      (setq x (dimx_tile img))
      (setq y (dimy_tile img))
      (start_image img)
      (fill_image 0 0 x y -2)
      (slide_image 0 0 x (- y 5) name)
      (end_image)
    )
    (defun csh () 
      (set_tile "hi" (&RTXT zg))
      (set_tile "str" str)
      (vslide "Tssd(Zhb1)" "img1")
      (vslide "Tssd(Zhb2)" "img2")
      (vslide "Tssd(Zhb3)" "img3")
      (mode_tile (strcat "img" (itoa no)) 4)
      (set_tile "cx" cx)
    )
    (defun hdsj (n / nzg) 
      (if (and (> n 0) (< n 4)) 
        (progn (mode_tile (strcat "img" (itoa n)) 4) 
               (mode_tile (strcat "img" (itoa no)) 4)
               (setq no n)
        )
      )
      (setq nzg (atof (get_tile "hi"))
            cx  (get_tile "cx")
            str (get_tile "str")
      )
      (if (> nzg 0) 
        (setq zg nzg)
        (progn (set_tile "hi" (&RTXT zg)) (alert "**字高应为正数！**"))
      )
      (if (or (= $reason 4) (= n 0)) 
        (progn 
          (if (read str) 
            (progn (setq what -8) (done_dialog 0))
            (alert "**标注内容不能为空！**")
          )
        )
      )
    )
    (setq what 2
          dia  (lib::dcl "Column")
    )
    (while (> what 0) 
      (if (not (new_dialog "Dzhbzh" dia)) (exit))
      (csh)
      (action_tile "img1" "(hdsj 1)")
      (action_tile "img2" "(hdsj 2)")
      (action_tile "img3" "(hdsj 3)")
      (action_tile "hi" "(hdsj 4)")
      (action_tile "accept" "(hdsj 0)")
      (action_tile "cancel" "(done_dialog 0)(setq what -2 no 4)")
      (action_tile "help" "(help \"Tssd\" \"Dzhbzh\")")
      (start_dialog)
    )
    (unload_dialog dia)
    no
  )
  (if 
    (and (>= (&UTXT) 0) 
         (setq lay (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线")
               ss  (&DSTR 
                     "\n选择要标注的柱子<退出>: "
                     (list (cons 0 "LWPOLYLINE") (cons 8 lay) '(39 . 0))
                   )
         )
         (setq _fn "Tssd/Dcl_Myj/Dzhbzh"
               _ld (list "no" 
                         1
                         "cx"
                         "0"
                         "str"
                         "KZ1"
                         "zg"
                         (/ (* 1.5 (&INTS "标号文字")) &sp)
                   )
         )
         (#dcldata _fn _ld T)
         (/= (setq no (dcl)) 4)
    )
    (progn (#dcldata _fn _ld nil) 
           (setq lay (&LJIG "平面柱子编号" T)
                 zg  (* zg &sp)
           )
           (if (= cx "0") (&INTS "标号文字") (&INTS "粗体文字"))
           (setvar "textsize" zg)
           (regapp "TssdCad6XData")
           (setq si -1)
           (while 
             (setq si (1+ si)
                   en (ssname ss si)
             )
             (setq el  (entget en)
                   pt  (p_l el)
                   pt1 (polar pt (* 0.25 pi) (* 2 zg))
                   s   (ssadd)
                   dis (textbox (list (cons 1 str)))
                   dis (* 1.25 (- (caadr dis) (caar dis)))
             )
             (cond 
               ((= no 1)
                (command ".line" pt pt1 "")
                (ssadd (entlast) s)
                (command ".line" pt1 (polar pt1 0 dis) "")
                (entmod 
                  (append (entget (entlast)) 
                          (list (list -3 (list "TssdCad6XData" '(1000 . "Type6"))) )
                  )
                )
                (ssadd (entlast) s)
                (setq pt1 (polar pt1 (* 0.25 pi) (* 0.5 zg)))
               )
               ((= no 2)
                (command ".line" pt pt1 "")
                (entmod 
                  (append (entget (entlast)) 
                          (list (list -3 (list "TssdCad6XData" '(1000 . "Type1"))) )
                  )
                )
                (ssadd (entlast) s)
                (setq pt1 (polar pt1 (* 0.25 pi) (* 0.5 zg)))
               )
               ((= no 3) (setq pt1 (polar pt (* 0.25 pi) (* 0.5 zg))))
             )
             (command ".text" pt1 zg 0 str)
             (ssadd (entlast) s)
             (&DGAR s)
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Shchzhz" "Tssd" "Shchzhz")
(defun c:Shchzhz (/ ss lay en pl p1 p2 dis s) 
  (if (< (&UTXT) 0) (exit))
  (setq lay (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线"))
  (setq ss (&DSTR "\n选择要删除的柱子<退出>: " (list (cons 0 "LWPOLYLINE") (cons 8 lay))))
  (if ss 
    (while (setq en (ssname ss 0)) 
      (ssdel en ss)
      (setq pl (&DRAG en 10))
      (if (= (length pl) 2) 
        (setq p1  (car pl)
              p2  (cadr pl)
              an  (angle p1 p2)
              dis (* 0.5 (distance p1 p2))
              pl  (list p1 
                        (polar p1 (+ an _pi2) dis)
                        (polar p2 (+ an _pi2) dis)
                        p2
                        (polar p2 (- an _pi2) dis)
                        (polar p1 (- an _pi2) dis)
                  )
        )
      )
      (@findw 
        pl
        (&LJIG 
          "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线,平面连梁,平面连梁实线,平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
        )
      )
      (entdel en)
      (if 
        (setq s (ssget "cp" 
                       pl
                       (list (cons 0 "HATCH,DIMENSION") 
                             (cons 8 (&LJIG "平面柱子填充,平面柱子尺寸"))
                       )
                )
        )
        (ss::del s)
      )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Ydzh" "Tssd" "Ydzh")
(defun c:Ydzh (/ jxchl ss lay en pl p1 p2 dis pt pt1 pt2 disl p10 p11 ptl ang zp) 
  (defun jxchl (en / an dis pl lp si smx ss p1 p2 tfz coltrim zp) 
    (defun coltrim (lp / pout a a1 a2 e e48 e6 el la ll lp1 lx p3 r r0 si smx ss st p 
                    ptl
                   ) 
      (defun poutl (p llp / tf r lp) 
        (while (and (null tf) (setq lp (car llp))) 
          (setq llp (cdr llp)
                tf  (if (atom (setq r (cadr lp))) 
                      (< (distance p (car lp)) r)
                      (@pinl p lp -1.)
                    )
          )
        )
        (null tf)
      )
      (setq la (&LJIG 
                 "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线,平面连梁,平面连梁实线,平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
               )
      )
      (if (listp (cadar lp)) 
        (setq ptl (car lp))
        (setq p   (caar lp)
              ptl (list (polar p 0 (cadar lp)) 
                        (polar p _pi2 (cadar lp))
                        (polar p pi (cadar lp))
                        (polar p (* 1.5 pi) (cadar lp))
                  )
        )
      )
      (if (setq ss (ssget "cp" ptl (list (cons 8 la) '(0 . "line,arc")))) 
        (progn 
          (setq si  0
                smx (sslength ss)
          )
          (while (< si smx) 
            (setq e   (ssname ss si)
                  el  (entget e)
                  si  (1+ si)
                  la  (assoc 8 el)
                  e6  (assoc 6 el)
                  e48 (assoc 48 el)
            )
            (if (null e6) (setq e6 '(6 . "bylayer")))
            (if (null e48) (setq e48 '(48 . 1.0)))
            (if (= (&DRAG e 0) "LINE") 
              (progn 
                (setq p1  (&DRAG 10)
                      p2  (&DRAG 11)
                      lx  nil
                      lp1 nil
                )
                (foreach l lp 
                  (setq p3 (car l)
                        ll nil
                  )
                  (if (atom (setq r (cadr l))) 
                    (setq ll (&ORDR p1 p2 p3 r))
                    (foreach p4 (cdr l) 
                      (if (setq p3 (inters p1 p2 p3 p4)) (setq ll (cons p3 ll)))
                      (setq p3 p4)
                    )
                  )
                  (if ll (setq lp1 (cons l lp1)))
                  (foreach p ll (setq lx (cons (cons (distance p p1) p) lx)))
                )
                (if lx 
                  (progn 
                    (setq lx (mapcar 'cdr (@ran3 lx))
                          lx (append lx (list p2))
                    )
                    (entdel e)
                    (foreach p2 lx 
                      (if (and (> (distance p1 p2) 1.) (poutl (&N2S p1 p2) lp1)) 
                        (entmake 
                          (list '(0 . "line") 
                                la
                                e6
                                e48
                                (cons 10 (@wcs p1))
                                (cons 11 (@wcs p2))
                          )
                        )
                      )
                      (setq p1 p2)
                    )
                  )
                )
              )
              (progn 
                (setq p1  (&DRAG 10)
                      r0  (&DRAG 40)
                      a1  (&DRAG 50)
                      a2  (&DRAG 51)
                      lx  nil
                      lp1 nil
                )
                (foreach l lp 
                  (setq p3 (car l)
                        ll nil
                  )
                  (if (atom (setq r (cadr l))) 
                    (setq ll (&ORDR p1 r0 a1 a2 p3 r))
                    (foreach p4 (cdr l) 
                      (setq ll (append ll (&ORDR p1 r0 a1 a2 p3 p4))
                            p3 p4
                      )
                    )
                  )
                  (if ll (setq lp1 (cons l lp1)))
                  (foreach p ll 
                    (setq a (angle p1 p))
                    (if (< a (- a1 1e-4)) (setq a (+ a pi pi)))
                    (setq lx (cons (cons (- a a1) a) lx))
                  )
                )
                (if lx 
                  (progn 
                    (setq lx (mapcar 'cdr (@ran3 lx))
                          lx (append lx (list a2))
                    )
                    (entdel e)
                    (foreach a2 lx 
                      (if 
                        (and (> (- a2 a1) 1e-3) 
                             (poutl (polar p1 (* 0.5 (+ a1 a2)) r0) lp1)
                        )
                        (entmake 
                          (list '(0 . "arc") 
                                la
                                e6
                                e48
                                (cons 10 (@wcs p1))
                                (cons 40 r0)
                                (cons 50 (@wcs a1))
                                (cons 51 (@wcs a2))
                          )
                        )
                      )
                      (setq a1 a2)
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    (setq pl (&DRAG en 10))
    (if (or (equal (&DRAG en 42) (list 1 1)) (equal (&DRAG en 42) (list -1 -1))) 
      (setq p1  (car pl)
            p2  (cadr pl)
            an  (angle p1 p2)
            dis (* 0.5 (distance p1 p2))
            lp  (list p1 
                      (polar p1 (+ an _pi2) dis)
                      (polar p2 (+ an _pi2) dis)
                      p2
                      (polar p2 (- an _pi2) dis)
                      (polar p1 (- an _pi2) dis)
                )
            pl  (list (&N2S p1 p2) dis)
      )
      (progn (if (not (equal (car pl) (last pl))) (setq pl (cons (last pl) pl))) 
             (setq lp pl)
      )
    )
    (setq zp (@zoome 1 lp))
    (coltrim (list pl))
    (if zp (command ".zoom" "p"))
  )
  (if (< (&UTXT) 0) (exit))
  (setq lay (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线"))
  (if (setq ss (&DSTR "\n选择要移动的柱子<退出>: " (list (cons 0 "LWPOLYLINE") (cons 8 lay)))) 
    (progn (initget "C") 
           (if (setq pt1 (&OSNP "\n指定柱子移动的基点或 [选取柱平齐的梁线(C)]<退出>: ")) 
             (if (listp pt1) 
               (progn (prompt "\n点取柱子移动的终点<退出>: ") 
                      (&SWTO T)
                      (command ".move" ss "" pt1 pause)
                      (&SWTO)
                      (setq pt2 (getvar "lastpoint"))
                      (if (and pt2 (not (equal pt1 pt2 (* &sp 0.01)))) 
                        (progn (command ".move" ss "" pt2 pt1) 
                               (setq l  (sslength ss)
                                     i  0
                                     pt (getvar "ViewCtr")
                               )
                               (while (> l i) 
                                 (setq en (ssname ss i)
                                       i  (1+ i)
                                 )
                                 (setq pl (&DRAG en 10))
                                 (if 
                                   (or (equal (&DRAG en 42) (list 1 1)) 
                                       (equal (&DRAG en 42) (list -1 -1))
                                   )
                                   (setq p1  (car pl)
                                         p2  (cadr pl)
                                         an  (angle p1 p2)
                                         dis (* 0.5 (distance p1 p2))
                                         pl  (list p1 
                                                   (polar p1 (+ an _pi2) dis)
                                                   (polar p2 (+ an _pi2) dis)
                                                   p2
                                                   (polar p2 (- an _pi2) dis)
                                                   (polar p1 (- an _pi2) dis)
                                             )
                                   )
                                 )
                                 (setq zp (@zoome 1 pl))
                                 (setq flag (@findw 
                                              pl
                                              (&LJIG 
                                                "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线,平面连梁,平面连梁实线,平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
                                              )
                                            )
                                 )
                                 (command ".Move" 
                                          en
                                          ""
                                          pt
                                          (polar pt 
                                                 (angle pt1 pt2)
                                                 (distance pt1 pt2)
                                          )
                                 )
                                 (if zp (command ".Zoom" "p"))
                                 (if flag (jxchl en))
                               )
                        )
                        (progn (command ".Undo" "Back") (command ".Undo" ""))
                      )
               )
               (if (or (wcmatch pt1 "C") (wcmatch pt1 "c")) 
                 (if 
                   (setq ent (car (&DOVR "\n选取柱平齐的直线<退出>: " (list (cons 0 "LINE"))) ))
                   (progn 
                     (setq l   (sslength ss)
                           i   0
                           p10 (&DRAG ent 10)
                           p11 (&DRAG 11)
                           ang (angle p10 p11)
                     )
                     (while (> l i) 
                       (setq en (ssname ss i)
                             i  (1+ i)
                       )
                       (setq pl  (&DRAG en 10)
                             ptl pl
                       )
                       (if 
                         (or (equal (&DRAG en 42) (list 1 1)) 
                             (equal (&DRAG en 42) (list -1 -1))
                         )
                         (progn 
                           (setq p1  (car pl)
                                 p2  (cadr pl)
                                 an  (angle p1 p2)
                                 dis (* 0.5 (distance p1 p2))
                                 pl  (list p1 
                                           (polar p1 (+ an _pi2) dis)
                                           (polar p2 (+ an _pi2) dis)
                                           p2
                                           (polar p2 (- an _pi2) dis)
                                           (polar p1 (- an _pi2) dis)
                                     )
                                 pt  (&N2S (car (&DRAG 10)) (cadr (&DRAG 10)))
                                 dis (- (abs (&MIDP pt p10 p11)) 
                                        (* 0.5 
                                           (distance (car (&DRAG 10)) 
                                                     (cadr (&DRAG 10))
                                           )
                                        )
                                     )
                                 pt1 (inters p10 
                                             p11
                                             pt
                                             (polar pt (+ _pi2 ang) 100)
                                             nil
                                     )
                                 pt1 (polar pt (angle pt pt1) dis)
                           )
                           (setq zp (@zoome 1 pl))
                           (setq flag (@findw 
                                        pl
                                        (&LJIG 
                                          "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线,平面连梁,平面连梁实线,平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
                                        )
                                      )
                           )
                           (command ".Move" en "" pt pt1)
                           (if zp (command ".Zoom" "p"))
                           (if flag (jxchl en))
                         )
                         (progn (setq disl nil) 
                                (while (setq pt (car ptl)) 
                                  (setq dis  (abs (&MIDP pt p10 p11))
                                        disl (cons (list dis pt) disl)
                                        ptl  (cdr ptl)
                                  )
                                )
                                (setq disl (@ran4 disl))
                                (if (equal (caar disl) (caadr disl) (* 0.01 &sp)) 
                                  (progn 
                                    (setq dis (caar disl)
                                          pt  (cadar disl)
                                          pt1 (inters p10 
                                                      p11
                                                      pt
                                                      (polar pt (+ _pi2 ang) 100)
                                                      nil
                                              )
                                    )
                                    (setq zp (@zoome 1 pl))
                                    (setq flag (@findw 
                                                 pl
                                                 (&LJIG 
                                                   "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线,平面连梁,平面连梁实线,平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
                                                 )
                                               )
                                    )
                                    (command ".Move" en "" pt pt1)
                                    (if zp (command ".Zoom" "p"))
                                    (if flag (jxchl en))
                                  )
                                )
                         )
                       )
                     )
                   )
                 )
               )
             )
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Zhxxbj" "Tssd" "zhxxbj")
(defun c:Zhxxbj (/ p1 p2 ss en enl pt lay) 
  (if (< (&UTXT) 0) (exit))
  (if 
    (setq ss (&DSTR 
               "\n选择要标注形心的柱子<退出>: "
               (list (cons 8 (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线")) 
                     '(0 . "LWPOLYLINE")
               )
             )
    )
    (progn (command ".Layer" "Make" "Defpoints" "") 
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq pt (&MGRP en))
             (command ".point" pt)
           )
           (princ "\n本程序已经在柱子的形心处做了点标记 !")
    )
  )
  (&TSTY)
)
(setfunhelp "c:Chtbzh" "Tssd" "Chtbzh")
(Defun c:Chtbzh (/ draw chs_dcl txt what wid lon hp zp zhj lab rote dim no) 
  (defun draw (fl / layzh layz lay sc ljj hjj byjl dis zhch zhk cirzh cirz p1 p2 ss 
               en en1 enl en1l fla flag len ang an1 an2 pl en ptl dim_pt ptla diml 
               labe drawz drawzh cht drawcht1 drawcht2 drawcht3 drawcht4 drawcht5 
               drawcht6 drawcht7 drawcht8 drawcht9 drawcht10 drawcht11 drawcht12 
               drawcht13 drawlx @plin
              ) 
    (defun @plin (lp lay / cly p) 
      (setq cly (getvar "clayer"))
      (setvar "clayer" lay)
      (command ".pline")
      (foreach p lp (command p))
      (command "c")
      (setvar "clayer" cly)
    )
    (defun diml (pt1 pt2 ang / px py) 
      (command ".dimaligned" pt1 pt2 (polar (&N2S pt1 pt2) ang (* 8 &sp)))
    )
    (defun labe (p / delb dele lab dis pt pt1 zg gk lay) 
      (defun delb (str / ch i len) 
        (setq len (strlen str)
              i   1
        )
        (while (<= i len) 
          (setq ch (@substr str i 1)
                i  (if Tsz_If_Unicode (+ 2 i) (1+ i))
          )
          (if (/= ch " ") 
            (setq str (@substr str (1- i) len)
                  i   (1+ len)
            )
          )
        )
        str
      )
      (defun dele (str / ch len) 
        (setq len (strlen str))
        (while (> len 0) 
          (setq ch  (@substr str len 1)
                len (if Tsz_If_Unicode (- len 2) (1- len))
          )
          (if (= ch " ") (setq str (@substr str 1 len)) (setq len 0))
        )
        str
      )
      (setq lab (nth 7 txt)
            lab (delb lab)
            lab (dele lab)
      )
      (if (/= lab "") 
        (progn 
          (setq pt  (polar (setq p (polar p (+ ang pi) byjl)) 
                           (- ang _pi2)
                           (/ byjl 3)
                    )
                zg  (&INTS "标号文字" 1)
                gk  (cadr zg)
                zg  (car zg)
                pt1 (polar p (+ ang _pi2) (* 1.2 zg))
          )
          (setq lay (&LJIG "平面桩编号" T))
          (@text lab (polar pt1 (* 0.25 pi) (* 0.5 zg)) lay zg 0 "" gk)
          (setq dis (textbox (entget (entlast)))
                dis (+ (* 0.6 zg) (- (caadr dis) (caar dis)))
          )
          (@linel (list pt pt1 (polar pt1 0 dis)) lay)
        )
      )
    )
    (defun drawz (pt / emkz emkzc p0 p1 p2 p3) 
      (defun emkz () 
        (entmake 
          (list (cons 0 "Lwpolyline") 
                (cons 100 "AcDbEntity")
                (cons 67 0)
                (cons 8 layz)
                (cons 100 "AcDbPolyline")
                (cons 90 4)
                (cons 70 1)
                (cons 43 0)
                (cons 10 (@wcs p0))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
                (cons 10 (@wcs p1))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
                (cons 10 (@wcs p2))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
                (cons 10 (@wcs p3))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
          )
        )
      )
      (defun emkzc (p0 p1) 
        (entmake 
          (list (cons 0 "Lwpolyline") 
                (cons 100 "AcDbEntity")
                (cons 67 0)
                (cons 8 layz)
                (cons 100 "AcDbPolyline")
                (cons 90 2)
                (cons 70 1)
                (cons 43 0)
                (cons 10 (@wcs p0))
                (cons 40 0)
                (cons 41 0)
                (cons 42 1)
                (cons 10 (@wcs p1))
                (cons 40 0)
                (cons 41 0)
                (cons 42 1)
          )
        )
      )
      (setq p0 (polar (polar pt ang zhch) (- ang _pi2) zhk)
            p1 (polar p0 (+ ang _pi2) (+ zhk zhk))
            p2 (polar p1 (+ ang pi) (+ zhch zhch))
            p3 (polar p0 (+ ang pi) (+ zhch zhch))
      )
      (if cirz (emkzc (polar pt 0 zhch) (polar pt pi zhch)) (emkz))
      (&LJIG "详图轴线" T)
      (if cirz 
        (command ".Line" 
                 (polar pt 0 (+ zhch (* 3 &sp)))
                 (polar pt pi (+ zhch (* 3 &sp)))
                 ""
                 ".Line"
                 (polar pt _pi2 (+ zhch (* 3 &sp)))
                 (polar pt (* 1.5 pi) (+ zhch (* 3 &sp)))
                 ""
        )
        (command ".Line" 
                 (polar pt ang (+ zhch (* 3 &sp)))
                 (polar pt (+ ang pi) (+ zhch (* 3 &sp)))
                 ""
                 ".Line"
                 (polar pt (+ ang _pi2) (+ zhk (* 3 &sp)))
                 (polar pt (+ ang pi _pi2) (+ zhk (* 3 &sp)))
                 ""
        )
      )
    )
    (defun drawzh (pt / emkzh emkzhc p0 p1 p2 p3 sss) 
      (defun emkzh () 
        (entmake 
          (list (cons 0 "Lwpolyline") 
                (cons 100 "AcDbEntity")
                (cons 67 0)
                (cons 8 layzh)
                (cons 100 "AcDbPolyline")
                (cons 90 4)
                (cons 70 1)
                (cons 43 0)
                (cons 48 (* 0.2 &sc))
                (cons 10 (@wcs p0))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
                (cons 10 (@wcs p1))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
                (cons 10 (@wcs p2))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
                (cons 10 (@wcs p3))
                (cons 40 0)
                (cons 41 0)
                (cons 42 0)
          )
        )
      )
      (defun emkzhc (p0 p1) 
        (entmake 
          (list (cons 0 "Lwpolyline") 
                (cons 100 "AcDbEntity")
                (cons 67 0)
                (cons 8 layzh)
                (cons 100 "AcDbPolyline")
                (cons 90 2)
                (cons 70 1)
                (cons 43 0)
                (cons 48 (* 0.2 &sc))
                (cons 10 (@wcs p0))
                (cons 40 0)
                (cons 41 0)
                (cons 42 1)
                (cons 10 (@wcs p1))
                (cons 40 0)
                (cons 41 0)
                (cons 42 1)
          )
        )
      )
      (setq p0 (polar (polar pt ang zh) (- ang _pi2) zh)
            p1 (polar p0 (+ ang _pi2) (+ zh zh))
            p2 (polar p1 (+ ang pi) (+ zh zh))
            p3 (polar p0 (+ ang pi) (+ zh zh))
      )
      (if cirzh (emkzhc (polar pt 0 zh) (polar pt pi zh)) (emkzh))
      (setq sss (ssadd)
            sss (ssadd (entlast) sss)
      )
      (&LJIG "详图轴线" T)
      (if cirzh 
        (progn 
          (command ".Line" 
                   (polar pt 0 (+ zh (* 2 &sp)))
                   (polar pt pi (+ zh (* 2 &sp)))
                   ""
          )
          (ssadd (entlast) sss)
          (command ".Line" 
                   (polar pt _pi2 (+ zh (* 2 &sp)))
                   (polar pt (* 1.5 pi) (+ zh (* 2 &sp)))
                   ""
          )
          (ssadd (entlast) sss)
        )
        (progn 
          (command ".Line" 
                   (polar pt ang (+ zh (* 2 &sp)))
                   (polar pt (+ ang pi) (+ zh (* 2 &sp)))
                   ""
          )
          (ssadd (entlast) sss)
          (command ".Line" 
                   (polar pt (+ ang _pi2) (+ zh (* 2 &sp)))
                   (polar pt (+ ang pi _pi2) (+ zh (* 2 &sp)))
                   ""
          )
          (ssadd (entlast) sss)
        )
      )
      (&DGAR sss)
    )
    (defun cht (/ cly) 
      (setq p0 (polar (polar pt ang disx) (- ang _pi2) disy)
            p1 (polar p0 (+ ang _pi2) (+ disy disy))
            p2 (polar p1 (+ ang pi) (+ disx disx))
            p3 (polar p0 (+ ang pi) (+ disx disx))
      )
      (@plin (list p0 p1 p2 p3) lay)
      (if (= (nth 10 txt) "1") (drawz pt))
      (if (= (nth 6 txt) "1") (labe p1))
    )
    (defun drawCht1 (pt disx disy / p0 p1 p2 p3 en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (&N2S p3 p0) (- ang _pi2))
               (diml p0 (&N2S p3 p0) (- ang _pi2))
               (diml p0 (&N2S p1 p0) ang)
               (diml p1 (&N2S p1 p0) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh pt)
    )
    (defun drawCht2 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang (* 0.5 ljj))) (- ang _pi2))
               (diml p (setq p (polar p ang (* 0.5 ljj))) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (&N2S p1 p0) ang)
               (diml p1 (&N2S p1 p0) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar pt ang (* 0.5 ljj)))
      (drawzh (polar pt (+ ang pi) (* 0.5 ljj)))
    )
    (defun drawCht3 (pt / p0 p1 p2 pt0 pt1 pt2 pt3 pt4 pt5 p en s) 
      (drawzh (setq p0 (polar (polar pt ang ljj) (- ang _pi2) (/ hjj 3))))
      (drawzh (setq p1 (polar pt (+ ang _pi2) (/ (+ hjj hjj) 3))))
      (drawzh (setq p2 (polar (polar pt (+ ang pi) ljj) (- ang _pi2) (/ hjj 3))))
      (setq pt0 (polar p0 (- ang _pi2) byjl)
            pt2 (polar p2 (- ang _pi2) byjl)
            pt1 (polar p1 (+ ang _pi2) byjl)
            a1  (angle p1 p0)
            a2  (angle p2 p1)
            pt0 (inters pt0 
                        pt2
                        (polar p0 ang byjl)
                        (polar (polar p0 ang byjl) (+ ang _pi2) 1000)
                        nil
                )
            pt2 (inters pt0 
                        pt2
                        (polar p2 (+ ang pi) byjl)
                        (polar (polar p2 (+ ang pi) byjl) (+ ang _pi2) 1000)
                        nil
                )
            pt3 (inters pt0 
                        (polar pt0 (+ ang _pi2) 1000)
                        (polar p0 (+ a1 _pi2) byjl)
                        (polar p1 (+ a1 _pi2) byjl)
                        nil
                )
            pt4 (inters pt2 
                        (polar pt2 (+ ang _pi2) 1000)
                        (polar p2 (+ a2 _pi2) byjl)
                        (polar p1 (+ a2 _pi2) byjl)
                        nil
                )
            pt1 (inters pt3 (polar pt3 a1 1000) pt1 (polar pt1 ang 1000) nil)
            pt5 (inters pt4 (polar pt4 a2 1000) pt1 (polar pt1 ang 1000) nil)
            p   (inters pt0 pt2 pt1 pt3 nil)
            a1  (angle p0 p)
            pt0 (inters pt0 
                        pt2
                        (polar p0 a1 byjl)
                        (polar (polar p0 a1 byjl) (+ a1 _pi2) 1000)
                        nil
                )
            pt3 (inters pt1 
                        pt3
                        (polar p0 a1 byjl)
                        (polar (polar p0 a1 byjl) (+ a1 _pi2) 1000)
                        nil
                )
            p   (inters pt0 pt2 pt4 pt5 nil)
            a1  (angle p2 p)
            pt2 (inters pt0 
                        pt2
                        (polar p2 a1 byjl)
                        (polar (polar p2 a1 byjl) (+ a1 _pi2) 1000)
                        nil
                )
            pt4 (inters pt4 
                        pt5
                        (polar p2 a1 byjl)
                        (polar (polar p2 a1 byjl) (+ a1 _pi2) 1000)
                        nil
                )
      )
      (@plin (list pt0 pt3 pt1 pt5 pt4 pt2) lay)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq p (inters pt4 (polar pt4 (+ ang _pi2) 1000) pt0 pt2 nil))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p pt2 (- ang _pi2))
               (setq p (inters p2 (polar p2 (+ ang _pi2) 1000) pt0 pt2 nil))
               (diml pt2 p (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p pt0 (- ang _pi2))
               (setq p (inters pt3 (polar pt3 (+ ang _pi2) 1000) pt0 pt2 nil))
               (diml pt0 p (- ang _pi2))
               (diml p pt3 ang)
               (setq p (inters pt 
                               (polar pt ang 1000)
                               pt3
                               (polar pt3 (+ ang _pi2) 1000)
                               nil
                       )
               )
               (diml pt3 p ang)
               (diml p (setq p (polar p (+ ang _pi2) (/ (+ hjj hjj) 3))) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (if (= (nth 10 txt) "1") (drawz pt))
      (if (= (nth 6 txt) "1") (labe pt1))
    )
    (defun drawCht4 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang (* 0.5 ljj))) (- ang _pi2))
               (diml p (setq p (polar p ang (* 0.5 ljj))) (- ang _pi2))
               (diml p (polar p ang byjl) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) (* 0.5 hjj))) ang)
               (diml p (setq p (polar p (+ ang _pi2) (* 0.5 hjj))) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang (* 0.5 ljj)) (- ang _pi2) (* 0.5 hjj)))
      (drawzh (polar (polar pt ang (* 0.5 ljj)) (+ ang _pi2) (* 0.5 hjj)))
      (drawzh (polar (polar pt (+ ang pi) (* 0.5 ljj)) (- ang _pi2) (* 0.5 hjj)))
      (drawzh (polar (polar pt (+ ang pi) (* 0.5 ljj)) (+ ang _pi2) (* 0.5 hjj)))
    )
    (defun drawCht5 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (polar p ang byjl) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang ljj) (- ang _pi2) hjj))
      (drawzh (polar (polar pt ang ljj) (+ ang _pi2) hjj))
      (drawzh pt)
      (drawzh (polar (polar pt (+ ang pi) ljj) (- ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) ljj) (+ ang _pi2) hjj))
    )
    (defun drawCht6 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) (* 0.5 hjj))) ang)
               (diml p (setq p (polar p (+ ang _pi2) (* 0.5 hjj))) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang ljj) (- ang _pi2) (* 0.5 hjj)))
      (drawzh (polar (polar pt ang ljj) (+ ang _pi2) (* 0.5 hjj)))
      (drawzh (polar pt (- ang _pi2) (* 0.5 hjj)))
      (drawzh (polar pt (+ ang _pi2) (* 0.5 hjj)))
      (drawzh (polar (polar pt (+ ang pi) ljj) (- ang _pi2) (* 0.5 hjj)))
      (drawzh (polar (polar pt (+ ang pi) ljj) (+ ang _pi2) (* 0.5 hjj)))
    )
    (defun drawCht7 (pt disx disy / p0 p1 p2 p3 p4 p5 p pp a1 a2 a3 a4 en s) 
      (drawzh (setq p0 (polar pt ang (+ ljj ljj))))
      (drawzh (setq p5 (polar (polar pt ang ljj) (- ang _pi2) hjj)))
      (drawzh (setq p1 (polar (polar pt ang ljj) (+ ang _pi2) hjj)))
      (drawzh pt)
      (drawzh (setq p4 (polar (polar pt (+ ang pi) ljj) (- ang _pi2) hjj)))
      (drawzh (setq p2 (polar (polar pt (+ ang pi) ljj) (+ ang _pi2) hjj)))
      (drawzh (setq p3 (polar pt (+ ang pi) (+ ljj ljj))))
      (setq p  (polar pt (- ang _pi2) (+ hjj byjl))
            a1 (angle p0 p5)
            p5 (inters p 
                       (polar p ang 1000)
                       (polar p5 (+ a1 _pi2) byjl)
                       (polar p0 (+ a1 _pi2) byjl)
                       nil
               )
            a2 (angle p4 p3)
            p4 (inters p 
                       (polar p ang 1000)
                       (polar p4 (+ a2 _pi2) byjl)
                       (polar p3 (+ a2 _pi2) byjl)
                       nil
               )
            p  (polar pt (+ ang _pi2) (+ hjj byjl))
            a3 (angle p1 p0)
            p1 (inters p 
                       (polar p ang 1000)
                       (polar p1 (+ a3 _pi2) byjl)
                       (polar p0 (+ a3 _pi2) byjl)
                       nil
               )
            a4 (angle p3 p2)
            p2 (inters p 
                       (polar p ang 1000)
                       (polar p2 (+ a4 _pi2) byjl)
                       (polar p3 (+ a4 _pi2) byjl)
                       nil
               )
            p0 (inters p5 (polar p5 a1 1000) p1 (polar p1 a3 1000) nil)
            p3 (inters p4 (polar p4 a2 1000) p2 (polar p2 a4 1000) nil)
      )
      (@plin (list p0 p1 p2 p3 p4 p5) lay)
      (if (= (nth 6 txt) "1") (labe p1))
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml 
                 (setq p (polar pt (- ang _pi2) (+ hjj byjl)))
                 (setq p1 (polar p ang ljj))
                 (- ang _pi2)
               )
               (diml p1 p5 (- ang _pi2))
               (diml p5 (setq p2 (polar p1 ang ljj)) (- ang _pi2))
               (diml 
                 p2
                 (setq pp (polar p0 (- ang _pi2) (+ hjj byjl)))
                 (- ang _pi2)
               )
               (diml p (setq p1 (polar p (+ ang pi) ljj)) (- ang _pi2))
               (diml p1 p4 (- ang _pi2))
               (diml p4 (setq p2 (polar p1 (+ ang pi) ljj)) (- ang _pi2))
               (diml p2 (polar p3 (- ang _pi2) (+ hjj byjl)) (- ang _pi2))
               (diml pp (setq p1 (polar pp (+ ang _pi2) byjl)) ang)
               (diml p1 p0 ang)
               (diml p0 (setq p1 (polar p0 (+ ang _pi2) hjj)) ang)
               (diml p1 (polar p1 (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (if (= (nth 10 txt) "1") (drawz pt))
    )
    (defun drawCht8 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang (+ ljj ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt ang ljj))
      (drawzh (polar (polar pt ang (+ ljj ljj)) (+ ang _pi2) hjj))
      (drawzh (polar pt (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) (+ ljj ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) ljj))
      (drawzh (polar (polar pt (+ ang pi) (+ ljj ljj)) (+ ang _pi2) hjj))
    )
    (defun drawCht9 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang ljj) (- ang _pi2) hjj))
      (drawzh (polar pt ang ljj))
      (drawzh (polar (polar pt ang ljj) (+ ang _pi2) hjj))
      (drawzh (polar pt (- ang _pi2) hjj))
      (drawzh pt)
      (drawzh (polar pt (+ ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) ljj) (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) ljj))
      (drawzh (polar (polar pt (+ ang pi) ljj) (+ ang _pi2) hjj))
    )
    (defun drawCht10 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar pt ang (+ ljj ljj ljj)))
      (drawzh (polar (polar pt ang (+ ljj ljj)) (- ang _pi2) hjj))
      (drawzh (polar (polar pt ang (+ ljj ljj)) (+ ang _pi2) hjj))
      (drawzh (polar pt ang ljj))
      (drawzh (polar pt (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) ljj))
      (drawzh (polar (polar pt (+ ang pi) (+ ljj ljj)) (- ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) (+ ljj ljj)) (+ ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) (+ ljj ljj ljj)))
    )
    (defun drawCht11 (pt disx disy / p0 p1 p2 p3 p4 p5 p a1 a2 a3 a4 en s) 
      (drawzh (setq p0 (polar pt ang (+ ljj ljj ljj))))
      (drawzh (setq p5 (polar (polar pt ang (+ ljj ljj)) (- ang _pi2) hjj)))
      (drawzh (setq p1 (polar (polar pt ang (+ ljj ljj)) (+ ang _pi2) hjj)))
      (drawzh (polar pt ang ljj))
      (drawzh (polar pt (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) ljj))
      (drawzh (setq p4 (polar (polar pt (+ ang pi) (+ ljj ljj)) (- ang _pi2) hjj)))
      (drawzh (setq p2 (polar (polar pt (+ ang pi) (+ ljj ljj)) (+ ang _pi2) hjj)))
      (drawzh (setq p3 (polar pt (+ ang pi) (+ ljj ljj ljj))))
      (setq p  (polar pt (- ang _pi2) (+ hjj byjl))
            a1 (angle p0 p5)
            p5 (inters p 
                       (polar p ang 1000)
                       (polar p5 (+ a1 _pi2) byjl)
                       (polar p0 (+ a1 _pi2) byjl)
                       nil
               )
            a2 (angle p4 p3)
            p4 (inters p 
                       (polar p ang 1000)
                       (polar p4 (+ a2 _pi2) byjl)
                       (polar p3 (+ a2 _pi2) byjl)
                       nil
               )
            p  (polar pt (+ ang _pi2) (+ hjj byjl))
            a3 (angle p1 p0)
            p1 (inters p 
                       (polar p ang 1000)
                       (polar p1 (+ a3 _pi2) byjl)
                       (polar p0 (+ a3 _pi2) byjl)
                       nil
               )
            a4 (angle p3 p2)
            p2 (inters p 
                       (polar p ang 1000)
                       (polar p2 (+ a4 _pi2) byjl)
                       (polar p3 (+ a4 _pi2) byjl)
                       nil
               )
            p0 (inters p5 (polar p5 a1 1000) p1 (polar p1 a3 1000) nil)
            p3 (inters p4 (polar p4 a2 1000) p2 (polar p2 a4 1000) nil)
      )
      (@plin (list p0 p1 p2 p3 p4 p5) lay)
      (if (= (nth 6 txt) "1") (labe p1))
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml 
                 (setq p (polar pt (- ang _pi2) (+ hjj byjl)))
                 (setq p1 (polar p ang ljj))
                 (- ang _pi2)
               )
               (diml p1 (setq p1 (polar p1 ang ljj)) (- ang _pi2))
               (diml p1 p5 (- ang _pi2))
               (diml p5 (setq p2 (polar p1 ang ljj)) (- ang _pi2))
               (diml 
                 p2
                 (setq pp (polar p0 (- ang _pi2) (+ hjj byjl)))
                 (- ang _pi2)
               )
               (diml p (setq p1 (polar p (+ ang pi) ljj)) (- ang _pi2))
               (diml p1 (setq p1 (polar p1 (+ ang pi) ljj)) (- ang _pi2))
               (diml p1 p4 (- ang _pi2))
               (diml p4 (setq p2 (polar p1 (+ ang pi) ljj)) (- ang _pi2))
               (diml p2 (polar p3 (- ang _pi2) (+ hjj byjl)) (- ang _pi2))
               (diml pp (setq p1 (polar pp (+ ang _pi2) byjl)) ang)
               (diml p1 p0 ang)
               (diml p0 (setq p1 (polar p0 (+ ang _pi2) hjj)) ang)
               (diml p1 (polar p1 (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (if (= (nth 10 txt) "1") (drawz pt))
    )
    (defun drawCht12 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang (+ ljj ljj ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt ang (+ ljj ljj)))
      (drawzh (polar (polar pt ang (+ ljj ljj ljj)) (+ ang _pi2) hjj))
      (drawzh (polar (polar pt ang ljj) (- ang _pi2) hjj))
      (drawzh pt)
      (drawzh (polar (polar pt ang ljj) (+ ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) ljj) (- ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) ljj) (+ ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) (+ ljj ljj ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) (+ ljj ljj)))
      (drawzh (polar (polar pt (+ ang pi) (+ ljj ljj ljj)) (+ ang _pi2) hjj))
    )
    (defun drawCht13 (pt disx disy / p0 p1 p2 p3 p en s) 
      (cht)
      (if (= (nth 4 txt) "1") 
        (progn (&LJIG "平面桩尺寸" T) 
               (&GVAL (atoi (nth 8 txt)))
               (setq en (entlast)
                     s  (ssadd)
               )
               (diml p3 (setq p (polar p3 ang byjl)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang ljj)) (- ang _pi2))
               (diml p (setq p (polar p ang byjl)) (- ang _pi2))
               (diml p0 (setq p (polar p0 (+ ang _pi2) byjl)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (setq p (polar p (+ ang _pi2) hjj)) ang)
               (diml p (polar p (+ ang _pi2) byjl) ang)
               (while (entnext en) (ssadd (setq en (entnext en)) s))
               (&CODE s)
        )
      )
      (drawzh (polar (polar pt ang (* 1.5 ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt ang (* 1.5 ljj)))
      (drawzh (polar (polar pt ang (* 1.5 ljj)) (+ ang _pi2) hjj))
      (drawzh (polar (polar pt ang (* 0.5 ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt ang (* 0.5 ljj)))
      (drawzh (polar (polar pt ang (* 0.5 ljj)) (+ ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) (* 0.5 ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) (* 0.5 ljj)))
      (drawzh (polar (polar pt (+ ang pi) (* 0.5 ljj)) (+ ang _pi2) hjj))
      (drawzh (polar (polar pt (+ ang pi) (* 1.5 ljj)) (- ang _pi2) hjj))
      (drawzh (polar pt (+ ang pi) (* 1.5 ljj)))
      (drawzh (polar (polar pt (+ ang pi) (* 1.5 ljj)) (+ ang _pi2) hjj))
    )
    (defun drawlx (pt / no) 
      (setq no (car txt))
      (cond 
        ((= no "0") (drawCht1 pt byjl byjl))
        ((= no "1") (drawCht2 pt (+ (* 0.5 ljj) byjl) byjl))
        ((= no "2") (drawCht3 pt))
        ((= no "3") (drawCht4 pt (+ (* 0.5 ljj) byjl) (+ (* 0.5 hjj) byjl)))
        ((= no "4") (drawCht5 pt (+ ljj byjl) (+ hjj byjl)))
        ((= no "5") (drawCht6 pt (+ ljj byjl) (+ (* 0.5 hjj) byjl)))
        ((= no "6") (drawCht7 pt (+ ljj ljj) (+ hjj byjl)))
        ((= no "7") (drawCht8 pt (+ ljj ljj byjl) (+ hjj byjl)))
        ((= no "8") (drawCht9 pt (+ ljj byjl) (+ hjj byjl)))
        ((= no "9") (drawCht10 pt (+ ljj ljj ljj byjl) (+ hjj byjl)))
        ((= no "10") (drawCht11 pt (+ ljj ljj ljj byjl) (+ hjj byjl)))
        ((= no "11") (drawCht12 pt (+ ljj ljj ljj byjl) (+ hjj byjl)))
        ((= no "12") (drawCht13 pt (+ (* 1.5 ljj) byjl) (+ hjj byjl)))
      )
    )
    (defun draw_pt (pt ang /) 
      (if dim_pt 
        (if (< (+ (car pt) (cadr pt)) (+ (car dim_pt) (cadr dim_pt))) 
          (setq dim_pt pt
                ptl    (cons (list pt ang) ptl)
          )
          (setq ptl (append ptl (list (list pt ang))))
        )
        (setq dim_pt pt
              ptl    (cons (list pt ang) ptl)
        )
      )
    )
    (if (/= fl -38) 
      (progn 
        (&GLAY 
          "Tssd40/Dcl_Hzh/Pmbzhx"
          (strcat (nth 0 txt) 
                  "\t"
                  (nth 1 txt)
                  "\t"
                  (nth 2 txt)
                  "\t"
                  (nth 3 txt)
                  "\t"
                  (nth 4 txt)
                  "\t"
                  (nth 5 txt)
                  "\t"
                  (nth 6 txt)
                  "\t"
                  (nth 7 txt)
                  "\t"
                  (nth 8 txt)
                  "\t"
                  (nth 9 txt)
                  "\t"
                  (nth 10 txt)
                  "\t"
                  (nth 11 txt)
                  "\t"
                  (nth 12 txt)
                  "\t"
                  (nth 13 txt)
                  "\t"
                  (nth 14 txt)
                  "\t"
                  (nth 15 txt)
                  "\t"
                  (nth 16 txt)
          )
        )
        (setq layzh (&LJIG "平面桩虚线" T)
              layz  (&LJIG "平面柱子" T)
              lay   (&LJIG "平面桩" T)
              zj    (/ (* pi (atof (nth 15 txt))) 180)
        )
        (setq sc   (/ &sp (atoi (nth 8 txt)) 1.0)
              ljj  (* (atof (nth 1 txt)) sc)
              hjj  (* (atof (nth 2 txt)) sc)
              byjl (* (atof (nth 3 txt)) sc)
              zh   (* 0.5 (atof (nth 9 txt)) sc)
              zhch (* 0.5 (atof (nth 11 txt)) sc)
              zhk  (* 0.5 (atof (nth 12 txt)) sc)
        )
        (if (= (nth 13 txt) "1") (setq cirzh T) (setq cirzh nil))
        (if (= (nth 14 txt) "1") (setq cirz T) (setq cirz nil))
      )
    )
    (cond 
      ((= fl -8)
       (setq pt  (getvar "viewctr")
             ang zj
       )
       (command ".point" (list 0 0))
       (setq en (entlast))
       (while pt 
         (setq ent (entlast)
               ss  nil
               ss  (ssadd)
         )
         (drawlx pt)
         (while (setq ent (entnext ent)) (ssadd ent ss))
         (setq pt (&END "\n点取插入桩基承台的中心点<退出>: " ss pt))
       )
       (entdel en)
      )
      ((= fl -18)
       (while 
         (and (setq p1 (&OSNP "\n点取桩基承台插入区域第一角点<退出>: ")) 
              (setq p2 (&OSNP p1 "\t另一角点<退出>: " t))
         )
         (setq ptl    nil
               ptla   nil
               dim_pt nil
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面轴线")) '(0 . "line,arc,circle"))
                    )
           )
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq len  (sslength ss)
                   enl  (entget en)
                   flag (strcase (cdr (assoc 0 enl)))
             )
             (while (> len 0) 
               (setq len  (1- len)
                     en1  (ssname ss len)
                     en1l (entget en1)
                     fla  (strcase (cdr (assoc 0 en1l)))
               )
               (cond 
                 ((and (wcmatch flag "LINE") (wcmatch fla "LINE"))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= (nth 5 txt) "1") 
                      (progn 
                        (setq an1 (angle (&DRAG en 10) (&DRAG en 11))
                              an2 (angle (&DRAG en1 10) (&DRAG en1 11))
                              pl  (cdr pl)
                        )
                        (if (equal an1 (+ pi pi)) (setq an1 0))
                        (if (equal an2 (+ pi pi)) (setq an2 0))
                        (if (> an1 pi) (setq an1 (- an1 pi)))
                        (if (> an2 pi) (setq an2 (- an2 pi)))
                        (if (< (abs (- an1 _pi2)) (abs (- an2 _pi2))) 
                          (setq ang an2)
                          (setq ang an1)
                        )
                      )
                      (setq ang 0
                            an  _pi2
                            pl  (cdr pl)
                      )
                    )
                    (setq ang (+ ang zj))
                    (if (= (nth 16 txt) "1") (draw_pt pt ang) (drawlx pt))
                  )
                 )
                 ((and (wcmatch flag "LINE") (not (wcmatch fla "LINE")))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= (nth 5 txt) "1") 
                      (setq ang (angle (&DRAG en 10) (&DRAG en 11))
                            pl  (cdr pl)
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (setq ang (+ ang zj))
                    (if (= (nth 16 txt) "1") (draw_pt pt ang) (drawlx pt))
                  )
                 )
                 ((and (not (wcmatch flag "LINE")) (wcmatch fla "LINE"))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= (nth 5 txt) "1") 
                      (setq ang (angle (&DRAG en1 10) (&DRAG en1 11))
                            pl  (cdr pl)
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (setq ang (+ ang zj))
                    (if (= (nth 16 txt) "1") (draw_pt pt ang) (drawlx pt))
                  )
                 )
                 ((and (not (wcmatch flag "LINE")) (not (wcmatch fla "LINE")))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (setq ang zj
                          pl  (cdr pl)
                    )
                    (if (= (nth 16 txt) "1") (draw_pt pt ang) (drawlx pt))
                  )
                 )
               )
             )
           )
         )
         (setq txt (@subst txt 4 "1"))
         (while (setq ptla (car ptl)) 
           (setq ptl (cdr ptl)
                 pt  (car ptla)
                 ang (cadr ptla)
           )
           (drawlx pt)
           (setq txt (@subst txt 4 "0"))
         )
       )
      )
      ((= fl -28)
       (while 
         (and (setq p1 (&OSNP "\n点取桩基承台插入区域第一角点<退出>: ")) 
              (setq p2 (&OSNP p1 "\n点取桩基承台插入区域第二角点<退出>: " t))
         )
         (setq ptl    nil
               ptla   nil
               dim_pt nil
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面柱子")) '(0 . "LWPOLYLINE"))
                    )
           )
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq enl (entget en)
                   pt  (&MGRP en)
                   pl  (&DRAG en 10)
             )
             (if (>= (length pl) 3) 
               (setq ang (angle (car pl) (cadr pl)))
               (setq ang 0)
             )
             (if (equal ang (+ pi pi) 0.005) (setq ang 0))
             (if (> ang pi) (setq ang (- ang pi)))
             (setq ang (+ ang zj))
             (if (= (nth 16 txt) "1") (draw_pt pt ang) (drawlx pt))
           )
         )
         (setq txt (@subst txt 4 "1"))
         (while (setq ptla (car ptl)) 
           (setq ptl (cdr ptl)
                 pt  (car ptla)
                 ang (cadr ptla)
           )
           (drawlx pt)
           (setq txt (@subst txt 4 "0"))
         )
       )
      )
    )
  )
  (defun chs_dcl (tx / slide what dia selsld) 
    (defun selsld (no / vslide getimg what dias n i) 
      (defun vslide (name img / x y) 
        (setq x (dimx_tile img)
              y (dimy_tile img)
        )
        (start_image img)
        (fill_image 0 0 x y -2)
        (slide_image 0 0 x (- y 10) (strcat "Tssd (" name ")"))
        (end_image)
      )
      (defun getimg (n /) 
        (mode_tile (strcat "img" n) 4)
        (mode_tile (strcat "img" (itoa no)) 4)
        (setq no (atoi n))
        (if (= $reason 4) (progn (done_dialog -2) (setq what -2)))
      )
      (setq what 2
            dias (lib::dcl "Column")
            i    1
      )
      (while (> what 0) 
        (if (not (new_dialog "Selzhlx" dias)) (exit))
        (while (< i 14) 
          (vslide (strcat (itoa i) "zhcht") (strcat "img" (itoa i)))
          (setq i (1+ i))
        )
        (action_tile "img1" "(getimg \"1\")")
        (action_tile "img2" "(getimg \"2\")")
        (action_tile "img3" "(getimg \"3\")")
        (action_tile "img4" "(getimg \"4\")")
        (action_tile "img5" "(getimg \"5\")")
        (action_tile "img6" "(getimg \"6\")")
        (action_tile "img7" "(getimg \"7\")")
        (action_tile "img8" "(getimg \"8\")")
        (action_tile "img9" "(getimg \"9\")")
        (action_tile "img10" "(getimg \"10\")")
        (action_tile "img11" "(getimg \"11\")")
        (action_tile "img12" "(getimg \"12\")")
        (action_tile "img13" "(getimg \"13\")")
        (mode_tile (strcat "img" (itoa no)) 4)
        (action_tile "accept" "(getimg (itoa no))(done_dialog -2)(setq what -1)")
        (start_dialog)
      )
      (unload_dialog dias)
      no
    )
    (defun changeimg (/ vslide name name_l) 
      (defun vslide (l / x y name) 
        (setq x (dimx_tile "img")
              y (dimy_tile "img")
        )
        (start_image "img")
        (fill_image 0 0 x y -2)
        (while (setq name (car l)) 
          (slide_image 0 0 (+ x 8) (- y 20) (strcat "Tssd (" name ")"))
          (setq l (cdr l))
        )
        (end_image)
      )
      (set_tile "err2" "")
      (setq no (get_tile "lx"))
      (if (= no "0") 
        (progn (mode_tile "ljj" 1) (mode_tile "hjj" 1))
        (if (= no "1") 
          (progn (mode_tile "ljj" 0) (mode_tile "hjj" 1))
          (progn (mode_tile "ljj" 0) (mode_tile "hjj" 0))
        )
      )
      (if (= (atoi no) 10) 
        (setq name "10zhd")
        (if (< (atoi no) 10) 
          (setq no   (itoa (1+ (atoi no)))
                name (strcat no "zh")
          )
          (setq name (strcat no "zh"))
        )
      )
      (setq name_l (cons name name_l))
      (if (= (nth 13 txt) "1") 
        (progn (mapcar 'set_tile (list "yz" "fz" "txt") (list "1" "0" "桩直径:")) 
               (setq name_l (cons (strcat name "zhy") name_l))
        )
        (progn (mapcar 'set_tile (list "yz" "fz" "txt") (list "0" "1" "方桩长:")) 
               (setq name_l (cons (strcat name "zhf") name_l))
        )
      )
      (if (= (get_tile "zhu") "1") 
        (progn 
          (mapcar 'mode_tile 
                  (list "yzh" "fzh" "txt1" "zhch" "txt2" "zhk")
                  (list 0 0 0 0 0 0)
          )
          (if (= (nth 14 txt) "1") 
            (progn 
              (mapcar 'set_tile 
                      (list "yzh" "fzh" "txt1" "txt2")
                      (list "1" "0" "直径:" "")
              )
              (mode_tile "zhk" 1)
              (setq name_l (cons (strcat name "zhuy") name_l))
            )
            (progn 
              (mapcar 'set_tile 
                      (list "yzh" "fzh" "txt1" "txt2")
                      (list "0" "1" "柱长:" "柱宽:")
              )
              (mode_tile "zhk" 0)
              (setq name_l (cons (strcat name "zhuf") name_l))
            )
          )
        )
        (mapcar 'mode_tile 
                (list "yzh" "fzh" "txt1" "zhch" "txt2" "zhk")
                (list 1 1 1 1 1 1)
        )
      )
      (setq name_l (cons (strcat name "dim") name_l))
      (vslide name_l)
    )
    (defun changtxt (/ tx) 
      (if (= (get_tile "bhed") "") 
        (progn (set_tile "bh" "0") (set_tile "bhed" "CHT1"))
      )
      (if (= (atof (get_tile "zj")) 0) (set_tile "zj" "0"))
      (if (= (get_tile "bh") "1") (mode_tile "bhed" 0) (mode_tile "bhed" 1))
      (setq txt (@subst txt 0 (get_tile "lx"))
            txt (@subst txt 1 (get_tile "ljj"))
            txt (@subst txt 2 (get_tile "hjj"))
            txt (@subst txt 3 (get_tile "byjl"))
            txt (@subst txt 4 (get_tile "dim"))
            txt (@subst txt 5 (get_tile "rot"))
            txt (@subst txt 6 (get_tile "bh"))
            txt (@subst txt 7 (get_tile "bhed"))
            txt (@subst txt 8 (get_tile "bl"))
            txt (@subst txt 9 (get_tile "zh"))
            txt (@subst txt 10 (get_tile "zhu"))
            txt (@subst txt 11 (get_tile "zhch"))
            txt (@subst txt 12 (get_tile "zhk"))
            txt (@subst txt 15 (get_tile "zj"))
            txt (@subst txt 16 (get_tile "first"))
      )
      (if (= fl 5) 
        (setq txt (@subst txt 13 (get_tile "yz"))
              txt (@subst txt 14 (get_tile "yzh"))
        )
      )
    )
    (defun cal (fl / ljj hjj zh lbl hbl str bujl bl zhch zhk zj) 
      (set_tile "err2" "")
      (if (= fl 1) 
        (progn (if (and (= $key "first") (= $value "1")) (set_tile "dim" "0")) 
               (if (and (= $key "dim") (= $value "1")) (set_tile "first" "0"))
        )
      )
      (setq str ""
            no  (atoi (get_tile "lx"))
      )
      (if (= fl 6) 
        (progn 
          (setq fl 1
                no (1- (selsld (1+ no)))
          )
          (set_tile "lx" (itoa no))
        )
      )
      (if (>= fl 1) 
        (progn 
          (setq ljj  (atof (get_tile "ljj"))
                hjj  (atof (get_tile "hjj"))
                zh   (atof (get_tile "zh"))
                byjl (atof (get_tile "byjl"))
                bl   (atof (get_tile "bl"))
                zhch (atof (get_tile "zhch"))
                zhk  (atof (get_tile "zhk"))
          )
          (if (<= ljj 0) 
            (progn (set_tile "ljj" (nth 1 txt)) (setq str "  桩的列间距应大于零! 已改为原值"))
          )
          (if (<= hjj 0) 
            (progn (set_tile "hjj" (nth 2 txt)) (setq str "  桩的行间距应大于零! 已改为原值"))
          )
          (if (<= byjl 0) 
            (progn (set_tile "byjl" (nth 3 txt)) (setq str "  桩的边缘距离应大于零! 已改为原值"))
          )
          (if (<= bl 0) 
            (progn (set_tile "bl" (nth 8 txt)) (setq str "  比例应大于零! 已改为原值"))
          )
          (if (<= zh 0) 
            (progn (set_tile "zh" (nth 9 txt)) (setq str "  桩的直径应大于零! 已改为原值"))
          )
          (if (<= zhch 0) 
            (progn (set_tile "zhch" (nth 11 txt)) (setq str "  柱长应大于零! 已改为原值"))
          )
          (if (<= zhk 0) 
            (progn (set_tile "zhk" (nth 12 txt)) (setq str "  柱宽应大于零! 已改为原值"))
          )
          (if (< byjl zh) 
            (progn (setq str (strcat str "  边缘距离应大于桩径!")) 
                   (if (= fl 4) 
                     (set_tile "zh" (nth 9 txt))
                     (set_tile "byjl" (nth 3 txt))
                   )
            )
          )
        )
      )
      (setq ljj (atof (get_tile "ljj"))
            hjj (atof (get_tile "hjj"))
            zh  (atof (get_tile "zh"))
      )
      (if (or (= no 2) (= no 4)) 
        (setq lbl (/ (+ ljj ljj) zh)
              hbl (/ (sqrt (+ (* ljj ljj) (* hjj hjj))) zh)
        )
        (if (or (= no 6) (= no 7) (= no 9) (= no 10) (= no 11)) 
          (setq lbl (/ (+ ljj ljj) zh)
                hbl (/ (sqrt (+ (* ljj ljj) (* hjj hjj))) zh)
          )
          (if (> no 0) 
            (setq lbl (/ ljj zh)
                  hbl (/ hjj zh)
            )
            (setq lbl 8
                  hbl 8
            )
          )
        )
      )
      (if (= no 1) (setq hbl 8))
      (if (or (< lbl 3) (< hbl 3)) 
        (progn (setq str (strcat str "  桩间距应大于 3 倍桩直径! 已改为原值")) 
               (if (= fl 2) (set_tile "ljj" (nth 1 txt)))
               (if (= fl 3) (set_tile "hjj" (nth 2 txt)))
               (if (= fl 4) (set_tile "zh" (nth 9 txt)))
        )
      )
      (setq ljj (atof (get_tile "ljj"))
            hjj (atof (get_tile "hjj"))
            zh  (atof (get_tile "zh"))
      )
      (if (> no 1) 
        (set_tile "err1" (strcat "桩间距与桩直径比为" (rtos (min lbl hbl) 2 2)))
        (if (> no 0) 
          (set_tile "err1" (strcat "桩间距与桩直径比为" (rtos lbl 2 2)))
          (set_tile "err1" "")
        )
      )
      (set_tile "err2" str)
      (changtxt)
    )
    (mapcar 'set '(wid lon hp zp zhj lab rote dim no) txt)
    (setq what 2
          dia  (lib::dcl "Column")
          wid  (atoi wid)
          lon  (atoi lon)
          hp   (atoi hp)
          zp   (atoi zp)
          zhj  (atoi zhj)
    )
    (while (> what 0) 
      (if (not (new_dialog "Pmbzh" dia)) (exit))
      (mapcar 'set_tile 
              (list "lx" "ljj" "hjj" "byjl" "dim" "rot" "bh" "bhed" "bl" "zh" "zhu" 
                    "zhch" "zhk"
              )
              txt
      )
      (set_tile "zj" (nth 15 txt))
      (set_tile "first" (nth 16 txt))
      (cal 0)
      (changeimg)
      (action_tile "lx" "(cal 1)(changeimg)")
      (action_tile "type" "(cal 6)(changeimg)")
      (action_tile "yz" "(cal 5)(changeimg)")
      (action_tile "fz" "(cal 5)(changeimg)")
      (action_tile "zhu" "(cal 1)(changeimg)")
      (action_tile "yzh" "(cal 5)(changeimg)")
      (action_tile "fzh" "(cal 5)(changeimg)")
      (action_tile "dim" "(cal 1)")
      (action_tile "bh" "(cal 1)(changeimg)")
      (action_tile "ljj" "(cal 2)")
      (action_tile "hjj" "(cal 3)")
      (action_tile "zh" "(cal 4)")
      (action_tile "byjl" "(cal 1)")
      (action_tile "rot" "(cal 1)")
      (action_tile "bhed" "(cal 1)")
      (action_tile "zj" "(cal 1)")
      (action_tile "first" "(cal 1)")
      (action_tile "bl" "(cal 1)")
      (action_tile "zhch" "(cal 1)")
      (action_tile "zhk" "(cal 1)")
      (action_tile "sigl" "(setq what -8)(done_dialog 1)")
      (action_tile "mult" "(setq what -18)(done_dialog 2)")
      (action_tile "zhux" "(setq what -28)(done_dialog 2)")
      (action_tile "cancel" "(setq what -38)(done_dialog 3)")
      (action_tile "help" "(help \"Tssd\" \"Chtbzh\")")
      (start_dialog)
    )
    (unload_dialog dia)
    what
  )
  (if (< (&UTXT) 0) (exit))
  (setq txt (&GPTS "Tssd40/Dcl_Hzh/Pmbzhx"))
  (if (or (= txt nil) (wcmatch txt "")) 
    (setq txt (list "0" "1000" "1000" "500" "1" "0" "1" "CHT1" "100" "300" "0" "600" 
                    "600" "1" "0" "0" "1"
              )
    )
    (setq txt (&PLCN txt "\t"))
  )
  (draw (chs_dcl txt))
  (&TSTY)
)
(setfunhelp "c:Qxbzh" "Tssd" "Qxbzh")
(defun c:Qxbzh (/ drawzh dcl_set txt what) 
  (defun drawzh (str / emkzh emkzhc findwall_l findwall_a cen a1 a2 r pt1 pt2 lay 
                 layz wide dfs dis ang os pmid
                ) 
    (defun emkzh (p a l / p0 p1 p2 p3 s) 
      (setq p0 (polar (polar p a (* 0.5 l)) (+ a _pi2) (* 0.5 l))
            p1 (polar p0 (+ a pi) l)
            p2 (polar p1 (- a _pi2) l)
            p3 (polar p0 (- a _pi2) l)
      )
      (entmake 
        (list (cons 0 "Lwpolyline") 
              (cons 100 "AcDbEntity")
              (cons 67 0)
              (cons 8 lay)
              (cons 100 "AcDbPolyline")
              (cons 90 4)
              (cons 70 1)
              (cons 43 0)
              (cons 10 (@wcs p0))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p1))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p2))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p3))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
        )
      )
      (setq s nil
            s (ssadd)
            s (ssadd (entlast) s)
      )
      (setq p0 (polar p a l)
            p1 (polar p (+ a pi) l)
            p2 (polar p (+ a _pi2) l)
            p3 (polar p (- a _pi2) l)
      )
      (@line p0 p1 layz)
      (ssadd (entlast) s)
      (@line p2 p3 layz)
      (ssadd (entlast) s)
      (&DGAR s)
    )
    (defun emkzhc (p a l / p0 p1 p2 p3 s) 
      (setq p0 (polar p 0 (* 0.5 l))
            p1 (polar p pi (* 0.5 l))
      )
      (entmake 
        (list (cons 0 "Lwpolyline") 
              (cons 100 "AcDbEntity")
              (cons 67 0)
              (cons 8 lay)
              (cons 100 "AcDbPolyline")
              (cons 90 2)
              (cons 70 1)
              (cons 43 0)
              (cons 10 (@wcs p0))
              (cons 40 0)
              (cons 41 0)
              (cons 42 1)
              (cons 10 (@wcs p1))
              (cons 40 0)
              (cons 41 0)
              (cons 42 1)
        )
      )
      (setq s nil
            s (ssadd)
            s (ssadd (entlast) s)
      )
      (setq p0 (polar p a l)
            p1 (polar p (+ a pi) l)
            p2 (polar p (+ a _pi2) l)
            p3 (polar p (- a _pi2) l)
      )
      (@line p0 p1 layz)
      (ssadd (entlast) s)
      (@line p2 p3 layz)
      (ssadd (entlast) s)
      (&DGAR s)
    )
    (defun findwall_l (pt ang / find_nea_l find_nea_a p0 p1 p2 p3 ss epl1 epl2 pt an 
                       ptl findarc a1 a2 zm
                      ) 
      (defun find_nea_l (ss pt an / en p10 p11 pint ptl d) 
        (setq l  (sslength ss)
              di (+ wide wide)
        )
        (while (> l 0) 
          (setq l    (1- l)
                en   (ssname ss l)
                p10  (&DRAG en 10)
                p11  (&DRAG 11)
                pint (inters p10 p11 pt (polar pt an (+ wide wide)))
          )
          (if pint 
            (progn (setq d (distance pt pint)) 
                   (if (< d di) 
                     (setq ptl (list en pint)
                           di  d
                     )
                   )
            )
          )
        )
        ptl
      )
      (setq p0 (polar pt (* 0.25 pi) wide)
            p1 (polar pt (* 0.75 pi) wide)
            p2 (polar pt (* 1.25 pi) wide)
            p3 (polar pt (* 1.75 pi) wide)
      )
      (setq zm (@zoome &sp (list p0 p1 p2 p3)))
      (if 
        (setq ss (ssget "cp" 
                        (list p0 p1 p2 p3)
                        (list (cons 0 "LINE") 
                              (cons 8 (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"))
                        )
                 )
        )
        (progn 
          (setq epl1 (find_nea_l ss pt (+ ang _pi2))
                epl2 (find_nea_l ss pt (- ang _pi2))
          )
          (if (and epl1 epl2) 
            (progn 
              (setq a1 (angle (&DRAG (car epl1) 10) (&DRAG 11))
                    a2 (angle (&DRAG (car epl2) 10) (&DRAG 11))
              )
              (if (or (equal a1 pi 0.01) (equal a1 (+ pi pi) 0.01)) (setq a1 0.))
              (if (or (equal a2 pi 0.01) (equal a2 (+ pi pi) 0.01)) (setq a2 0.))
              (while (> a1 pi) (setq a1 (- a1 pi)))
              (while (> a2 pi) (setq a2 (- a2 pi)))
              (if (equal a1 a2 0.01) 
                (setq pt  (&N2S (cadr epl1) (cadr epl2))
                      an  (angle (&DRAG (car epl1) 10) (&DRAG 11))
                      ptl (list pt an)
                )
                (setq ptl (list pt ang))
              )
            )
            (setq ptl (list pt ang))
          )
        )
      )
      (if zm (command ".Zoom" "p"))
      ptl
    )
    (defun findwall_a (pt ang / find_nea_l find_nea_a p0 p1 p2 p3 ss epl1 epl2 pt an 
                       ptl zm
                      ) 
      (defun find_nea_a (ss pt an / en e pint pintl ptl d) 
        (setq l  (sslength ss)
              di (+ wide wide)
        )
        (command ".Line" pt (polar pt an (+ wide wide)) "")
        (setq e (entlast))
        (while (> l 0) 
          (setq l     (1- l)
                en    (ssname ss l)
                pintl (&ORDR en e)
          )
          (while (setq pint (car pintl)) 
            (setq d     (distance pt pint)
                  pintl (cdr pintl)
            )
            (if (< d di) 
              (setq ptl (list en pint)
                    di  d
              )
            )
          )
        )
        (entdel e)
        ptl
      )
      (setq p0 (polar pt (* 0.25 pi) wide)
            p1 (polar pt (* 0.75 pi) wide)
            p2 (polar pt (* 1.25 pi) wide)
            p3 (polar pt (* 1.75 pi) wide)
      )
      (setq zm (@zoome &sp (list p0 p1 p2 p3)))
      (if 
        (setq ss (ssget "cp" 
                        (list p0 p1 p2 p3)
                        (list (cons 0 "ARC") 
                              (cons 8 (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"))
                        )
                 )
        )
        (progn 
          (setq epl1 (find_nea_a ss pt ang)
                epl2 (find_nea_a ss pt (+ ang pi))
          )
          (if (and epl1 epl2) 
            (if (equal (&DRAG (car epl1) 10) (&DRAG (car epl2) 10) 1.0) 
              (setq pt  (&N2S (cadr epl1) (cadr epl2))
                    an  (angle (cadr epl1) (cadr epl2))
                    ptl (list pt an)
              )
              (setq ptl (list pt ang))
            )
            (setq ptl (list pt ang))
          )
        )
      )
      (if zm (command ".Zoom" "p"))
      ptl
    )
    (&GLAY 
      "Tssd/Dcl_Hzh/Qxbzh"
      (strcat (nth 0 str) 
              "\t"
              (nth 1 str)
              "\t"
              (nth 2 str)
              "\t"
              (nth 3 str)
              "\t"
              (nth 4 str)
      )
    )
    (if 
      (and (setq pt1 (&OSNP "\n在墙线中点取布桩位置的起点<退出>: ")) 
           (setq pt2 (&OSNP pt1 "\t终点<退出>: "))
      )
      (progn (initget "Yes No") 
             (setq flag (getkword "\n是否为弧线墙 [是(Y)/否(N)]<否>: "))
             (if (= flag "Yes") (setq pmid (&P2L pt1 pt2)))
             (setq lay  (&LJIG "平面桩" T)
                   layz (&LJIG "平面轴线" T)
                   wide (* 1000 &sc)
             )
             (if pmid 
               (progn (command ".Arc" pt1 pmid pt2) 
                      (setq cen (&DRAG (entlast) 10)
                            a1  (&DRAG 50)
                            a2  (&DRAG 51)
                            r   (&DRAG 40)
                      )
                      (entdel (entlast))
                      (if (< a2 a1) (setq a2 (+ a2 pi pi)))
                      (setq wide (* 1200 &sc)
                            dfs  (atof (last str))
                            dis  (/ (- a2 a1) dfs)
                            pt1  (polar cen a1 r)
                      )
                      (while (>= dfs 0) 
                        (setq ptl (findwall_a pt1 a1)
                              dfs (1- dfs)
                        )
                        (if ptl 
                          (if (= (car str) "1") 
                            (emkzh (car ptl) (cadr ptl) (* &sc (atof (nth 3 str))))
                            (emkzhc 
                              (car ptl)
                              (cadr ptl)
                              (* &sc (atof (nth 2 str)))
                            )
                          )
                        )
                        (setq a1  (+ a1 dis)
                              pt1 (polar cen a1 r)
                        )
                      )
               )
               (progn 
                 (setq dfs (atof (last str))
                       dis (/ (distance pt1 pt2) dfs)
                       ang (angle pt1 pt2)
                 )
                 (while (>= dfs 0) 
                   (setq ptl (findwall_l pt1 ang)
                         dfs (1- dfs)
                   )
                   (if ptl 
                     (if (= (car str) "1") 
                       (emkzh (car ptl) (cadr ptl) (* &sc (atof (nth 3 str))))
                       (emkzhc (car ptl) (cadr ptl) (* &sc (atof (nth 2 str))))
                     )
                   )
                   (setq pt1 (polar pt1 ang dis))
                 )
               )
             )
      )
    )
  )
  (defun dcl_set (txt / change dia) 
    (defun change (/ fzh yzh zhj zhc dfs) 
      (setq fzh (get_tile "fzh")
            yzh (get_tile "yzh")
            zhj (get_tile "zhj")
            zhc (get_tile "zhc")
            dfs (get_tile "dfs")
      )
      (if (= (get_tile "fzh") "1") 
        (progn (mode_tile "zhj" 1) (mode_tile "zhc" 0))
        (progn (mode_tile "zhj" 0) (mode_tile "zhc" 1))
      )
      (if (<= (atof zhj) 0) (set_tile "zhj" (nth 2 txt)))
      (if (<= (atof zhc) 0) (set_tile "zhc" (nth 3 txt)))
      (if (<= (atof dfs) 0) (set_tile "dfs" (nth 4 txt)))
      (setq fzh (get_tile "fzh")
            yzh (get_tile "yzh")
            zhj (get_tile "zhj")
            zhc (get_tile "zhc")
            dfs (get_tile "dfs")
      )
      (setq txt (list fzh yzh zhj zhc dfs))
    )
    (setq what 2
          dia  (lib::dcl "Column")
    )
    (while (> what 0) 
      (if (not (new_dialog "Qxbzh" dia)) (exit))
      (mapcar 'set_tile (list "fzh" "yzh" "zhj" "zhc" "dfs") txt)
      (change)
      (action_tile "fzh" "(change)")
      (action_tile "yzh" "(change)")
      (action_tile "zhj" "(change)")
      (action_tile "zhc" "(change)")
      (action_tile "dfs" "(change)")
      (action_tile "accept" "(change)(setq what -8)(done_dialog 1)")
      (action_tile "cancel" "(setq what -2)(done_dialog 1)")
      (action_tile "help" "(help \"Tssd\" \"Qxbzh\")")
      (start_dialog)
    )
    (unload_dialog dia)
    txt
  )
  (if (< (&UTXT) 0) (exit))
  (setq txt (&GPTS "Tssd/Dcl_Hzh/Qxbzh"))
  (if (or (= txt nil) (wcmatch txt "")) 
    (setq txt (list "1" "0" "300" "300" "10"))
    (setq txt (&PLCN txt "\t"))
  )
  (setq txt (dcl_set txt))
  (if (= -8 what) (drawzh txt))
  (&TSTY)
)
(setfunhelp "c:Shchzh" "Tssd" "Shchzh")
(defun c:Shchzh (/ ss en enl findf) 
  (defun findg (e / el e3) 
    (if (setq el (entget e)) 
      (progn (setq e3 (entget (cdr (assoc 330 el)))) 
             (while (setq e (cdr (assoc 340 e3))) 
               (entdel e)
               (setq e3 (subst (cons 341 "Tsz") (assoc 340 e3) e3))
             )
      )
    )
  )
  (if (< (&UTXT) 0) (exit))
  (if (setq ss (&DSTR "\n选择要删除的桩<退出>: " (list (cons 8 (&LJIG "平面桩,平面桩虚线"))))) 
    (progn (while (setq en (ssname ss 0)) (ssdel en ss) (setq enl (findg en))))
  )
  (&TSTY)
)
(setfunhelp "c:Fhgjzh" "Tssd" "Fhgjzh")
(Defun c:Fhgjzh (/ draw chs_dcl txt widno lonno gjzhj xzhbj yzhbj jjzhj zs1 zs2 px py) 
  (defun draw (fl / emk endchul zhgj yxgj lxgj qua lbxgj1 lbxgj2 bbxgj yxgjhf an an1 
               an2 ang d di en en1 en1l enl fla flag i l lay len lo lon p1 p2 pintl pt 
               px py r sc ss str txt w wi wid
              ) 
    (defun emk (lay / p p01 p02 p03 p04 p05) 
      (entmake 
        (list (cons 0 "Lwpolyline") 
              (cons 100 "AcDbEntity")
              (cons 67 0)
              (cons 8 lay)
              (cons 100 "AcDbPolyline")
              (cons 90 4)
              (cons 70 1)
              (cons 43 0)
              (cons 10 (@wcs p1))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p2))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p3))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p4))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
        )
      )
    )
    (defun endchul (p1 p2 p3 p4 pp no / diml axis peij biaoh) 
      (defun diml (/ pm1 pm2 p pv ph) 
        (setq p  (polar (polar pt pi (* sc px)) (* 1.5 pi) (* sc py))
              pv (polar p _pi2 1000)
              ph (polar p 0 1000)
        )
        (setq pm1 (inters p3 p4 p pv nil)
              pm2 (inters p1 p4 p ph nil)
        )
        (&GVAL (fix (atoi (nth 6 txt))))
        (&LJIG "详图柱子尺寸" T)
        (if (> (distance p4 pm2) (* 0.01 &sp)) 
          (@dima p4 pm2 (polar (&N2S p4 pm2) 0 (* 10 &sp)) nil)
        )
        (if (> (distance p1 pm2) (* 0.01 &sp)) 
          (@dima pm2 p1 (polar (&N2S pm2 p1) 0 (* 10 &sp)) nil)
        )
        (if (> (distance p3 pm1) (* 0.01 &sp)) 
          (@dima p3 pm1 (polar (&N2S p3 pm1) (* 1.5 pi) (* 10 &sp)) nil)
        )
        (if (> (distance p4 pm1) (* 0.01 &sp)) 
          (@dima pm1 p4 (polar (&N2S pm1 p4) (* 1.5 pi) (* 10 &sp)) nil)
        )
      )
      (defun axis (/ pm1 pm2 pm3 pm4 labx laby p pv ph lay) 
        (setq p  (polar (polar pt pi (* sc px)) (* 1.5 pi) (* sc py))
              pv (polar p _pi2 1000)
              ph (polar p 0 1000)
        )
        (setq lay (&LJIG "详图轴线" T))
        (setq pm1  (inters p1 p2 p pv nil)
              pm2  (inters p2 p3 p ph nil)
              pm3  (inters p3 p4 p pv nil)
              pm4  (inters p4 p1 p ph nil)
              labx (nth 23 txt)
              laby (nth 24 txt)
        )
        (if (= labx "nolabel") (setq labx " "))
        (if (= laby "nolabel") (setq laby " "))
        (@line (polar pm1 _pi2 (* 8 &sp)) (polar pm3 (* 1.5 pi) (* 16 &sp)) lay)
        (@line (polar pm2 pi (* 8 &sp)) (polar pm4 0 (* 16 &sp)) lay)
        (&LJIG "详图轴线编号" T)
        (&INTS "轴号文字")
        (&FIND 1 (polar pm4 0 (* 16 &sp)) 0 0 "详图轴线编号" laby)
        (&FIND 1 (polar pm3 (* 1.5 pi) (* 16 &sp)) (* 1.5 pi) 0 "详图轴线编号" labx)
      )
      (defun peij (/ zg wf pm1 pm2 str1 str2 st sss lay) 
        (setq zg  (&INTS "钢筋文字" 1)
              wf  (cadr zg)
              zg  (car zg)
              pm1 (polar p1 pi (* 2 &sp))
              sss (ssadd)
        )
        (if pp 
          (setq pm1 pp
                pm2 (polar pm1 _pi2 (* 6.8 zg))
          )
          (setq pm2 (polar pm1 _pi2 (* 5.8 zg)))
        )
        (setq lay (&LJIG "详图柱子集中标" T))
        (@line pm1 pm2 lay)
        (ssadd (entlast) sss)
        (setq pm1  (polar (polar pm2 0 (/ zg 3.)) (* 1.5 pi) (* 1 zg))
              str1 (&FLD 
                     (nth (atoi (nth 7 txt)) 
                          '("GJFH1" "GJFH2" "GJFH3" "GJFH4" "GJFH5" "GJFH6" "GJFH7" 
                            "GJFH8" "GJFH9" "GJFHA"
                           )
                     )
                   )
              str2 (&FLD 
                     (nth (atoi (nth 13 txt)) 
                          '("GJFH1" "GJFH2" "GJFH3" "GJFH5" "GJFH6" "GJFH8" "GJFHA")
                     )
                   )
        )
        (if (= (&GSYS "钢筋间距符号") 0) (setq st "@") (setq st "-"))
        (@text (nth 28 txt) pm1 lay zg 0 nil wf)
        (ssadd (entlast) sss)
        (@text 
          (if pp 
            (strcat "R=" (itoa (/ (atoi (nth 1 txt)) 2)))
            (strcat (nth 1 txt) "X" (nth 2 txt))
          )
          (polar pm1 (* 1.5 pi) (* 1.25 zg))
          lay
          zg
          0
          nil
          wf
        )
        (ssadd (entlast) sss)
        (@text 
          (strcat (itoa no) str1 jjzhj)
          (polar pm1 (* 1.5 pi) (* 2.5 zg))
          lay
          zg
          0
          nil
          wf
        )
        (ssadd (entlast) sss)
        (@text 
          (strcat str2 gjzhj st (nth 3 txt) "/" (nth 4 txt))
          (polar pm1 (* 1.5 pi) (* 3.75 zg))
          lay
          zg
          0
          nil
          wf
        )
        (ssadd (entlast) sss)
        (&DGAR sss)
        (if (not pp) 
          (progn (&LJIG "详图柱子原位标" T) 
                 (if (> widno 0) 
                   (@text 
                     (strcat (itoa widno) str1 xzhbj)
                     (polar (&N2S p1 p2) _pi2 (* 0.83 zg))
                     lay
                     zg
                     0
                     "M"
                     wf
                   )
                 )
                 (if (> lonno 0) 
                   (@text 
                     (strcat (itoa lonno) str1 yzhbj)
                     (polar (&N2S p2 p3) pi (* 0.83 zg))
                     lay
                     zg
                     _pi2
                     "M"
                     wf
                   )
                 )
          )
        )
      )
      (defun biaoh (/ zg wf pm1 pm2 dis pw tmzg blzg bzzg shx er ers ang lay) 
        (setq dis  (* 0.5 (&FIND 1))
              tmzg (* &sp (&GSYS "图名字高"))
              blzg (* &sp (&GSYS "图名比例字高"))
              bzzg (* &sp (&GSYS "图名备注字高"))
              shx  (&GSYS "双划线")
              er   (entlast)
              ers  (ssadd)
        )
        (cond 
          ((= (nth 16 txt) "1") (setq dis (+ dis (* 30 &sp))))
          ((= (nth 15 txt) "1") (setq dis (+ dis (* 12 &sp))))
          (T (setq dis (* 2 dis)))
        )
        (setq zg  (&INTS "标号文字" 1)
              wf  (cadr zg)
              zg  (car zg)
              pm1 (polar (&N2S p3 p4) (* 1.5 pi) dis)
              pw  (* &sp (&GSYS "多义线宽度"))
              lay (&LJIG "详图柱子编号" T)
        )
        (@text (nth 28 txt) pm1 lay tmzg 0 "M" wf)
        (ssadd (entlast) ers)
        (setq dis (textbox (entget (entlast)))
              dis (* 1.6 (- (caadr dis) (caar dis)))
              pm2 (polar (polar pm1 0 (* 0.65 dis)) (* 1.5 pi) (* 0.75 tmzg))
              pm1 (polar pm1 (* 1.5 pi) (* 0.75 tmzg))
        )
        (@text (strcat "1:" (nth 6 txt)) pm2 lay blzg 0 nil wf)
        (ssadd (entlast) ers)
        (@pline (list (polar pm1 pi (* 0.5 dis)) (polar pm1 0 (* 0.5 dis))) pw nil)
        (ssadd (entlast) ers)
        (if (= shx 1.0) 
          (progn 
            (@line 
              (polar (polar pm1 pi (* 0.5 dis)) (* 1.5 pi) (+ pw pw))
              (polar (polar pm1 0 (* 0.5 dis)) (* 1.5 pi) (+ pw pw))
              lay
            )
            (ssadd (entlast) ers)
          )
        )
        (if (or (= (car txt) "0") (= (car txt) "1")) 
          (setq ang 0)
          (setq ang (atof (nth 26 txt)))
        )
        (if (not (zerop (+ an ang))) 
          (command ".Rotate" ers "" pt (* -1 (+ an ang)))
        )
      )
      (if (= (nth 16 txt) "1") (axis))
      (if (= (nth 17 txt) "1") (peij))
      (if (= (nth 25 txt) "1") (biaoh))
      (if (= (nth 15 txt) "1") (diml))
    )
    (defun zhgj (/ p p01 p02 p03 p04 p05 p06 p07 p08 dis1 dis2 pp pp1 pp2 pp3 pp4 kx 
                 ky i pl
                ) 
      (setq p01 (polar (polar p1 pi (+ di (* 0.5 w))) (* 1.5 pi) (+ di (* 0.5 w)))
            p02 (polar (polar p2 0 (+ di (* 0.5 w))) (* 1.5 pi) (+ di (* 0.5 w)))
            p03 (polar (polar p3 0 (+ di (* 0.5 w))) _pi2 (+ di (* 0.5 w)))
            p04 (polar (polar p4 pi (+ di (* 0.5 w))) _pi2 (+ di (* 0.5 w)))
            pl  (list p01 p02 p03 p04)
            p   (polar p01 (* 1.25 pi) (* 0.5 d))
            p05 (polar p (* 0.75 pi) (* 0.5 (+ d w)))
            p06 (polar p (* -0.25 pi) (* 0.5 (+ d w)))
            p07 (polar p05 (* 1.25 pi) (* 1.414 l))
            p08 (polar p06 (* 1.25 pi) (* 1.414 l))
      )
      (&LJIG "详图柱子线钢筋" T)
      (if (= (nth 18 txt) "1") 
        (@pline 
          (list p08 
                (inters p08 p06 p01 p04 nil)
                p01
                p02
                p03
                p04
                p01
                (inters p07 p05 p01 p02 nil)
                p07
          )
          w
          nil
        )
        (@pline (list p01 p02 p03 p04) w '((70 . 1)))
      )
      (&LJIG "详图柱子点钢筋" T)
      (command ".donut" 
               0
               d
               (setq p01 (polar (polar p01 pi (* 0.5 (+ w d))) 
                                (* 1.5 pi)
                                (* 0.5 (+ w d))
                         )
               )
               (setq p02 (polar (polar p02 0 (* 0.5 (+ w d))) 
                                (* 1.5 pi)
                                (* 0.5 (+ w d))
                         )
               )
               (setq p03 (polar (polar p03 0 (* 0.5 (+ w d))) _pi2 (* 0.5 (+ w d))))
               (setq p04 (polar (polar p04 pi (* 0.5 (+ w d))) 
                                _pi2
                                (* 0.5 (+ w d))
                         )
               )
               ""
      )
      (setq kx   (/ (- wid di di w w d) (1+ widno))
            ky   (/ (- lon di di w w d) (1+ lonno))
            i    0
            ptlw (list p01)
            ptll (list p01)
      )
      (while (> widno i) 
        (setq i (1+ i))
        (if (and (or (= (car txt) "3") (= (car txt) "5")) (= (/ (1+ widno) 2) i)) 
          (setq i (1+ i))
        )
        (if (>= widno i) 
          (command ".donut" 0 d (polar p01 pi (* i kx)) (polar p04 pi (* i kx)) "")
        )
        (setq ptlw (append ptlw (list (polar p01 pi (* i kx)))))
      )
      (setq i 0)
      (while (> lonno i) 
        (setq i (1+ i))
        (if (and (or (= (car txt) "3") (= (car txt) "6")) (= (/ (1+ lonno) 2) i)) 
          (setq i (1+ i))
        )
        (if (>= lonno i) 
          (command ".donut" 
                   0
                   d
                   (polar p02 (* 1.5 pi) (* i ky))
                   (polar p01 (* 1.5 pi) (* i ky))
                   ""
          )
        )
        (setq ptll (append ptll (list (polar p01 (* 1.5 pi) (* i ky)))))
      )
      (endchul p1 p2 p3 p4 nil 4)
      pl
    )
    (defun yxgj (pt dis / dl pt1 pt2 ang i p h ll an1 oldan p pwg0 pwg1 pt0 ww) 
      (&LJIG "详图柱子点钢筋" T)
      (command ".donut" (* 2.0 (- dis di w)) (* 2.0 (- dis di)) pt "")
      (endchul 
        (polar (polar pt 0 dis) _pi2 dis)
        (polar (polar pt pi dis) _pi2 dis)
        (polar (polar pt pi dis) (* 1.5 pi) dis)
        (polar (polar pt 0 dis) (* 1.5 pi) dis)
        (polar pt (* 0.25 pi) dis)
        widno
      )
      (setq oldan an
            ang   (/ (* 2 pi) widno)
            i     0
      )
      (if (= (car txt) "0") 
        (setq an (* 1.5 pi))
        (cond 
          ((or (= widno 8) (= widno 12))
           (setq an  (/ pi widno)
                 an1 an
           )
          )
          ((or (= widno 16) (= widno 20))
           (setq an  (/ pi widno)
                 an1 (* 2 an)
                 an  0
           )
          )
          ((or (= widno 24) (= widno 28))
           (setq an  (/ pi widno)
                 an1 (* 3 an)
           )
          )
          ((= widno 32)
           (setq an  (/ pi widno)
                 an1 (* 4 an)
                 an  0
           )
          )
        )
      )
      (&LJIG "详图柱子点钢筋" T)
      (while (> widno i) 
        (setq p (polar pt (+ an (* i ang)) (- dis di w (* 0.5 d)))
              i (1+ i)
        )
        (command ".donut" 0 d p "")
        (if (= widno i) 
          (setq pwg1 p)
          (if (= widno (+ i (if (<= widno 8) 1 (if (>= widno 20) 3 2)))) 
            (setq pwg0 p)
          )
        )
        (cond 
          ((= widno 8)
           (if (= i 2) 
             (setq pt0 p)
             (if (= i 6) (setq pwg0 p) (if (= i 7) (setq pwg1 p)))
           )
          )
          ((= widno 12)
           (if (= i 3) 
             (setq pt0 p)
             (if (= i 8) (setq pwg0 p) (if (= i 11) (setq pwg1 p)))
           )
          )
          ((= widno 16)
           (if (= i 4) 
             (setq pt0 p)
             (if (= i 11) (setq pwg0 p) (if (= i 15) (setq pwg1 p)))
           )
          )
          ((= widno 20)
           (if (= i 5) 
             (setq pt0 p)
             (if (= i 14) (setq pwg0 p) (if (= i 18) (setq pwg1 p)))
           )
          )
          ((= widno 24)
           (if (= i 5) 
             (setq pt0 p)
             (if (= i 16) (setq pwg0 p) (if (= i 21) (setq pwg1 p)))
           )
          )
          ((= widno 28)
           (if (= i 6) 
             (setq pt0 p)
             (if (= i 19) (setq pwg0 p) (if (= i 24) (setq pwg1 p)))
           )
          )
          ((= widno 32)
           (if (= i 7) 
             (setq pt0 p)
             (if (= i 22) (setq pwg0 p) (if (= i 28) (setq pwg1 p)))
           )
          )
        )
      )
      (&LJIG "详图柱子线钢筋" T)
      (if (= (car txt) "1") 
        (progn 
          (setq h   (* (- dis di w (* 0.5 d)) (sin an1))
                h   (+ h (* 0.5 (+ d w)))
                ang (atan (/ h (sqrt (- (* (- dis di w) (- dis di w)) (* h h)))))
          )
          (setq pt1 (polar pt (- _pi2 ang) (- dis di w))
                pt2 (polar pt (+ (* 1.5 pi) ang) (- dis di w))
          )
          (setq pt0 (inters pt1 
                            pt2
                            pt0
                            (polar pt0 (+ (angle pt1 pt2) _pi2) 100)
                            nil
                    )
                dd  (distance pt0 pt1)
                pt1 pt0
                pt0 (polar pt1 (- (angle pt1 pt2) _pi2) (+ w d))
                p0  (polar pt0 (angle pt1 pt2) l)
                pt2 (polar pt2 (angle pt2 pt1) dd)
                pt3 (polar pt2 (- (angle pt1 pt2) _pi2) (+ w d))
                p1  (polar pt3 (angle pt2 pt1) l)
          )
          (command ".pline" p0 "W" w w pt0 "A" pt1 "L" pt2 "A" pt3 "L" p1 "")
          (setq pt1 (polar pt (+ _pi2 ang) (- dis di w))
                pt2 (polar pt (- (* 1.5 pi) ang) (- dis di w))
          )
          (setq pt1 (polar pt1 (angle pt1 pt2) dd)
                pt0 (polar pt1 (+ (angle pt1 pt2) _pi2) (+ w d))
                p0  (polar pt0 (angle pt1 pt2) l)
                pt2 (polar pt2 (angle pt2 pt1) dd)
                pt3 (polar pt2 (+ (angle pt1 pt2) _pi2) (+ w d))
                p1  (polar pt3 (angle pt2 pt1) l)
          )
          (command ".pline" p0 "W" w w pt0 "A" pt1 "L" pt2 "A" pt3 "L" p1 "")
          (setq pt1 (polar pt ang (- dis di w))
                pt2 (polar pt (- pi ang) (- dis di w))
          )
          (setq pt1 (polar pt1 (angle pt1 pt2) dd)
                pt0 (polar pt1 (+ (angle pt1 pt2) _pi2) (+ w d))
                p0  (polar pt0 (angle pt1 pt2) l)
                pt2 (polar pt2 (angle pt2 pt1) dd)
                pt3 (polar pt2 (+ (angle pt1 pt2) _pi2) (+ w d))
                p1  (polar pt3 (angle pt2 pt1) l)
          )
          (command ".pline" p0 "W" w w pt0 "A" pt1 "L" pt2 "A" pt3 "L" p1 "")
          (setq pt1 (polar pt (- (* 2 pi) ang) (- dis di w))
                pt2 (polar pt (+ pi ang) (- dis di w))
          )
          (setq pt1 (polar pt1 (angle pt1 pt2) dd)
                pt0 (polar pt1 (- (angle pt1 pt2) _pi2) (+ w d))
                p0  (polar pt0 (angle pt1 pt2) l)
                pt2 (polar pt2 (angle pt2 pt1) dd)
                pt3 (polar pt2 (- (angle pt1 pt2) _pi2) (+ w d))
                p1  (polar pt3 (angle pt2 pt1) l)
          )
          (command ".pline" p0 "W" w w pt0 "A" pt1 "L" pt2 "A" pt3 "L" p1 "")
        )
      )
      (if (= (nth 18 txt) "1") 
        (progn 
          (setq pwga (angle pt pwg0)
                ww   (* 0.5 (+ d w))
          )
          (command ".pline" 
                   (polar pwg0 pwga ww)
                   "W"
                   w
                   w
                   "A"
                   "S"
                   (polar pwg0 (- pwga _pi2) ww)
                   (setq p (polar pwg0 (- pwga pi) ww))
                   "L"
                   (polar p (+ pwga _pi2) l)
                   ""
          )
          (setq pwga (angle pt pwg1))
          (command ".pline" 
                   (polar pwg1 pwga ww)
                   "W"
                   w
                   w
                   "A"
                   "S"
                   (polar pwg1 (+ pwga _pi2) ww)
                   (setq p (polar pwg1 (- pwga pi) ww))
                   "L"
                   (polar p (- pwga _pi2) l)
                   ""
          )
        )
      )
      (setq an oldan)
    )
    (defun lxgj (pt1 pt2 / dis1 dis2 ang w1 w2) 
      (zhgj)
      (setq pt   (&N2S pt1 pt2)
            dis1 wi
            dis2 lo
            ang  (atan (/ dis2 dis1))
            w1   (/ w (sin ang))
            w2   (/ w (cos ang))
      )
      (setq dis1 (- dis1 di (* 0.5 w1))
            dis2 (- dis2 di (* 0.5 w2))
      )
      (setq p0 (polar pt _pi2 (- dis2 (* 0.5 w2) (/ (* 0.5 d) (cos ang)))))
      (&LJIG "详图柱子点钢筋" T)
      (command ".donut" 
               0
               d
               (polar pt 0 (- dis1 (* 0.5 w1) (/ (* 0.5 d) (sin ang))))
               p0
               (polar pt pi (- dis1 (* 0.5 w1) (/ (* 0.5 d) (sin ang))))
               (polar pt (* 1.5 pi) (- dis2 (* 0.5 w2) (/ (* 0.5 d) (cos ang))))
               ""
      )
      (&LJIG "详图柱子线钢筋" T)
      (if (= (nth 18 txt) "1") 
        (progn 
          (setq p1 (polar p0 0 (* 0.5 (+ w d)))
                p2 (polar p1 (* 1.5 pi) l)
                p1 (inters p1 p2 (polar pt 0 dis1) (polar pt _pi2 dis2) nil)
          )
          (@pline 
            (list p2 
                  (polar pt _pi2 dis2)
                  (polar pt pi dis1)
                  (polar pt (* 1.5 pi) dis2)
                  (polar pt 0 dis1)
                  (polar pt _pi2 dis2)
                  (polar p1 pi (+ d w))
                  (polar p2 pi (+ d w))
            )
            w
            nil
          )
        )
        (@pline 
          (list (polar pt 0 dis1) 
                (polar pt _pi2 dis2)
                (polar pt pi dis1)
                (polar pt (* 1.5 pi) dis2)
          )
          w
          '((70 . 1))
        )
      )
    )
    (defun qua (an r di / ang dis) 
      (setq ang (* 0.5 an)
            dis (/ (+ di r) (sin ang))
      )
      dis
    )
    (defun lbxgj1 (pt1 pt2 / dis1 dis2 ang w2 p0 p5 p6 p7 pl) 
      (setq pl   (zhgj)
            p01  (car pl)
            p02  (cadr pl)
            p03  (caddr pl)
            p04  (cadddr pl)
            pt   (&N2S pt1 pt2)
            dis1 wid
            dis2 lon
      )
      (setq dis1 (- dis1 w w di di)
            dis2 (- dis2 w w di di d)
            kx   (* 0.5 dis1)
            ky   (/ dis2 (1+ lonno))
            ky   (* ky (fix (/ (+ 2 lonno) 3)))
            ang  (atan (/ ky kx))
      )
      (setq p0 (polar (polar p01 (* 1.5 pi) (+ (* 0.5 (+ w d)) ky)) 
                      pi
                      (* 0.5 (+ w d))
               )
            p1 (polar p0 (- _pi2 ang) (* 0.5 (+ w d)))
            p2 (polar (polar p01 pi (+ (* 0.5 w) kx)) (* 1.5 pi) (* 0.5 (+ w d)))
            p3 (polar p2 ang (* 0.5 (+ w d)))
            p0 (inters p01 p04 p1 p3 nil)
            p1 (polar p01 pi (+ (* 0.5 w) kx))
            p2 (polar p02 (* 1.5 pi) (distance p01 p0))
            p3 (polar p03 _pi2 (distance p01 p0))
            p4 (polar p03 0 (distance p01 p1))
            p5 (polar p04 _pi2 (distance p01 p0))
      )
      (&LJIG "详图柱子点钢筋" T)
      (command ".donut" 
               0
               d
               (setq p6 (polar p1 
                               (* 1.5 pi)
                               (qua (- pi ang ang) (* 0.5 d) (* 0.5 w))
                        )
               )
               (polar p4 _pi2 (qua (- pi ang ang) (* 0.5 d) (* 0.5 w)))
               ""
      )
      (setq p6 (polar p6 0 (* 0.5 (+ w d)))
            p7 (polar p6 (* 1.5 pi) l)
            p6 (inters p6 p7 p0 p1 nil)
      )
      (&LJIG "详图柱子线钢筋" T)
      (if (= (nth 18 txt) "1") 
        (@pline 
          (list p7 
                p6
                p1
                p2
                p3
                p4
                p5
                p0
                p1
                (polar p6 pi (+ d w))
                (polar p7 pi (+ d w))
          )
          w
          nil
        )
        (@pline (list p0 p1 p2 p3 p4 p5) w '((70 . 1)))
      )
    )
    (defun lbxgj2 (pt1 pt2 / dis1 dis2 ang w1 p0 p5 p6 p7 pl) 
      (setq pl   (zhgj)
            p01  (car pl)
            p02  (cadr pl)
            p03  (caddr pl)
            p04  (cadddr pl)
            pt   (&N2S pt1 pt2)
            dis1 wid
            dis2 lon
      )
      (setq dis1 (- dis1 w w di di d)
            dis2 (- dis2 w w di di)
            kx   (/ dis1 (1+ widno))
            kx   (* kx (fix (/ (+ 2 widno) 3)))
            ky   (* 0.5 dis2)
            ang  (atan (/ ky kx))
      )
      (setq p0 (polar (polar p01 (* 1.5 pi) (+ (* 0.5 w) ky)) pi (* 0.5 (+ w d)))
            p1 (polar p0 (- _pi2 ang) (* 0.5 (+ w d)))
            p2 (polar (polar p01 pi (+ (* 0.5 (+ w d)) kx)) 
                      (* 1.5 pi)
                      (* 0.5 (+ w d))
               )
            p3 (polar p2 ang (* 0.5 (+ w d)))
            p1 (inters p01 p02 p1 p3 nil)
            p0 (polar p01 (* 1.5 pi) (+ (* 0.5 w) ky))
            p2 (polar p02 0 (distance p01 p1))
            p3 (polar p02 (* 1.5 pi) (distance p01 p0))
            p4 (polar p03 0 (distance p01 p1))
            p5 (polar p04 pi (distance p01 p1))
      )
      (&LJIG "详图柱子点钢筋" T)
      (command ".donut" 
               0
               d
               (polar p0 pi (qua (+ ang ang) (* 0.5 d) (* 0.5 w)))
               (setq p6 (polar p3 0 (qua (+ ang ang) (* 0.5 d) (* 0.5 w))))
               ""
      )
      (setq p6 (polar p6 _pi2 (* 0.5 (+ w d)))
            p7 (polar p6 0 l)
            p6 (inters p6 p7 p2 p3 nil)
      )
      (&LJIG "详图柱子线钢筋" T)
      (if (= (nth 18 txt) "1") 
        (@pline 
          (list p7 
                p6
                p3
                p4
                p5
                p0
                p1
                p2
                p3
                (polar p6 (* 1.5 pi) (+ d w))
                (polar p7 (* 1.5 pi) (+ d w))
          )
          w
          nil
        )
        (@pline (list p0 p1 p2 p3 p4 p5) w '((70 . 1)))
      )
    )
    (defun bbxgj (pt1 pt2 / pl kx ky p01 p02 p03 p04 dis1 dis2 ang p0 p5 p6 p7 p8 p9) 
      (setq pl   (zhgj)
            p01  (car pl)
            p02  (cadr pl)
            p03  (caddr pl)
            p04  (cadddr pl)
            pt   (&N2S pt1 pt2)
            dis1 wid
            dis2 lon
      )
      (setq dis1 (- dis1 w w di di d)
            dis2 (- dis2 w w di di d)
      )
      (setq kx  (/ dis1 (1+ widno))
            ky  (/ dis2 (1+ lonno))
            kx  (* kx (fix (/ (+ 2 widno) 3)))
            ky  (* ky (fix (/ (+ 2 lonno) 3)))
            ang (atan (/ ky kx))
      )
      (setq p0 (polar (polar p01 (* 1.5 pi) (+ (* 0.5 (+ w d)) ky)) 
                      pi
                      (* 0.5 (+ w d))
               )
            p1 (polar p0 (- _pi2 ang) (* 0.5 (+ w d)))
            p2 (polar (polar p01 pi (+ (* 0.5 (+ w d)) kx)) 
                      (* 1.5 pi)
                      (* 0.5 (+ w d))
               )
            p3 (polar p2 ang (* 0.5 (+ w d)))
            p0 (inters p01 p04 p1 p3 nil)
            p1 (inters p01 p02 p1 p3 nil)
            p2 (polar p02 0 (distance p01 p1))
            p3 (polar p0 pi (+ dis1 w d))
            p4 (polar p03 _pi2 (distance p02 p3))
            p5 (polar p2 (* 1.5 pi) (+ dis2 w d))
            p6 (polar p1 (* 1.5 pi) (+ dis2 w d))
            p7 (polar p4 0 (+ dis1 w d))
            p8 (polar p5 (- _pi2 (* 0.5 ang)) (qua (- pi ang) (* 0.5 d) (* 0.5 w)))
      )
      (setq p8 (polar p8 (- pi (* 0.5 ang)) (* 0.5 (+ d w)))
            p9 (polar p8 (- _pi2 (* 0.5 ang)) l)
            p8 (inters p8 p9 p4 p5 nil)
      )
      (&LJIG "详图柱子线钢筋" T)
      (if (= (nth 18 txt) "1") 
        (@pline 
          (list p9 
                p8
                p5
                p6
                p7
                p0
                p1
                p2
                p3
                p4
                p5
                (inters p5 
                        p6
                        (setq p9 (polar p9 (* -0.5 ang) (+ d w)))
                        (polar p9 (- _pi2 (* 0.5 ang)) l)
                        nil
                )
                p9
          )
          w
          nil
        )
        (@pline (list p0 p1 p2 p3 p4 p5 p6 p7) w '((70 . 1)))
      )
    )
    (defun yxgjhf (/ findpt drgj pl p01 p02 p03 p04 p05 p06 p07 p08 dis1 dis2 p0 p5 
                   p6 p7 p i plx ply
                  ) 
      (defun findpt (pl ptl / od pe d pel ppp) 
        (while (setq pp (car pl)) 
          (setq od  wid
                ppp ptl
          )
          (while (setq p (car ppp)) 
            (setq d   (distance pp p)
                  ppp (cdr ppp)
            )
            (if (< d od) 
              (setq pe p
                    od d
              )
            )
          )
          (setq pel (append pel (list pe))
                pl  (cdr pl)
          )
        )
        pel
      )
      (defun drgj (p0 p1 p2 p3 a i / p4 p5 p6 p7 p) 
        (&LJIG "详图柱子线钢筋" T)
        (if (or (equal p0 p1 1.0) (equal p0 p3 1.0)) 
          (progn 
            (setq p1 (polar p0 a (* 0.5 (+ d w)))
                  p0 (polar p1 (+ a _pi2) l)
                  p4 (polar p1 (+ a pi) (+ d w))
                  p2 (polar p2 (+ a pi) (* 0.5 (+ d w)))
                  p3 (polar p2 a (+ d w))
                  p5 (polar p3 (- a _pi2) l)
            )
            (command ".pline" p0 "w" w w p1 "a" p4 "l" p2 "a" p3 "l" p5 "")
          )
          (progn 
            (if (= 1 (rem i 2)) 
              (setq p4 (polar p2 (* 0.75 pi) (* 0.5 (+ d w)))
                    p5 (polar p4 (* 0.25 pi) l)
                    p7 (polar p2 (* 1.75 pi) (* 0.5 (+ d w)))
                    p6 (polar p7 (* 0.25 pi) l)
              )
              (setq p4 (polar p0 (* 1.75 pi) (* 0.5 (+ d w)))
                    p5 (polar p4 (* 1.25 pi) l)
                    p7 (polar p0 (* 0.75 pi) (* 0.5 (+ d w)))
                    p6 (polar p7 (* 1.25 pi) l)
              )
            )
            (setq p0 (polar p0 (* 0.25 pi) (* 0.5 (sqrt 2.0) (+ d w)))
                  p1 (polar p1 (* 0.75 pi) (* 0.5 (sqrt 2.0) (+ d w)))
                  p2 (polar p2 (* 1.25 pi) (* 0.5 (sqrt 2.0) (+ d w)))
                  p3 (polar p3 (* 1.75 pi) (* 0.5 (sqrt 2.0) (+ d w)))
            )
            (if (= 1 (rem i 2)) 
              (setq p4 (inters p1 p2 p4 p5 nil)
                    p7 (inters p3 p2 p6 p7 nil)
              )
              (setq p4 (inters p5 p4 p0 p3 nil)
                    p7 (inters p6 p7 p0 p1 nil)
                    p  p0
                    p0 p2
                    p2 p
                    p  p1
                    p1 p3
                    p3 p
              )
            )
            (if (= (nth 18 txt) "1") 
              (@pline (list p5 p4 p2 p3 p0 p1 p2 p7 p6) w nil)
              (@pline (list p0 p1 p2 p3) w '((70 . 1)))
            )
          )
        )
      )
      (setq pl   (zhgj)
            p01  (car pl)
            p02  (cadr pl)
            p03  (caddr pl)
            p04  (cadddr pl)
            pt   (&N2S p01 p03)
            dis1 wid
            dis2 lon
      )
      (setq dis1 (- dis1 w w di di d)
            dis2 (- dis2 w w di di d)
      )
      (setq kx (/ dis1 (1- zs1))
            ky (/ dis2 (1- zs2))
            i  0
      )
      (while (> (- zs1 2) i) 
        (setq i   (1+ i)
              p   (polar p01 pi (* i kx))
              plx (append plx (list p))
        )
      )
      (setq plx (findpt plx ptlw))
      (setq i 0)
      (while (setq p0 (car plx)) 
        (setq plx (cdr plx)
              p1  (car plx)
        )
        (if (not p1) (setq p1 p0))
        (if (= 1 (rem i 2)) 
          (setq p  p0
                p0 p1
                p1 p
          )
        )
        (setq p2  (polar p1 (* 1.5 pi) dis2)
              p3  (polar p0 (* 1.5 pi) dis2)
              i   (1+ i)
              plx (reverse (cdr plx))
        )
        (drgj p0 p1 p2 p3 pi i)
      )
      (setq i 0)
      (while (> (- zs2 2) i) 
        (setq i   (1+ i)
              p   (polar p01 (* 1.5 pi) (* i ky))
              ply (append ply (list p))
        )
      )
      (setq ply (findpt ply ptll))
      (setq i 0)
      (while (setq p0 (car ply)) 
        (setq ply (cdr ply)
              p3  (car ply)
        )
        (if (not p3) (setq p3 p0))
        (if (= 1 (rem i 2)) 
          (setq p  p0
                p0 p3
                p3 p
          )
        )
        (setq p2  (polar p3 pi dis1)
              p1  (polar p0 pi dis1)
              i   (1+ i)
              ply (reverse (cdr ply))
        )
        (drgj p0 p1 p2 p3 _pi2 i)
      )
    )
    (defun drawzh (an / p1 p2 p3 p4 en ss ang) 
      (&LJIG "详图柱子" T)
      (setq pt (polar (polar pt 0 (* sc px)) _pi2 (* sc py))
            p1 (polar (polar pt 0 wi) _pi2 lo)
            p2 (polar p1 pi wid)
            p3 (polar p2 (* 1.5 pi) lon)
            p4 (polar p3 0 wid)
      )
      (if (or (= (car txt) "0") (= (car txt) "1")) 
        (command ".donut" (* 2 wi) (* 2 wi) pt "")
        (emk lay)
      )
      (setq en (entlast)
            ss (ssadd)
            ss (ssadd en ss)
            zj "1"
      )
      (cond 
        ((= (car txt) "0") (yxgj pt wi))
        ((= (car txt) "1") (yxgj pt wi))
        ((= (car txt) "2") (zhgj))
        ((= (car txt) "3") (lxgj p2 p4))
        ((= (car txt) "4") (bbxgj p2 p4))
        ((= (car txt) "5") (lbxgj1 p2 p4))
        ((= (car txt) "6") (lbxgj2 p2 p4))
        ((= (car txt) "7") (yxgjhf))
      )
      (setq pt (polar (polar pt pi (* sc px)) (* 1.5 pi) (* sc py)))
      (while (entnext en) (ssadd (setq en (entnext en)) ss))
      (if (or (= (car txt) "0") (= (car txt) "1")) 
        (setq ang 0)
        (setq ang (atof (nth 26 txt)))
      )
      (if (not (zerop (+ an ang))) (command ".Rotate" ss "" pt (+ an ang)))
    )
    (if (or (= (car fl) -8) (= (car fl) -18)) 
      (progn 
        (setq txt (cadr fl)
              i   0
              str ""
        )
        (while (< i 29) 
          (setq str (strcat str (nth i txt) "\t")
                i   (1+ i)
          )
        )
        (&GLAY "Tssd/Dcl_Hzh/Fhgjzh" (strcat str (nth 29 txt)))
        (setq sc  (/ &sp (atoi (nth 6 txt)) 1.0)
              wid (* (atoi (nth 1 txt)) sc)
              lon (* (atoi (nth 2 txt)) sc)
              wi  (* 0.5 wid)
              lo  (* 0.5 lon)
              px  (atoi (nth 21 txt))
              py  (atoi (nth 22 txt))
              lay (&LJIG "详图柱子" T)
        )
        (setq r  (&GSYS "圆钩半径")
              l  (&GSYS "圆钩长度")
              w  (&GSYS "箍筋宽度")
              d  (&GSYS "点筋直径")
              di (* (atoi (nth 5 txt)) sc)
              r  (* r &sp)
              l  (* l &sp)
              w  (* w &sp)
              d  (* d &sp)
              di (max di (* (&GSYS "保护层厚") &sp))
        )
        (if (= (car fl) -18) 
          (progn 
            (while 
              (and (setq p1 (&OSNP "\n点取柱子插入区域第一角点<退出>: ")) 
                   (setq p2 (&OSNP p1 "\n点取柱子插入区域第二角点<退出>: " t))
              )
              (if 
                (setq ss (ssget "c" 
                                p1
                                p2
                                (list (cons 8 (&LJIG "平面轴线")) 
                                      '(0 . "line,arc,circle")
                                )
                         )
                )
                (while (setq en (ssname ss 0)) 
                  (ssdel en ss)
                  (setq len  (sslength ss)
                        enl  (entget en)
                        flag (strcase (cdr (assoc 0 enl)))
                  )
                  (while (> len 0) 
                    (setq len  (1- len)
                          en1  (ssname ss len)
                          en1l (entget en1)
                          fla  (strcase (cdr (assoc 0 en1l)))
                    )
                    (cond 
                      ((and (wcmatch flag "LINE") (wcmatch fla "LINE"))
                       (setq pintl (&ORDR en en1))
                       (while (setq pt (car pintl)) 
                         (if (= (nth 27 txt) "1") 
                           (progn 
                             (setq an1   (angle (&DRAG en 10) (&DRAG en 11))
                                   an2   (angle (&DRAG en1 10) (&DRAG en1 11))
                                   pintl (cdr pintl)
                             )
                             (if (equal an1 (+ pi pi)) (setq an1 0))
                             (if (equal an2 (+ pi pi)) (setq an2 0))
                             (if (or (> an1 pi) (equal an1 pi 0.01)) 
                               (setq an1 (- an1 pi))
                             )
                             (if (or (> an2 pi) (equal an2 pi 0.01)) 
                               (setq an2 (- an2 pi))
                             )
                             (if (< (abs (- an1 _pi2)) (abs (- an2 _pi2))) 
                               (setq ang an2)
                               (setq ang an1)
                             )
                           )
                           (setq ang   0
                                 an    _pi2
                                 pintl (cdr pintl)
                           )
                         )
                         (setq ang (* 180 (/ ang pi)))
                         (drawzh ang)
                       )
                      )
                      ((and (wcmatch flag "LINE") (not (wcmatch fla "LINE")))
                       (setq pintl (&ORDR en en1))
                       (while (setq pt (car pintl)) 
                         (if (= (nth 27 txt) "1") 
                           (setq ang   (angle (&DRAG en 10) (&DRAG en 11))
                                 pintl (cdr pintl)
                           )
                           (setq ang   0
                                 pintl (cdr pintl)
                           )
                         )
                         (setq ang (* 180 (/ ang pi)))
                         (drawzh ang)
                       )
                      )
                      ((and (not (wcmatch flag "LINE")) (wcmatch fla "LINE"))
                       (setq pintl (&ORDR en en1))
                       (while (setq pt (car pintl)) 
                         (if (= (nth 27 txt) "1") 
                           (setq ang   (angle (&DRAG en1 10) (&DRAG en1 11))
                                 pintl (cdr pintl)
                           )
                           (setq ang   0
                                 pintl (cdr pintl)
                           )
                         )
                         (setq ang (* 180 (/ ang pi)))
                         (drawzh ang)
                       )
                      )
                      ((and (not (wcmatch flag "LINE")) (not (wcmatch fla "LINE")))
                       (setq pintl (&ORDR en en1))
                       (while (setq pt (car pintl)) 
                         (setq ang   0
                               pintl (cdr pintl)
                         )
                         (drawzh ang)
                       )
                      )
                    )
                  )
                )
              )
            )
          )
          (progn 
            (setq pt (getvar "viewctr")
                  ss (ssadd)
            )
            (command ".Point" pt)
            (setq en  (entlast)
                  en1 en
            )
            (drawzh 0)
            (while (setq en (entnext en)) 
              (if (not (wcmatch "ATTRIB" (strcase (&DRAG en 0)))) (ssadd en ss))
            )
            (if en1 (entdel en1))
            (&END "\n点取插入柱子的中心点<退出>: " ss pt)
          )
        )
      )
    )
  )
  (defun chs_dcl (txt / #ret slide isnum chatxt what dia wid lon jj fjj hou bl yzj0 
                  yzj1 zj zj1 zj2
                 ) 
    (defun isnum (n1 n2 / lab sg1 sg2 st1 st2 vl) 
      (if n1 
        (if (= (type n1) 'REAL) 
          (setq sg1 >=
                st1 "≥"
          )
          (setq sg1 >
                st1 "＞"
          )
        )
      )
      (if n2 
        (if (= (type n2) 'REAL) 
          (setq sg2 <=
                st2 "≤"
          )
          (setq sg2 <
                st2 "＜"
          )
        )
      )
      (if (wcmatch $value "[.]*") (setq $value (strcat "0" $value)))
      (if 
        (and (= (setq vl (read $value)) (atof $value)) 
             (or (and (null n1) (null n2)) 
                 (and n1 (null n2) (sg1 vl n1))
                 (and n2 (null n1) (sg2 vl n2))
                 (and n1 n2 (sg1 vl n1) (sg2 vl n2))
             )
        )
        (set (read $key) vl)
        (progn (set_tile $key (&RTXT (eval (read $key)))) nil)
      )
    )
    (defun chatxt (/ zdj gdj) 
      (setq txt (@subst txt 1 (get_tile "wid"))
            txt (@subst txt 2 (get_tile "lon"))
            txt (@subst txt 3 (get_tile "jj"))
            txt (@subst txt 4 (get_tile "fjj"))
            txt (@subst txt 5 (get_tile "hou"))
            txt (@subst txt 6 (get_tile "bl"))
            txt (@subst txt 19 (get_tile "zs1"))
            txt (@subst txt 20 (get_tile "zs2"))
            txt (@subst txt 8 (get_tile "jzj"))
            txt (@subst txt 10 (get_tile "kzj"))
            txt (@subst txt 12 (get_tile "czj"))
            txt (@subst txt 14 (get_tile "gzj"))
            txt (@subst txt 21 (get_tile "px"))
            txt (@subst txt 22 (get_tile "py"))
            txt (@subst txt 7 (get_tile "zdj"))
            txt (@subst txt 13 (get_tile "gdj"))
            txt (@subst txt 15 (get_tile "dim"))
            txt (@subst txt 16 (get_tile "zb"))
            txt (@subst txt 17 (get_tile "pj"))
            txt (@subst txt 18 (get_tile "jg"))
            txt (@subst txt 25 (get_tile "bho"))
            txt (@subst txt 26 (get_tile "rot"))
            txt (@subst txt 27 (get_tile "xz"))
            txt (@subst txt 28 (get_tile "bh"))
            txt (@subst txt 29 (get_tile "td"))
      )
      (if (= "" (get_tile "labx")) 
        (setq txt (@subst txt 23 "nolabel"))
        (setq txt (@subst txt 23 (get_tile "labx")))
      )
      (if (= "" (get_tile "laby")) 
        (setq txt (@subst txt 24 "nolabel"))
        (setq txt (@subst txt 24 (get_tile "laby")))
      )
      (if (= (nth 16 txt) "1") 
        (progn (mode_tile "labx" 0) (mode_tile "laby" 0))
        (progn (mode_tile "labx" 1) (mode_tile "laby" 1))
      )
      (if (= (nth 25 txt) "1") (mode_tile "bh" 0) (mode_tile "bh" 1))
    )
    (defun #ret (kw) 
      (chatxt)
      (if (and (= (nth 25 txt) "1") (null (read (nth 28 txt)))) 
        (progn (set_tile "error" "**柱号不能为空!") (mode_tile "bh" 2))
        (progn (setq what kw) (done_dialog 1))
      )
    )
    (defun slide (fl / selsld duplen addl drawyxzh back oldtxt kno kzj cno czj tx1 
                  tx2 l0 l1 l dis no angl kn cn tempzs1 tempzs2
                 ) 
      (defun selsld (/ vslide getimg what dias no n i) 
        (defun vslide (name img / x y) 
          (setq x (dimx_tile img)
                y (dimy_tile img)
          )
          (start_image img)
          (fill_image 0 0 x y -2)
          (slide_image 0 0 x (- y 20) (strcat "Tssd (" name ")"))
          (end_image)
        )
        (defun getimg (n /) 
          (mode_tile (strcat "img" n) 4)
          (mode_tile (strcat "img" no) 4)
          (setq no n)
          (if (= $reason 4) (progn (done_dialog -2) (setq what -2)))
        )
        (setq what 2
              dias (lib::dcl "Column")
              no   (car txt)
              txt  (cdr txt)
              i    0
        )
        (while (> what 0) 
          (if (not (new_dialog "Selzh" dias)) (exit))
          (while (< i 8) 
            (vslide (strcat "Yxzh" (itoa i)) (strcat "img" (itoa i)))
            (setq i (1+ i))
          )
          (action_tile "img0" "(getimg \"0\")")
          (action_tile "img1" "(getimg \"1\")")
          (action_tile "img2" "(getimg \"2\")")
          (action_tile "img3" "(getimg \"3\")")
          (action_tile "img4" "(getimg \"4\")")
          (action_tile "img5" "(getimg \"5\")")
          (action_tile "img6" "(getimg \"6\")")
          (action_tile "img7" "(getimg \"7\")")
          (mode_tile (strcat "img" no) 4)
          (action_tile "accept" "(getimg no)(done_dialog -2)(setq what -1)")
          (start_dialog)
        )
        (unload_dialog dias)
        (if (= no "7") 
          (progn (set_tile "zs1" "4") 
                 (set_tile "zs2" "4")
                 (setq zs1 4
                       zs2 4
                 )
          )
        )
        (setq txt (cons no txt)
              txt (@subst txt 9 (if (= no "7") "4" "0"))
              txt (@subst txt 11 (if (= no "7") "4" "0"))
        )
      )
      (defun drawyxzh (/ drawgj drawsld drawsldc cirzj i w0 x0 h0 y0 isc lp xx yy ppx 
                       ppy zj zjh
                      ) 
        (defun drawgj (fl / dra knox cnox) 
          (defun dra (x y col /) 
            (vector_image (1- x) y (1+ x) y col)
            (vector_image (1- x) (1- y) (1+ x) (1+ y) col)
            (vector_image x (1- y) x (1+ y) col)
            (vector_image (1- x) (1+ y) (1+ x) (1- y) col)
          )
          (if (/= kn 0) (setq knox (fix (/ (* 2 (- xx 5)) (1+ kn)))))
          (if (/= cn 0) (setq cnox (fix (/ (* 2 (- yy 5)) (1+ cn)))))
          (while (> kn 0) 
            (dra (+ (* kn knox) (- x0 xx -5)) (- y0 yy -9) 1)
            (dra (+ (* kn knox) (- x0 xx -5)) (+ y0 yy -9) 1)
            (setq kn (1- kn))
          )
          (while (> cn 0) 
            (dra (- x0 xx -9) (+ (* cn cnox) (- y0 yy -5)) 1)
            (dra (+ x0 xx -9) (+ (* cn cnox) (- y0 yy -5)) 1)
            (setq cn (1- cn))
          )
        )
        (defun drawsld (x y col / dra) 
          (defun dra (x y col /) 
            (vector_image (1- x) y (1+ x) y col)
            (vector_image (1- x) (1- y) (1+ x) (1+ y) col)
            (vector_image x (1- y) x (1+ y) col)
            (vector_image (1- x) (1+ y) (1+ x) (1- y) col)
          )
          (vector_image (- x0 x) (- y0 y) (+ x0 x) (- y0 y) col)
          (vector_image (- x0 x) (- y0 y) (- x0 x) (+ y0 y) col)
          (vector_image (+ x0 x) (- y0 y) (+ x0 x) (+ y0 y) col)
          (vector_image (- x0 x) (+ y0 y) (+ x0 x) (+ y0 y) col)
          (if (= col 1) 
            (progn 
              (if (= (nth 18 txt) "1") 
                (progn 
                  (vector_image (+ x0 x) (- y0 y -4) (+ x0 x -5) (- y0 y -9) 6)
                  (vector_image (+ x0 x -4) (- y0 y) (+ x0 x -9) (- y0 y -5) 6)
                )
              )
              (dra (- x0 x -4) (- y0 y -4) 1)
              (dra (+ x0 x -4) (- y0 y -4) 1)
              (dra (- x0 x -4) (+ y0 y -4) 1)
              (dra (+ x0 x -4) (+ y0 y -4) 1)
            )
          )
        )
        (defun drawsldc (r col / a15 a45 a75 r1 r2 r3) 
          (setq a15 (/ pi 12)
                a45 (/ pi 4)
                a75 (/ pi 2.4)
                r1  (fix r)
                r2  (fix (* (/ r (cos a15)) (cos a45)))
                r3  (fix (* (/ r (cos a15)) (cos a75)))
          )
          (vector_image (+ x0 r1) (+ y0 r3) (+ x0 r1) (- y0 r3) col)
          (vector_image (+ x0 r1) (- y0 r3) (+ x0 r2) (- y0 r2) col)
          (vector_image (+ x0 r2) (- y0 r2) (+ x0 r3) (- y0 r1) col)
          (vector_image (+ x0 r3) (- y0 r1) (- x0 r3) (- y0 r1) col)
          (vector_image (- x0 r3) (- y0 r1) (- x0 r2) (- y0 r2) col)
          (vector_image (- x0 r2) (- y0 r2) (- x0 r1) (- y0 r3) col)
          (vector_image (- x0 r1) (- y0 r3) (- x0 r1) (+ y0 r3) col)
          (vector_image (- x0 r1) (+ y0 r3) (- x0 r2) (+ y0 r2) col)
          (vector_image (- x0 r2) (+ y0 r2) (- x0 r3) (+ y0 r1) col)
          (vector_image (- x0 r3) (+ y0 r1) (+ x0 r3) (+ y0 r1) col)
          (vector_image (+ x0 r3) (+ y0 r1) (+ x0 r2) (+ y0 r2) col)
          (vector_image (+ x0 r2) (+ y0 r2) (+ x0 r1) (+ y0 r3) col)
          (if (= col 1) 
            (progn 
              (if (= (nth 18 txt) "1") 
                (progn 
                  (vector_image (- x0 r2) (+ y0 r2) (- x0 r2 -3) (+ y0 r2 -3) 6)
                  (vector_image (- x0 r2 -3) (+ y0 r2 -3) (- x0 r2 -7) (+ y0 r2) 6)
                  (vector_image (+ x0 r2) (+ y0 r2) (+ x0 r2 -3) (+ y0 r2 -3) 6)
                  (vector_image (+ x0 r2 -3) (+ y0 r2 -3) (+ x0 r2 -7) (+ y0 r2) 6)
                )
              )
              (if (= (car txt) "1") 
                (progn (vector_image (+ x0 r3) (- y0 r1) (+ x0 r3) (+ y0 r1) col) 
                       (vector_image (- x0 r3) (- y0 r1) (- x0 r3) (+ y0 r1) col)
                       (vector_image (+ x0 r1) (+ y0 r3) (- x0 r1) (+ y0 r3) col)
                       (vector_image (+ x0 r1) (- y0 r3) (- x0 r1) (- y0 r3) col)
                )
              )
            )
          )
        )
        (defun cirzj (/ dra ang an rx ry i) 
          (defun dra (x y col /) 
            (vector_image (1- x) y (1+ x) y col)
            (vector_image (1- x) (1- y) (1+ x) (1+ y) col)
            (vector_image x (1- y) x (1+ y) col)
            (vector_image (1- x) (1+ y) (1+ x) (1- y) col)
          )
          (if (= (car txt) "0") 
            (progn 
              (setq ang (/ (* 2 pi) kn)
                    an  (* 1.5 pi)
                    i   0
              )
              (while (> kn i) 
                (setq rx (fix (* (- xx 8) (cos (+ an (* i ang)))))
                      ry (fix (* (- xx 8) (sin (+ an (* i ang)))))
                      i  (1+ i)
                )
                (dra (- x0 rx) (- y0 ry) 1)
              )
            )
            (progn 
              (setq an (* 1.5 pi)
                    i  0
              )
              (while (> kn i) 
                (setq ang (/ (* pi (nth i angl)) 180)
                      rx  (fix (* (- xx 8) (cos ang)))
                      ry  (fix (* (- xx 8) (sin ang)))
                      i   (1+ i)
                )
                (dra (- x0 rx) (- y0 ry) 1)
              )
            )
          )
        )
        (setq w0  (dimx_tile "img")
              x0  (/ w0 2)
              h0  (dimy_tile "img")
              y0  (/ h0 2)
              isc (/ y0 750.)
              lp  (/ w0 (max (atoi (nth 1 txt)) (atoi (nth 2 txt))) 1.)
              isc (min isc lp)
              xx  (fix (* 0.5 (atoi (nth 1 txt)) isc))
              yy  (fix (* 0.5 (atoi (nth 2 txt)) isc))
              ppx (fix (* -1 px isc))
              ppy (fix (* py isc))
              zj  (atof (get_tile "rot"))
              zj  (/ (* zj pi) 180)
        )
        (if (< xx 22) (setq xx 22))
        (if (< yy 22) (setq yy 22))
        (start_image "img")
        (fill_image 0 0 w0 h0 -2)
        (vector_image (+ x0 10) (- y0 10) (- x0 10) (+ y0 10) 2)
        (vector_image (- x0 10) (- y0 10) (+ x0 10) (+ y0 10) 2)
        (vector_image (+ x0 ppx) (- y0 800) (+ x0 ppx) (+ 800 y0) 9)
        (vector_image (- x0 800) (+ y0 ppy) (+ x0 800) (+ y0 ppy) 9)
        (cond 
          ((or (= (car txt) "0") (= (car txt) "1"))
           (drawsldc xx 7)
           (drawsldc (- xx 5) 1)
           (cirzj)
          )
          ((= (car txt) "2")
           (drawsld xx yy 7)
           (drawsld (- xx 5) (- yy 5) 1)
           (drawgj 2)
          )
          ((= (car txt) "3")
           (drawsld xx yy 7)
           (drawsld (- xx 5) (- yy 5) 1)
           (vector_image x0 (- y0 yy -5) (- x0 xx -5) y0 1)
           (vector_image (- x0 xx -5) y0 x0 (+ y0 yy -5) 1)
           (vector_image x0 (+ y0 yy -5) (+ x0 xx -5) y0 1)
           (vector_image (+ x0 xx -5) y0 x0 (- y0 yy -5) 1)
           (if (= (nth 18 txt) "1") 
             (progn (vector_image (- x0 3) (- y0 yy -8) (- x0 3) (- y0 yy -14) 6) 
                    (vector_image (+ x0 3) (- y0 yy -8) (+ x0 3) (- y0 yy -14) 6)
             )
           )
           (drawgj 3)
          )
          ((= (car txt) "4")
           (drawsld xx yy 7)
           (drawsld (- xx 5) (- yy 5) 1)
           (setq dxx (fix (/ (- xx 5) 3))
                 dyy (fix (/ (- yy 5) 3))
           )
           (vector_image (- x0 dxx) (- y0 yy -5) (- x0 xx -5) (- y0 dyy) 1)
           (vector_image (- x0 xx -5) (+ y0 dyy) (- x0 dxx) (+ y0 yy -5) 1)
           (vector_image (+ x0 dxx) (+ y0 yy -5) (+ x0 xx -5) (+ y0 dyy) 1)
           (vector_image (+ x0 xx -5) (- y0 dyy) (+ x0 dxx) (- y0 yy -5) 1)
           (if (= (nth 18 txt) "1") 
             (progn 
               (vector_image (- x0 dxx 3) 
                             (+ y0 yy -8)
                             (- x0 dxx -3)
                             (+ y0 yy -14)
                             6
               )
               (vector_image (- x0 dxx -3) 
                             (+ y0 yy -5)
                             (- x0 dxx -9)
                             (+ y0 yy -11)
                             6
               )
             )
           )
           (drawgj 4)
          )
          ((= (car txt) "5")
           (drawsld xx yy 7)
           (drawsld (- xx 5) (- yy 5) 1)
           (setq dxx (fix (/ (- xx 5) 3))
                 dyy (fix (/ (- yy 5) 3))
           )
           (vector_image x0 (- y0 yy -5) (- x0 xx -5) (- y0 dyy) 1)
           (vector_image (- x0 xx -5) (+ y0 dyy) x0 (+ y0 yy -5) 1)
           (vector_image x0 (+ y0 yy -5) (+ x0 xx -5) (+ y0 dyy) 1)
           (vector_image (+ x0 xx -5) (- y0 dyy) x0 (- y0 yy -5) 1)
           (if (= (nth 18 txt) "1") 
             (progn (vector_image (- x0 3) (- y0 yy -8) (- x0 3) (- y0 yy -14) 6) 
                    (vector_image (+ x0 3) (- y0 yy -8) (+ x0 3) (- y0 yy -14) 6)
             )
           )
           (drawgj 5)
          )
          ((= (car txt) "6")
           (drawsld xx yy 7)
           (drawsld (- xx 5) (- yy 5) 1)
           (setq dxx (fix (/ (- xx 5) 3))
                 dyy (fix (/ (- yy 5) 3))
           )
           (vector_image (- x0 dxx) (- y0 yy -5) (- x0 xx -5) y0 1)
           (vector_image (- x0 xx -5) y0 (- x0 dxx) (+ y0 yy -5) 1)
           (vector_image (+ x0 dxx) (+ y0 yy -5) (+ x0 xx -5) y0 1)
           (vector_image (+ x0 xx -5) y0 (+ x0 dxx) (- y0 yy -5) 1)
           (if (= (nth 18 txt) "1") 
             (progn (vector_image (- x0 xx -8) (- y0 3) (- x0 xx -14) (- y0 3) 6) 
                    (vector_image (- x0 xx -8) (+ y0 3) (- x0 xx -14) (+ y0 3) 6)
             )
           )
           (drawgj 6)
          )
          ((= (car txt) "7")
           (drawsld xx yy 7)
           (drawsld (- xx 5) (- yy 5) 1)
           (setq i   0
                 dxx (fix (/ (* 2 (- xx 5)) (1- zs1)))
                 dyy (fix (/ (* 2 (- yy 5)) (1- zs2)))
           )
           (while (<= i (- zs1 2)) 
             (vector_image (- (+ x0 xx -5) (* i dxx)) 
                           (- y0 yy -5)
                           (- (+ x0 xx -5) (* i dxx))
                           (+ y0 yy -5)
                           1
             )
             (if (and (<= i (* 0.5 zs1)) (= (nth 18 txt) "1")) 
               (progn 
                 (vector_image (- (+ x0 xx -5) (* i dxx)) 
                               (- y0 yy -8)
                               (- (+ x0 xx -10) (* i dxx))
                               (- y0 yy -13)
                               6
                 )
                 (vector_image (- (+ x0 xx -8) (* i dxx)) 
                               (- y0 yy -5)
                               (- (+ x0 xx -13) (* i dxx))
                               (- y0 yy -10)
                               6
                 )
               )
             )
             (setq i (1+ i))
           )
           (setq i 0)
           (while (<= i (- zs2 2)) 
             (vector_image (- x0 xx -5) 
                           (+ (- y0 yy -5) (* i dyy))
                           (+ x0 xx -5)
                           (+ (- y0 yy -5) (* i dyy))
                           1
             )
             (if (and (<= i (* 0.5 zs2)) (= (nth 18 txt) "1")) 
               (progn 
                 (vector_image (+ x0 xx -5) 
                               (+ (- y0 yy -8) (* i dyy))
                               (+ x0 xx -10)
                               (+ (- y0 yy -13) (* i dyy))
                               6
                 )
                 (vector_image (+ x0 xx -8) 
                               (+ (- y0 yy -5) (* i dyy))
                               (+ x0 xx -13)
                               (+ (- y0 yy -10) (* i dyy))
                               6
                 )
               )
             )
             (setq i (1+ i))
           )
           (drawgj 7)
          )
        )
        (end_image)
      )
      (defun duplen (lj n m / d i l l1 l2 x) 
        (setq n  (1+ n)
              m  (1- m)
              i  1
              lj (/ lj n 1.0)
        )
        (if (and (> n 2) (> m 2)) 
          (progn 
            (while (< i n) 
              (setq l (cons (cons (/ i n 1.0) i) l)
                    i (1+ i)
              )
            )
            (setq i 1)
            (while (< i m) 
              (setq d  (/ i m 1.0)
                    l1 nil
              )
              (foreach x l 
                (if (not (assoc (abs (- (car x) d)) l1)) 
                  (setq l1 (cons (cons (abs (- (car x) d)) (cdr x)) l1))
                )
              )
              (setq d  (apply 'min (mapcar 'car l1))
                    l2 (cons (cdr (assoc d l1)) l2)
                    i  (1+ i)
              )
            )
            (setq n (length l2))
            (cond 
              ((= n 3) (setq l2 (reverse (cdr (reverse l2)))))
              ((= (rem n 2) 1) (setq l2 (@aditem l2 (/ n 2) nil)))
            )
            (setq i 0)
            (while l2 
              (setq n  (car l2)
                    m  (cadr l2)
                    i  (+ i (- n m))
                    l2 (cddr l2)
              )
            )
            (* lj 2 i)
          )
          0
        )
      )
      (defun addl (l0 l1 fl / gzjl gj kj cj jjz kan cha fan yuan fanz yuanz fanf 
                   yuanf pj pg fpg kx ky dis disk disc wkan wcha
                  ) 
        (start_list "kno" 3)
        (mapcar 'add_list l0)
        (end_list)
        (set_tile "kno" (nth 9 txt))
        (start_list "cno" 3)
        (mapcar 'add_list l1)
        (end_list)
        (set_tile "cno" (nth 11 txt))
        (setq kn    (atoi (nth (atoi (nth 9 txt)) l0))
              cn    (atoi (nth (atoi (nth 11 txt)) l1))
              widno kn
              lonno cn
              gzjl  (list "6" "8" "10" "12" "14" "16" "18" "20" "22" "25" "28" "32" 
                          "36" "40"
                    )
              jzj   (nth 8 txt)
              kzj   (nth 10 txt)
              czj   (nth 12 txt)
              gzj   (nth 14 txt)
              gjzhj (nth (atoi gzj) gzjl)
              xzhbj (nth (atoi kzj) gzjl)
              yzhbj (nth (atoi czj) gzjl)
              jjzhj (nth (atoi jzj) gzjl)
              gj    (* 0.5 (atoi gjzhj))
              kj    (* 0.5 (atoi xzhbj))
              cj    (* 0.5 (atoi yzhbj))
              jjz   (* 0.5 (atoi jjzhj))
              wkan  (atoi (nth 1 txt))
              wcha  (atoi (nth 2 txt))
              kan   (- wkan hou hou gj gj)
              cha   (- wcha hou hou gj gj)
              fan   (/ (* 200 pi gj gj (+ kan cha)) (* kan cha jj))
              fanf  (/ (* 200 pi gj gj (+ kan cha)) (* kan cha fjj))
              yuan  (/ (* 400 pi gj gj) (* kan jj))
              yuanf (/ (* 400 pi gj gj) (* kan fjj))
              fanz  (/ 
                      (* 200 pi (+ (* 2 jjz jjz) (* kn kj kj) (* cn cj cj)))
                      (* wkan wcha)
                    )
              yuanz (/ (* 400 jjz jjz kn) (* wkan wkan))
        )
        (cond 
          ((= fl "0")
           (setq pj  yuanz
                 pg  yuan
                 fpg yuanf
                 dis (- (/ (* pi (- kan gj gj gj gj jjz jjz)) kn) jjz jjz)
           )
          )
          ((= fl "1")
           (setq pj  yuanz
                 dis (- (/ (* pi (- kan gj gj gj gj jjz jjz)) kn) jjz jjz)
           )
           (cond 
             ((= kn 8)
              (setq angl (list 15. 75. 105. 165. 195. 255. 285. 345.)
                    a    66.
              )
             )
             ((= kn 12)
              (setq angl (list 15. 45. 75. 105. 135. 165. 195. 225. 255. 285. 315. 
                               345.
                         )
                    a    74.
              )
             )
             ((= kn 16)
              (setq angl (list 0. 15. 45. 75. 90. 105. 135. 165. 180. 195. 225. 255. 
                               270. 285. 315. 345.
                         )
                    a    66.
              )
             )
             ((= kn 20)
              (setq angl (list 0. 15. 36.6 53.3 75. 90. 105. 126.6 143.3 165. 180. 
                               195. 216.7 233.3 255. 270. 285. 306.7 323.3 345.
                         )
                    a    70.
              )
             )
             ((= kn 24)
              (setq angl (list 13.3 15. 36.6 53.3 75. 83.3 96.7 105. 126.6 143.3 165. 
                               173.3 186.7 195. 216.7 233.3 255. 263.3 276.7 285. 306.7 
                               323.3 345. 353.3
                         )
                    a    66.
              )
             )
             ((= kn 28)
              (setq angl (list 13.3 15. 32.5 45. 57.5 75. 83.3 96.7 105. 122.5 135. 
                               147.5 165. 173.3 186.7 195. 212.5 225. 237.5 255. 263.3 
                               276.7 285. 302.5 315. 327.5 345. 353.3
                         )
                    a    69.
              )
             )
             ((= kn 32)
              (setq angl (list 13.3 15. 30. 40. 50. 60. 75. 83.3 96.7 105. 120. 130. 
                               140. 150. 165. 173.3 186.7 195. 210. 220. 230. 240. 255. 
                               263.3 276.7 285. 300. 310. 320. 330. 345. 353.3
                         )
                    a    66.
              )
             )
           )
           (setq pg  (+ yuan (/ (* 1600 gj gj (sin (* (/ a 180) pi))) (* kan jj)))
                 fpg (+ yuanf 
                        (/ (* 1600 gj gj (sin (* (/ a 180) pi))) (* kan fjj))
                     )
           )
          )
          ((= fl "2")
           (setq pj   fanz
                 pg   fan
                 fpg  fanf
                 disk (- (/ (- kan gj gj) (1+ kn)) kj kj)
                 disc (- (/ (- cha gj gj) (1+ cn)) cj cj)
                 dis  (min disk disc)
           )
          )
          ((= fl "3")
           (setq pj   fanz
                 pg   (+ fan (/ (* (sqrt 2) fan) 2))
                 fpg  (+ fanf (/ (* (sqrt 2) fanf) 2))
                 disk (- (/ (- kan gj gj) (1+ kn)) kj kj)
                 disc (- (/ (- cha gj gj) (1+ cn)) cj cj)
                 dis  (min disk disc)
           )
          )
          ((= fl "4")
           (setq pj   fanz
                 kx   (/ kan (1+ kn) 1.0)
                 ky   (/ cha (1+ cn) 1.0)
                 kx   (* kx (fix (/ (+ 2 kn) 3)))
                 ky   (* ky (fix (/ (+ 2 cn) 3)))
                 dis  (if (= (nth 29 txt) "1") 
                        (+ (* 2 (- kan kx kx)) (* 2 (- cha ky ky)))
                        0
                      )
                 pg   (+ fan 
                         (/ 
                           (* 100 
                              pi
                              gj
                              gj
                              (+ (* 4 (sqrt (+ (* kx kx) (* ky ky)))) dis)
                           )
                           (* kan cha jj)
                         )
                      )
                 fpg  (+ fanf 
                         (/ 
                           (* 100 
                              pi
                              gj
                              gj
                              (+ (* 4 (sqrt (+ (* kx kx) (* ky ky)))) dis)
                           )
                           (* kan cha fjj)
                         )
                      )
                 disk (- (/ (- kan gj gj) (1+ kn)) kj kj)
                 disc (- (/ (- cha gj gj) (1+ cn)) cj cj)
                 dis  (min disk disc)
           )
          )
          ((= fl "5")
           (setq pj   fanz
                 kx   (* 0.5 kan)
                 ky   (/ cha (1+ cn) 1.0)
                 ky   (* ky (fix (/ (+ 2 cn) 3)))
                 dis  (if (= (nth 29 txt) "1") (* 2 (- cha ky ky)) 0)
                 pg   (+ fan 
                         (/ 
                           (* 100 
                              pi
                              gj
                              gj
                              (+ (* 4 (sqrt (+ (* kx kx) (* ky ky)))) dis)
                           )
                           (* kan cha jj)
                         )
                      )
                 fpg  (+ fanf 
                         (/ 
                           (* 100 
                              pi
                              gj
                              gj
                              (+ (* 4 (sqrt (+ (* kx kx) (* ky ky)))) dis)
                           )
                           (* kan cha fjj)
                         )
                      )
                 disk (- (/ (- kan gj gj) (1+ kn)) kj kj)
                 disc (- (/ (- cha gj gj) (1+ cn)) cj cj)
                 dis  (min disk disc)
           )
          )
          ((= fl "6")
           (setq pj   fanz
                 kx   (/ kan (1+ kn) 1.0)
                 kx   (* kx (fix (/ (+ 2 kn) 3)))
                 ky   (* 0.5 cha)
                 dis  (if (= (nth 29 txt) "1") (* 2 (- kan kx kx)) 0)
                 pg   (+ fan 
                         (/ 
                           (* 400 
                              pi
                              gj
                              gj
                              (+ (* 4 (sqrt (+ (* kx kx) (* ky ky)))) dis)
                           )
                           (* kan cha jj)
                         )
                      )
                 fpg  (+ fanf 
                         (/ 
                           (* 400 
                              pi
                              gj
                              gj
                              (+ (* 4 (sqrt (+ (* kx kx) (* ky ky)))) dis)
                           )
                           (* kan cha fjj)
                         )
                      )
                 disk (- (/ (- kan gj gj) (1+ kn)) kj kj)
                 disc (- (/ (- cha gj gj) (1+ cn)) cj cj)
                 dis  (min disk disc)
           )
          )
          ((= fl "7")
           (setq pj   fanz
                 dis  (if (= (nth 29 txt) "1") 
                        (+ (duplen kan kn zs1) (duplen cha cn zs2))
                        0
                      )
                 pg   (+ fan 
                         (/ 
                           (* 100 
                              pi
                              gj
                              gj
                              (+ (* (- zs2 2) kan) (* (- zs1 2) cha) dis)
                           )
                           (* kan cha jj)
                         )
                      )
                 fpg  (+ fanf 
                         (/ 
                           (* 100 
                              pi
                              gj
                              gj
                              (+ (* (- zs2 2) kan) (* (- zs1 2) cha) dis)
                           )
                           (* kan cha fjj)
                         )
                      )
                 disk (- (/ (- kan gj gj) (1+ kn)) kj kj)
                 disc (- (/ (- cha gj gj) (1+ cn)) cj cj)
                 dis  (min disk disc)
           )
          )
        )
        (setq pj  (rtos (+ pj 0.0005) 2 3)
              pg  (rtos (+ pg 0.0005) 2 3)
              fpg (rtos (+ fpg 0.0005) 2 3)
        )
        (set_tile "error" 
                  (strcat "柱纵筋配筋率为:" pj "%  加密区配箍率为:" pg "%  非加密区配箍率为:" fpg "%")
        )
        dis
      )
      (defun back (/ no) 
        (setq no  (car txt)
              txt (cdr oldtxt)
              txt (cons no txt)
        )
        (mapcar 'set '(wid lon jj fjj hou bl) (cdr txt))
        (setq wid (atoi wid)
              lon (atoi lon)
              jj  (atoi jj)
              fjj (atoi fjj)
              hou (atoi hou)
              bl  (atoi bl)
              zs1 (atoi (nth 19 txt))
              zs2 (atoi (nth 20 txt))
              px  (atoi (nth 21 txt))
              py  (atoi (nth 22 txt))
        )
        (mapcar 'set_tile 
                (list "wid" "lon" "jj" "fjj" "hou" "bl" "zdj" "jzj" "kno" "kzj" "cno" 
                      "czj" "gdj" "gzj" "dim" "zb" "pj" "jg" "zs1" "zs2" "px" "py" "labx" 
                      "laby" "bho" "rot" "xz" "bh"
                )
                (cdr txt)
        )
      )
      (setq oldtxt  txt
            tempzs1 (atoi (get_tile "kno"))
            tempzs2 (atoi (get_tile "cno"))
      )
      (cond 
        ((= fl 4)
         (setq txt (@subst txt 9 (get_tile "kno"))
               txt (@subst txt 11 (get_tile "cno"))
         )
         (if (> (- zs1 2) tempzs1) 
           (progn (setq zs1 (+ 2 tempzs1)) (set_tile "zs1" (itoa (+ 2 tempzs1))))
         )
         (if (> (- zs2 2) tempzs2) 
           (progn (setq zs2 (+ 2 tempzs2)) (set_tile "zs2" (itoa (+ 2 tempzs2))))
         )
        )
        ((= fl 6)
         (setq no  (car txt)
               txt (cdr txt)
         )
         (if (> (atoi no) 0) 
           (setq no  (itoa (1- (atoi no)))
                 txt (cons no txt)
                 txt (@subst txt 9 "0")
                 txt (@subst txt 11 "0")
           )
         )
         (set_tile "kzj" "6")
         (set_tile "czj" "6")
        )
        ((= fl 7)
         (setq no  (car txt)
               txt (cdr txt)
         )
         (if (< (atoi no) 7) 
           (setq no  (itoa (1+ (atoi no)))
                 txt (cons no txt)
                 txt (@subst txt 9 (if (= (atoi no) 7) "4" "0"))
                 txt (@subst txt 11 (if (= (atoi no) 7) "4" "0"))
           )
         )
         (set_tile "kzj" "6")
         (set_tile "czj" "6")
         (if (= no "7") 
           (progn (set_tile "zs1" "4") 
                  (set_tile "zs2" "4")
                  (setq zs1 4
                        zs2 4
                  )
           )
         )
        )
        ((= fl 8) (selsld) (set_tile "kzj" "6") (set_tile "czj" "6"))
      )
      (chatxt)
      (cond 
        ((= (car txt) "0")
         (setq tx1 "柱直径:"
               tx2 "圆周配筋数:"
               l0  yzj0
               l1  l0
               l   (list 1 1 1 1 1 1 0 1 1 1)
         )
        )
        ((= (car txt) "1")
         (setq tx1 "柱直径:"
               tx2 "圆周配筋数:"
               l0  yzj1
               l1  l0
               l   (list 1 1 1 1 1 0 0 1 1 1)
         )
        )
        ((= (car txt) "2")
         (setq tx1 "截面宽:"
               tx2 "X 向中部筋:"
               l0  zj
               l1  l0
               l   (list 0 0 0 0 0 0 0 1 1 0)
         )
        )
        ((= (car txt) "3")
         (setq tx1 "截面宽:"
               tx2 "X 向中部筋:"
               l0  zj1
               l1  l0
               l   (list 0 0 0 0 0 0 0 1 1 0)
         )
        )
        ((= (car txt) "4")
         (setq tx1 "截面宽:"
               tx2 "X 向中部筋:"
               l0  zj2
               l1  l0
               l   (list 0 0 0 0 0 0 0 1 1 0)
         )
        )
        ((= (car txt) "5")
         (setq tx1 "截面宽:"
               tx2 "X 向中部筋:"
               l0  zj1
               l1  zj2
               l   (list 0 0 0 0 0 0 0 1 1 0)
         )
        )
        ((= (car txt) "6")
         (setq tx1 "截面宽:"
               tx2 "X 向中部筋:"
               l0  zj2
               l1  zj1
               l   (list 0 0 0 0 0 0 0 1 1 0)
         )
        )
        ((= (car txt) "7")
         (setq tx1 "截面宽:"
               tx2 "X 向中部筋:"
               l0  zj
               l1  l0
               l   (list 0 0 0 0 0 0 1 0 0 0)
         )
        )
      )
      (set_tile "txt" tx1)
      (set_tile "tx" tx2)
      (mapcar 'mode_tile 
              (list "lon" "lons" "kzj" "cno" "czj" "per" "end" "zs1" "zs2" "rot")
              l
      )
      (setq dis (addl l0 l1 (car txt)))
      (if (< dis 50) (progn (back) (alert "纵筋净距离小于50毫米!") (addl l0 l1 (car txt))))
      (drawyxzh)
    )
    (if (= (length txt) 28) (setq txt (append txt (list "KZ1"))))
    (if (= (length txt) 29) (setq txt (append txt (list "0"))))
    (mapcar 'set '(wid lon jj fjj hou bl) (cdr txt))
    (setq what  2
          dia   (lib::dcl "Column")
          wid   (atoi wid)
          lon   (atoi lon)
          jj    (atoi jj)
          fjj   (atoi fjj)
          hou   (atoi hou)
          bl    (atoi bl)
          zs1   (atoi (nth 19 txt))
          zs2   (atoi (nth 20 txt))
          widno 2
          lonno 2
          px    (atoi (nth 21 txt))
          py    (atoi (nth 22 txt))
          rot   (atoi (nth 26 txt))
          yzj0  (list "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" 
                      "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30"
                )
          yzj1  (list "8" "12" "16" "20" "24" "28" "32")
          zj    (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" 
                      "14" "15" "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" 
                      "28" "29" "30"
                )
          zj1   (list "1" "3" "5" "7" "9" "11" "13" "15" "17" "19" "21" "23" "25" 
                      "27" "29" "31"
                )
          zj2   (list "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" 
                      "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" 
                      "30"
                )
    )
    (while (> what 0) 
      (if (not (new_dialog "Fhgjzh" dia)) (exit))
      (mapcar 'set_tile (list "jmg" "yxbj") (list "截面高:" "Y 向中部筋:"))
      (mapcar 'set_tile 
              (list "wid" "lon" "jj" "fjj" "hou" "bl" "zdj" "jzj" "kno" "kzj" "cno" 
                    "czj" "gdj" "gzj" "dim" "zb" "pj" "jg" "zs1" "zs2" "px" "py" "labx" 
                    "laby" "bho" "rot" "xz" "bh" "td"
              )
              (cdr txt)
      )
      (if (= (nth 23 txt) "nolabel") (set_tile "labx" ""))
      (if (= (nth 24 txt) "nolabel") (set_tile "laby" ""))
      (slide 0)
      (action_tile "wid" "(isnum 0 nil)(slide 0)")
      (action_tile "lon" "(isnum 0 nil)(slide 0)")
      (action_tile "rot" "(isnum 0.0 360)(slide 0)")
      (action_tile "jj" "(isnum 50. nil)(slide 3)")
      (action_tile "fjj" "(isnum 0 nil)(slide 3)")
      (action_tile "hou" "(isnum 0 nil)(slide 3)")
      (action_tile "zs1" "(isnum 2. (+ 2 (* 1.0 widno)))(slide 3)")
      (action_tile "zs2" "(isnum 2. (+ 2 (* 1.0 lonno)))(slide 3)")
      (action_tile "bl" "(isnum 0 nil)")
      (action_tile "px" "(isnum nil nil)(slide 3)")
      (action_tile "py" "(isnum nil nil)(slide 3)")
      (action_tile "jzj" "(slide 3)")
      (action_tile "kzj" "(slide 3)")
      (action_tile "czj" "(slide 3)")
      (action_tile "gzj" "(slide 3)")
      (action_tile "jg" "(slide 3)")
      (action_tile "kno" "(slide 4)")
      (action_tile "cno" "(slide 4)")
      (action_tile "per" "(slide 6)")
      (action_tile "end" "(slide 7)")
      (action_tile "sel" "(slide 8)")
      (action_tile "xz" "(chatxt)")
      (action_tile "zdj" "(chatxt)")
      (action_tile "gdj" "(chatxt)")
      (action_tile "r335" "(chatxt)")
      (action_tile "r400" "(chatxt)")
      (action_tile "r235" "(chatxt)")
      (action_tile "r35" "(chatxt)")
      (action_tile "dim" "(chatxt)")
      (action_tile "zb" "(chatxt)")
      (action_tile "pj" "(chatxt)")
      (action_tile "bho" "(chatxt)")
      (action_tile "bh" "(chatxt)")
      (action_tile "td" "(slide 0)")
      (action_tile "labx" "(chatxt)")
      (action_tile "laby" "(chatxt)")
      (action_tile "sigl" "(#ret -8)")
      (action_tile "mult" "(#ret -18)")
      (action_tile "cancel" "(setq what -28)(done_dialog 3)")
      (action_tile "help" "(help \"Tssd\" \"Fhgjzh\")")
      (start_dialog)
    )
    (unload_dialog dia)
    (list what txt)
  )
  (if (< (&UTXT) 0) (exit))
  (setq txt (&GPTS "Tssd/Dcl_Hzh/Fhgjzh"))
  (if (or (= txt nil) (wcmatch txt "")) 
    (setq txt (list "2" "500" "500" "100" "200" "20" "20" "1" "6" "0" "6" "0" "6" "0" 
                    "1" "1" "1" "1" "1" "4" "4" "0" "0" "1" "A" "1" "0" "1" "KZ1" "0"
              )
    )
    (setq txt (&PLCN txt "\t"))
  )
  (draw (chs_dcl txt))
  (&TSTY)
)
(setfunhelp "c:Chzhm" "Tssd" "Chzhm")
(defun c:Chzhm (/ draw chs_dcl txt) 
  (defun draw (fl / emk diml labe drawzhm wid lon pt p1 p2 p3 p4 dim_pt en enl ang ss 
               en1 flag an1 an2 len en1l fl pl ptl
              ) 
    (defun emk (lay /) 
      (entmake 
        (list (cons 0 "Lwpolyline") 
              (cons 100 "AcDbEntity")
              (cons 67 0)
              (cons 8 lay)
              (cons 100 "AcDbPolyline")
              (cons 90 4)
              (cons 70 1)
              (cons 43 0)
              (cons 10 (@wcs p1))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p2))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p3))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p4))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
        )
      )
    )
    (defun diml (/ px py) 
      (setq px (&N2S p3 p4)
            py (&N2S p1 p4)
      )
      (&GVAL)
      (&LJIG "平面柱帽尺寸" T)
      (command ".dimaligned" p3 px (polar (&N2S p3 px) (angle p1 p4) (* 10 &sp)))
      (command ".dimaligned" px p4 (polar (&N2S px p4) (angle p1 p4) (* 10 &sp)))
      (command ".dimaligned" p1 py (polar (&N2S p1 py) (angle p2 p1) (* 10 &sp)))
      (command ".dimaligned" py p4 (polar (&N2S py p4) (angle p2 p1) (* 10 &sp)))
    )
    (defun labe (/ delb dele dis p0 pt zg gk lay) 
      (defun delb (str / ch i len) 
        (setq len (strlen str)
              i   1
        )
        (while (<= i len) 
          (setq ch (@substr str i 1)
                i  (if Tsz_If_Unicode (+ 2 i) (1+ i))
          )
          (if (/= ch " ") 
            (setq str (@substr str (1- i) len)
                  i   (1+ len)
            )
          )
        )
        str
      )
      (defun dele (str / ch len) 
        (setq len (strlen str))
        (while (> len 0) 
          (setq ch  (@substr str len 1)
                len (if Tsz_If_Unicode (- len 2) (1- len))
          )
          (if (= ch " ") (setq str (@substr str 1 len)) (setq len 0))
        )
        str
      )
      (setq lab (last txt)
            lab (delb lab)
            lab (dele lab)
      )
      (if (/= lab "") 
        (progn 
          (setq dis (* 0.25 (distance p1 p3))
                p0  (polar p1 (angle p1 p3) dis)
                dis (distance p0 (inters p1 p2 p0 (polar p0 _pi2 1000) nil))
                dis (+ dis (* 5 &sp))
                pt  (polar p0 _pi2 dis)
                zg  (&INTS "标号文字" 1)
                gk  (cadr zg)
                zg  (car zg)
          )
          (setq lay (&LJIG "平面柱帽编号" T))
          (@text lab (polar pt (* 0.25 pi) (* 0.5 zg)) lay zg 0 "" gk)
          (setq dis (textbox (entget (entlast)))
                dis (+ (* 0.6 zg) (- (caadr dis) (caar dis)))
          )
          (@linel (list p0 pt (polar pt 0 dis)) lay)
        )
      )
    )
    (defun drawzhm (ang pt / p1 p2 p3 p4) 
      (while (> ang _pi2) (setq ang (- ang _pi2)))
      (if (equal ang _pi2 0.01) (setq ang 0))
      (setq p1 (polar (polar pt ang wid) (+ _pi2 ang) lon)
            p2 (polar p1 (- ang pi) (+ wid wid))
            p3 (polar p2 (- ang _pi2) (+ lon lon))
            p4 (polar p3 ang (+ wid wid))
      )
      (emk (&LJIG "平面柱帽虚线" T))
      (if (= (cadddr txt) "1") 
        (if dim_pt 
          (if (< (+ (car pt) (cadr pt)) (+ (car dim_pt) (cadr dim_pt))) 
            (setq dim_pt pt
                  ptl    (list p1 p2 p3 p4)
            )
          )
          (setq dim_pt pt
                ptl    (list p1 p2 p3 p4)
          )
        )
        (if (= (nth 4 txt) "1") (diml))
      )
      (if (= (nth 5 txt) "1") (labe))
    )
    (defun per (pl / pt flag) 
      (setq pt (&N2S (car pl) (caddr pl)))
      (if 
        (and (equal (distance pt (car pl)) (distance pt (cadr pl)) (* 0.01 &sp)) 
             (equal (distance pt (car pl)) (distance pt (caddr pl)) (* 0.01 &sp))
             (equal (distance pt (car pl)) (distance pt (cadddr pl)) (* 0.01 &sp))
        )
        (setq flag T)
        (setq flag nil)
      )
      flag
    )
    (setq wid (* 0.5 &sc (atof (car txt)))
          lon (* 0.5 &sc (atof (cadr txt)))
    )
    (cond 
      ((= fl -8)
       (while (setq pt (&OSNP "\n点取插入柱帽的中心点<退出>: ")) 
         (setq p1 (polar (polar pt 0 wid) _pi2 lon)
               p2 (polar p1 pi (+ wid wid))
               p3 (polar p2 (* 1.5 pi) (+ lon lon))
               p4 (polar p3 0 (+ wid wid))
         )
         (emk (&LJIG "平面柱帽虚线" T))
         (if (= (nth 4 txt) "1") (diml))
         (if (= (nth 5 txt) "1") (labe))
       )
      )
      ((= fl -18)
       (while 
         (and (setq p1 (&OSNP "\n点取柱帽插入区域第一角点<退出>: ")) 
              (setq p2 (&OSNP p1 "\n点取柱帽插入区域第二角点<退出>: " t))
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面柱帽虚线,平面柱帽编号,平面柱帽尺寸")))
                    )
           )
           (ss::del ss)
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面轴线")) '(0 . "line,arc,circle"))
                    )
           )
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq len  (sslength ss)
                   enl  (entget en)
                   flag (strcase (cdr (assoc 0 enl)))
             )
             (while (> len 0) 
               (setq len  (1- len)
                     en1  (ssname ss len)
                     en1l (entget en1)
                     fla  (strcase (cdr (assoc 0 en1l)))
               )
               (cond 
                 ((and (wcmatch flag "LINE") (wcmatch fla "LINE"))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= (caddr txt) "1") 
                      (progn 
                        (setq an1 (angle (&DRAG en 10) (&DRAG en 11))
                              an2 (angle (&DRAG en1 10) (&DRAG en1 11))
                              pl  (cdr pl)
                        )
                        (if (> an1 pi) (setq an1 (- an1 pi)))
                        (if (> an2 pi) (setq an2 (- an2 pi)))
                        (if (< (abs (- an1 _pi2)) (abs (- an2 _pi2))) 
                          (setq ang an2)
                          (setq ang an1)
                        )
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (drawzhm ang pt)
                  )
                 )
                 ((and (wcmatch flag "LINE") (not (wcmatch fla "LINE")))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= (caddr txt) "1") 
                      (progn 
                        (setq ang (angle (&DRAG en 10) (&DRAG en 11))
                              pl  (cdr pl)
                        )
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (drawzhm ang pt)
                  )
                 )
                 ((and (not (wcmatch flag "LINE")) (wcmatch fla "LINE"))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= (caddr txt) "1") 
                      (progn 
                        (setq ang (angle (&DRAG en1 10) (&DRAG en1 11))
                              pl  (cdr pl)
                        )
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (drawzhm ang pt)
                  )
                 )
                 ((and (not (wcmatch flag "LINE")) (not (wcmatch fla "LINE")))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) (setq pl (cdr pl)) (drawzhm 0 pt))
                 )
               )
             )
           )
         )
         (if dim_pt 
           (setq p1 (car ptl)
                 p2 (cadr ptl)
                 p3 (caddr ptl)
                 p4 (cadddr ptl)
                 pt (diml)
           )
         )
         (setq dim_pt nil
               ptl    nil
         )
       )
      )
      ((= fl -28)
       (while 
         (and (setq p1 (&OSNP "\n点取柱帽插入区域第一角点<退出>: ")) 
              (setq p2 (&OSNP p1 "\n点取柱帽插入区域第二角点<退出>: " t))
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线")) 
                                 '(0 . "LWPOLYLINE")
                           )
                    )
           )
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq enl (entget en)
                   pt  (&MGRP en)
                   pl  (&DRAG en 10)
             )
             (if (and (= (length pl) 4) (per pl)) 
               (drawzhm (angle (car pl) (cadr pl)) pt)
               (if 
                 (and (= (length pl) 2) 
                      (or (equal (&DRAG en 42) '(1 1)) 
                          (equal (&DRAG en 42) '(-1 -1))
                      )
                 )
                 (drawzhm 0 pt)
               )
             )
           )
         )
         (if dim_pt 
           (setq p1 (car ptl)
                 p2 (cadr ptl)
                 p3 (caddr ptl)
                 p4 (cadddr ptl)
                 pt (diml)
           )
         )
         (setq dim_pt nil
               ptl    nil
         )
       )
      )
    )
  )
  (defun chs_dcl (tx / slide what dia) 
    (defun slide (flag / wid lon w0 h0 x0 y0 isc lp xx yy) 
      (if (= (get_tile "dim") "1") 
        (mode_tile "first" 0)
        (progn (mode_tile "first" 1) (set_tile "first" "0"))
      )
      (if (= flag 0) 
        (progn 
          (setq wid (atoi (get_tile "wid"))
                lon (atoi (get_tile "lon"))
          )
          (setq w0  (dimx_tile "img")
                x0  (/ w0 2)
                h0  (dimy_tile "img")
                y0  (/ h0 2)
                isc (/ y0 3000.)
          )
          (setq lp  (/ w0 (max wid lon) 1.)
                isc (min isc lp)
                xx  (fix (* 0.5 wid isc))
                yy  (fix (* 0.5 lon isc))
          )
          (start_image "img")
          (fill_image 0 0 w0 h0 -2)
          (vector_image x0 0 x0 h0 253)
          (vector_image 0 y0 w0 y0 253)
          (vector_image (- x0 10) (- y0 10) (+ x0 10) (+ y0 10) 1)
          (vector_image (- x0 10) (+ y0 10) (+ x0 10) (- y0 10) 1)
          (vector_image (- x0 xx) (- y0 yy) (+ x0 xx) (- y0 yy) 2)
          (vector_image (- x0 xx) (- y0 yy) (- x0 xx) (+ y0 yy) 2)
          (vector_image (+ x0 xx) (- y0 yy) (+ x0 xx) (+ y0 yy) 2)
          (vector_image (- x0 xx) (+ y0 yy) (+ x0 xx) (+ y0 yy) 2)
          (end_image)
        )
      )
      (if (= "1" (get_tile "no")) (mode_tile "lab" 0) (mode_tile "lab" 1))
      (setq txt (list (get_tile "wid") 
                      (get_tile "lon")
                      (get_tile "rote")
                      (get_tile "first")
                      (get_tile "dim")
                      (get_tile "no")
                      (get_tile "lab")
                )
      )
      (if (= flag 2) 
        (&GLAY 
          "Tssd/Dcl_Hzh/Chzhm"
          (strcat (get_tile "wid") 
                  "\t"
                  (get_tile "lon")
                  "\t"
                  (get_tile "rote")
                  "\t"
                  (get_tile "first")
                  "\t"
                  (get_tile "dim")
                  "\t"
                  (get_tile "no")
                  "\t"
                  (get_tile "lab")
          )
        )
      )
      (list what txt)
    )
    (setq what 2
          dia  (lib::dcl "Column")
    )
    (while (> what 0) 
      (if (not (new_dialog "Chzhm" dia)) (exit))
      (mapcar 'set_tile (list "wid" "lon" "rote" "first" "dim" "no" "lab") txt)
      (slide 0)
      (action_tile "wid" "(#isnum 0 nil)(slide 0)")
      (action_tile "lon" "(#isnum 0 nil)(slide 0)")
      (action_tile "rote" "(slide 1)")
      (action_tile "dim" "(slide 1)")
      (action_tile "no" "(slide 1)")
      (action_tile "lab" "(slide 1)")
      (action_tile "sigl" "(slide 2)(setq what -8)(done_dialog 1)")
      (action_tile "mult" "(slide 2)(setq what -18)(done_dialog 2)")
      (action_tile "zhux" "(slide 2)(setq what -28)(done_dialog 2)")
      (action_tile "cancel" "(setq what -38)(done_dialog 3)")
      (action_tile "help" "(help \"Tssd\" \"Chzhm\")")
      (start_dialog)
    )
    (unload_dialog dia)
    what
  )
  (if (< (&UTXT) 0) (exit))
  (setq txt (&GPTS "Tssd/Dcl_Hzh/Chzhm"))
  (if (or (= txt nil) (wcmatch txt "")) 
    (setq txt (list "2000" "2000" "1" "1" "1" "1" "ZHM1"))
    (setq txt (&PLCN txt "\t"))
  )
  (draw (chs_dcl txt))
  (&TSTY)
)
(setfunhelp "c:Bdlzhj" "Tssd" "Bdlzhj")
(Defun c:Bdlzhj (/ zhupy draw chs_dcl txt what wid lon hp zp zhj lab rote dim no 
                 first hpp zpp
                ) 
  (defun zhupy (ex ey er / dist a1 a2) 
    (setq ex   (* 1.0 ex)
          ey   (* 1.0 ey)
          dist (sqrt (+ (* ex ex) (* ey ey)))
    )
    (if (and (/= ex 0) (/= ey 0)) 
      (progn (setq a1 (* 180 (/ (atan (/ ey ex)) pi))) 
             (if (< ex 0) (setq a1 (+ a1 180)) (if (< ey 0) (setq a1 (+ a1 360))))
      )
      (if (and (= ex 0) (= ey 0)) 
        (setq a1 0.0)
        (if (= ex 0) 
          (if (> ey 0) (setq a1 90.0) (setq a1 -90.0))
          (if (> ex 0) (setq a1 0.0) (setq a1 180.0))
        )
      )
    )
    (setq a2 (+ er a1)
          a2 (* (/ a2 180.0) pi)
          ex (* dist (cos a2))
          ey (* dist (sin a2))
    )
    (list ex ey)
  )
  (defun draw (fl / emk p_l diml labe wi lo an an1 an2 an3 pt p0 p1 p2 p3 p4 fla flag 
               en en1 enl en1l ss ang ptl labt dim_pt lay
              ) 
    (defun emk (lay /) 
      (entmake 
        (list (cons 0 "Lwpolyline") 
              (cons 100 "AcDbEntity")
              (cons 67 0)
              (cons 8 lay)
              (cons 100 "AcDbPolyline")
              (cons 90 4)
              (cons 70 1)
              (cons 43 0)
              (cons 10 (@wcs p1))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p2))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p3))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
              (cons 10 (@wcs p4))
              (cons 40 0)
              (cons 41 0)
              (cons 42 0)
        )
      )
    )
    (defun p_l (/ epx epy mdxy dxy1 dxy2 dxy3 dxy4 p0) 
      (setq epx  (/ (+ (car p1) (car p2) (car p3) (car p4)) 4)
            epy  (/ (+ (cadr p1) (cadr p2) (cadr p3) (cadr p4)) 4)
            dxy1 (+ (- (car p1) epx) (- (cadr p1) epy))
            dxy2 (+ (- (car p2) epx) (- (cadr p2) epy))
            dxy3 (+ (- (car p3) epx) (- (cadr p3) epy))
            dxy4 (+ (- (car p4) epx) (- (cadr p4) epy))
            mdxy (max dxy1 dxy2 dxy3 dxy4)
      )
      (cond 
        ((= mdxy dxy2)
         (setq p0 p1
               p1 p2
               p2 p3
               p3 p4
               p4 p0
         )
        )
        ((= mdxy dxy3)
         (setq p0 p1
               p1 p3
               p3 p0
               p0 p2
               p2 p4
               p4 p0
         )
        )
        ((= mdxy dxy4)
         (setq p0 p4
               p4 p3
               p3 p2
               p2 p1
               p1 p0
         )
        )
      )
    )
    (defun diml (pp / px py) 
      (p_l)
      (setq px (inters pp (polar pp (angle p3 p4) 100) p1 p4 nil)
            py (inters pp (polar pp (angle p1 p4) 100) p3 p4 nil)
      )
      (&GVAL)
      (&LJIG "平面独立基础尺寸" T)
      (command ".dimaligned" p4 px (polar (&N2S p4 px) (angle p2 p1) (* 10 &sp)))
      (command ".dimaligned" px p1 (polar (&N2S px p1) (angle p2 p1) (* 10 &sp)))
      (command ".dimaligned" p3 py (polar (&N2S p3 py) (angle p1 p4) (* 10 &sp)))
      (command ".dimaligned" py p4 (polar (&N2S py p4) (angle p1 p4) (* 10 &sp)))
    )
    (defun labe (/ delb dele dis p0 pt zg gk) 
      (defun delb (str / ch i len) 
        (setq len (strlen str)
              i   1
        )
        (while (<= i len) 
          (setq ch (@substr str i 1)
                i  (if Tsz_If_Unicode (+ 2 i) (1+ i))
          )
          (if (/= ch " ") 
            (setq str (@substr str (1- i) len)
                  i   (1+ len)
            )
          )
        )
        str
      )
      (defun dele (str / ch len) 
        (setq len (strlen str))
        (while (> len 0) 
          (setq ch  (@substr str len 1)
                len (if Tsz_If_Unicode (- len 2) (1- len))
          )
          (if (= ch " ") (setq str (@substr str 1 len)) (setq len 0))
        )
        str
      )
      (setq lab (delb lab)
            lab (dele lab)
      )
      (if (/= lab "") 
        (progn (p_l) 
               (setq dis (* 0.25 (distance p1 p3))
                     p0  (polar p1 (angle p1 p3) dis)
                     dis (distance p0 (inters p1 p2 p0 (polar p0 _pi2 1000) nil))
                     dis (+ dis (* 5 &sp))
                     pt  (polar p0 _pi2 dis)
                     zg  (&INTS "标号文字" 1)
                     gk  (cadr zg)
                     zg  (car zg)
               )
               (@text 
                 lab
                 (polar pt (* 0.25 pi) (* 0.5 zg))
                 (&LJIG "平面独立基础编号" T)
                 zg
                 0
                 ""
                 gk
               )
               (setq dis (textbox (entget (entlast)))
                     dis (+ (* 0.6 zg) (- (caadr dis) (caar dis)))
               )
               (@linel (list p0 pt (polar pt 0 dis)) (&LJIG "平面独立基础文字" T))
        )
      )
    )
    (if (/= fl -38) 
      (progn (if (= lab "") (setq labt "J-1") (setq labt lab)) 
             (&GLAY 
               "Tssd40/Dcl_Hzh/Bdlzhj"
               (strcat (&RTXT wid) 
                       "\t"
                       (&RTXT lon)
                       "\t"
                       (&RTXT hp)
                       "\t"
                       (&RTXT zp)
                       "\t"
                       (&RTXT zhj)
                       "\t"
                       labt
                       "\t"
                       rote
                       "\t"
                       dim
                       "\t"
                       no
                       "\t"
                       first
               )
             )
             (setq wid (* wid &sc)
                   lon (* lon &sc)
                   wi  (* 0.5 wid)
                   lo  (* 0.5 lon)
                   zhj (/ (* zhj pi) 180)
                   an1 (+ zhj _pi2)
                   an2 (+ zhj pi)
                   an3 (+ an1 pi)
                   lay (&LJIG "平面独立基础" T)
             )
      )
    )
    (cond 
      ((= fl -8)
       (while (setq pt (&OSNP "\n点取插入基础的中心点<退出>: ")) 
         (setq hpp (zhupy hp zp (* 180 (/ zhj pi)))
               zpp (cadr hpp)
               hpp (car hpp)
               hpp (* hpp &sc)
               zpp (* zpp &sc)
         )
         (setq p0 (polar (polar pt 0 hpp) _pi2 zpp)
               p1 (polar (polar p0 zhj wi) an1 lo)
               p2 (polar p1 an2 wid)
               p3 (polar p2 an3 lon)
               p4 (polar p3 zhj wid)
         )
         (emk lay)
         (if (= dim "1") (diml pt))
         (if (= no "1") (labe))
       )
      )
      ((= fl -18)
       (while 
         (and (setq p1 (&OSNP "\n点取基础插入区域第一角点<退出>: ")) 
              (setq p2 (&OSNP p1 "\n点取基础插入区域第二角点<退出>: " t))
         )
         (if (setq ss (ssget "c" p1 p2 (list (cons 8 lay) (cons 0 "LWPOLYLINE")))) 
           (ss::del ss)
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面轴线")) '(0 . "line,arc,circle"))
                    )
           )
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq len  (sslength ss)
                   enl  (entget en)
                   flag (strcase (cdr (assoc 0 enl)))
             )
             (while (> len 0) 
               (setq len  (1- len)
                     en1  (ssname ss len)
                     en1l (entget en1)
                     fla  (strcase (cdr (assoc 0 en1l)))
               )
               (cond 
                 ((and (wcmatch flag "LINE") (wcmatch fla "LINE"))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= rote "1") 
                      (progn 
                        (setq an1 (angle (&DRAG en 10) (&DRAG en 11))
                              an2 (angle (&DRAG en1 10) (&DRAG en1 11))
                              pl  (cdr pl)
                        )
                        (if (> an1 pi) (setq an1 (- an1 pi)))
                        (if (> an2 pi) (setq an2 (- an2 pi)))
                        (if (< (abs (- an1 _pi2)) (abs (- an2 _pi2))) 
                          (setq ang an2
                                an  an1
                          )
                          (setq ang an1
                                an  an2
                          )
                        )
                      )
                      (setq ang 0
                            an  _pi2
                            pl  (cdr pl)
                      )
                    )
                    (setq ang (+ zhj ang)
                          an1 (+ ang _pi2)
                          an2 (+ ang pi)
                          an3 (+ an1 pi)
                          hp  (* hp &sc)
                          zp  (* zp &sc)
                          p0  (polar (polar pt ang hp) (+ _pi2 ang) zp)
                          p1  (polar (polar p0 ang wi) an1 lo)
                          p2  (polar p1 an2 wid)
                          p3  (polar p2 an3 lon)
                          p4  (polar p3 ang wid)
                    )
                    (emk lay)
                    (if (= first "1") 
                      (if dim_pt 
                        (if 
                          (< (+ (car (&N2S p1 p3)) (cadr (&N2S p1 p3))) 
                             (+ (car dim_pt) (cadr dim_pt))
                          )
                          (setq dim_pt (&N2S p1 p3)
                                ptl    (list p1 p2 p3 p4 pt)
                          )
                        )
                        (setq dim_pt (&N2S p1 p3)
                              ptl    (list p1 p2 p3 p4 pt)
                        )
                      )
                      (if (= dim "1") (diml pt))
                    )
                    (if (= no "1") (labe))
                  )
                 )
                 ((and (wcmatch flag "LINE") (not (wcmatch fla "LINE")))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= rote "1") 
                      (progn 
                        (setq ang (angle (&DRAG en 10) (&DRAG en 11))
                              pl  (cdr pl)
                        )
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (setq ang (+ zhj ang)
                          an1 (+ ang _pi2)
                          an2 (+ ang pi)
                          an3 (+ an1 pi)
                          hp  (* hp &sc)
                          zp  (* zp &sc)
                          p0  (polar (polar pt ang hp) (+ ang _pi2) zp)
                          p1  (polar (polar p0 ang wi) an1 lo)
                          p2  (polar p1 an2 wid)
                          p3  (polar p2 an3 lon)
                          p4  (polar p3 ang wid)
                    )
                    (emk lay)
                    (if (= first "1") 
                      (if dim_pt 
                        (if 
                          (< (+ (car (&N2S p1 p3)) (cadr (&N2S p1 p3))) 
                             (+ (car dim_pt) (cadr dim_pt))
                          )
                          (setq dim_pt (&N2S p1 p3)
                                ptl    (list p1 p2 p3 p4 pt)
                          )
                        )
                        (setq dim_pt (&N2S p1 p3)
                              ptl    (list p1 p2 p3 p4 pt)
                        )
                      )
                      (if (= dim "1") (diml pt))
                    )
                    (if (= no "1") (labe))
                  )
                 )
                 ((and (not (wcmatch flag "LINE")) (wcmatch fla "LINE"))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (if (= rote "1") 
                      (progn 
                        (setq ang (angle (&DRAG en1 10) (&DRAG en1 11))
                              pl  (cdr pl)
                        )
                      )
                      (setq ang 0
                            pl  (cdr pl)
                      )
                    )
                    (setq ang (+ zhj ang)
                          an1 (+ ang _pi2)
                          an2 (+ ang pi)
                          an3 (+ an1 pi)
                          hp  (* hp &sc)
                          zp  (* zp &sc)
                          p0  (polar (polar pt ang hp) (+ ang _pi2) zp)
                          p1  (polar (polar p0 ang wi) an1 lo)
                          p2  (polar p1 an2 wid)
                          p3  (polar p2 an3 lon)
                          p4  (polar p3 ang wid)
                    )
                    (emk lay)
                    (if (= first "1") 
                      (if dim_pt 
                        (if 
                          (< (+ (car (&N2S p1 p3)) (cadr (&N2S p1 p3))) 
                             (+ (car dim_pt) (cadr dim_pt))
                          )
                          (setq dim_pt (&N2S p1 p3)
                                ptl    (list p1 p2 p3 p4 pt)
                          )
                        )
                        (setq dim_pt (&N2S p1 p3)
                              ptl    (list p1 p2 p3 p4 pt)
                        )
                      )
                      (if (= dim "1") (diml pt))
                    )
                    (if (= no "1") (labe))
                  )
                 )
                 ((and (not (wcmatch flag "LINE")) (not (wcmatch fla "LINE")))
                  (setq pl (&ORDR en en1))
                  (while (setq pt (car pl)) 
                    (setq ang zhj
                          an1 (+ ang _pi2)
                          an2 (+ ang pi)
                          an3 (+ an1 pi)
                          pl  (cdr pl)
                          hp  (* hp &sc)
                          zp  (* zp &sc)
                          p0  (polar (polar pt 0 hp) _pi2 zp)
                          p1  (polar (polar p0 ang wi) an1 lo)
                          p2  (polar p1 an2 wid)
                          p3  (polar p2 an3 lon)
                          p4  (polar p3 ang wid)
                    )
                    (emk lay)
                    (if (= first "1") 
                      (if dim_pt 
                        (if 
                          (< (+ (car (&N2S p1 p3)) (cadr (&N2S p1 p3))) 
                             (+ (car dim_pt) (cadr dim_pt))
                          )
                          (setq dim_pt (&N2S p1 p3)
                                ptl    (list p1 p2 p3 p4 pt)
                          )
                        )
                        (setq dim_pt (&N2S p1 p3)
                              ptl    (list p1 p2 p3 p4 pt)
                        )
                      )
                      (if (= dim "1") (diml pt))
                    )
                    (if (= no "1") (labe))
                  )
                 )
               )
             )
           )
         )
         (if dim_pt 
           (setq p1 (car ptl)
                 p2 (cadr ptl)
                 p3 (caddr ptl)
                 p4 (cadddr ptl)
                 pt (diml (last ptl))
           )
         )
         (setq dim_pt nil
               ptl    nil
         )
       )
      )
      ((= fl -28)
       (while 
         (and (setq p1 (&OSNP "\n点取基础插入区域第一角点<退出>: ")) 
              (setq p2 (&OSNP p1 "\n点取基础插入区域第二角点<退出>: " t))
         )
         (if (setq ss (ssget "c" p1 p2 (list (cons 8 lay) (cons 0 "LWPOLYLINE")))) 
           (ss::del ss)
         )
         (if 
           (setq ss (ssget "c" 
                           p1
                           p2
                           (list (cons 8 (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线")) 
                                 '(0 . "LWPOLYLINE")
                           )
                    )
           )
           (while (setq en (ssname ss 0)) 
             (ssdel en ss)
             (setq enl (entget en)
                   pt  (&MGRP en)
                   pl  (&DRAG en 10)
             )
             (if (>= (length pl) 3) 
               (setq ang (+ zhj (angle (car pl) (cadr pl))))
               (setq ang zhj)
             )
             (if (> ang pi) (setq ang (- ang pi)))
             (setq an1 (+ ang _pi2)
                   an2 (+ ang pi)
                   an3 (+ an1 pi)
                   hpp (zhupy hp zp (* 180 (/ ang pi)))
                   zpp (cadr hpp)
                   hpp (car hpp)
                   hpp (* hpp &sc)
                   zpp (* zpp &sc)
                   p0  (polar (polar pt 0 hpp) _pi2 zpp)
                   p1  (polar (polar p0 ang wi) an1 lo)
                   p2  (polar p1 an2 wid)
                   p3  (polar p2 an3 lon)
                   p4  (polar p3 ang wid)
             )
             (emk lay)
             (if (= first "1") 
               (if dim_pt 
                 (if 
                   (< (+ (car (&N2S p1 p3)) (cadr (&N2S p1 p3))) 
                      (+ (car dim_pt) (cadr dim_pt))
                   )
                   (setq dim_pt (&N2S p1 p3)
                         ptl    (list p1 p2 p3 p4 pt)
                   )
                 )
                 (setq dim_pt (&N2S p1 p3)
                       ptl    (list p1 p2 p3 p4 pt)
                 )
               )
               (if (= dim "1") (diml pt))
             )
             (if (= no "1") (labe))
           )
         )
         (if dim_pt 
           (setq p1 (car ptl)
                 p2 (cadr ptl)
                 p3 (caddr ptl)
                 p4 (cadddr ptl)
                 pt (diml (last ptl))
           )
         )
         (setq dim_pt nil
               ptl    nil
         )
       )
      )
    )
  )
  (defun chs_dcl (tx / slide what dia) 
    (defun slide (fl / w0 x0 h0 y0 isc xc yc xx yy xy hpp zpp) 
      (if (= fl 6) 
        (progn (if (and (= $key "first") (= $value "1")) (set_tile "dim" "0")) 
               (if (and (= $key "dim") (= $value "1")) (set_tile "first" "0"))
               (setq no   (get_tile "no")
                     rote (get_tile "rote")
                     dim  (get_tile "dim")
               )
               (if (= no "1") (mode_tile "lab" 0) (mode_tile "lab" 1))
        )
      )
      (if (= fl 0) 
        (mapcar 'set_tile 
                (list "wids" "lons" "hps" "zps" "zhjs")
                (list (get_tile "wid") 
                      (get_tile "lon")
                      (get_tile "hp")
                      (get_tile "zp")
                      (get_tile "zhj")
                )
        )
        (mapcar 'set_tile 
                (list "wid" "lon" "hp" "zp" "zhj")
                (list (if (= fl 1) (get_tile "wids") (get_tile "wid")) 
                      (if (= fl 2) (get_tile "lons") (get_tile "lon"))
                      (if (= fl 3) (get_tile "hps") (get_tile "hp"))
                      (if (= fl 4) (get_tile "zps") (get_tile "zp"))
                      (if (= fl 5) (get_tile "zhjs") (get_tile "zhj"))
                )
        )
      )
      (setq wid   (atoi (get_tile "wid"))
            lon   (atoi (get_tile "lon"))
            hp    (atoi (get_tile "hp"))
            zp    (atoi (get_tile "zp"))
            zhj   (atoi (get_tile "zhj"))
            lab   (get_tile "lab")
            first (get_tile "first")
            txt   (list (get_tile "wid") 
                        (get_tile "lon")
                        (get_tile "hp")
                        (get_tile "zp")
                        (get_tile "zhj")
                        lab
                        rote
                        dim
                        no
                        first
                  )
      )
      (setq w0  (dimx_tile "img")
            x0  (/ w0 2)
            h0  (dimy_tile "img")
            y0  (/ h0 2)
            isc (/ y0 5000.)
      )
      (setq lp  (/ w0 (max wid lon) 1.)
            isc (min isc lp)
            hpp (zhupy hp zp zhj)
            zpp (cadr hpp)
            hpp (car hpp)
            xc  (+ x0 (fix (* hpp isc)))
            yc  (- y0 (fix (* zpp isc)))
            xx  (* 0.5 wid isc)
            yy  (* 0.5 lon isc)
      )
      (setq xy  (sqrt (+ (* xx xx) (* yy yy)))
            xx1 (fix (* xy (cos (+ (atan (/ yy xx)) (/ (* zhj pi) 180)))))
            xx2 (fix (* xy (cos (+ (* -1 (atan (/ yy xx))) (/ (* zhj pi) 180)))))
            yy1 (fix (* xy (sin (+ (atan (/ yy xx)) (/ (* zhj pi) 180)))))
            yy2 (fix (* xy (sin (+ (* -1 (atan (/ yy xx))) (/ (* zhj pi) 180)))))
      )
      (start_image "img")
      (fill_image 0 0 w0 h0 -2)
      (vector_image x0 0 x0 h0 253)
      (vector_image 0 y0 w0 y0 253)
      (vector_image xc (- yc 10) xc (+ 10 yc) 1)
      (vector_image (- xc 10) yc (+ xc 10) yc 1)
      (vector_image (- xc xx2) (+ yc yy2) (+ xc xx1) (- yc yy1) 2)
      (vector_image (- xc xx2) (+ yc yy2) (- xc xx1) (+ yc yy1) 2)
      (vector_image (+ xc xx1) (- yc yy1) (+ xc xx2) (- yc yy2) 2)
      (vector_image (- xc xx1) (+ yc yy1) (+ xc xx2) (- yc yy2) 2)
      (end_image)
    )
    (defun getfh () 
      (setq dim  (get_tile "dim")
            rote (get_tile "rote")
      )
    )
    (mapcar 'set '(wid lon hp zp zhj lab rote dim no first) txt)
    (setq what 2
          dia  (lib::dcl "Column")
          wid  (atoi wid)
          lon  (atoi lon)
          hp   (atoi hp)
          zp   (atoi zp)
          zhj  (atoi zhj)
    )
    (while (> what 0) 
      (if (not (new_dialog "Bdlzhj" dia)) (exit))
      (mapcar 'set_tile 
              (list "wid" "lon" "hp" "zp" "zhj" "lab" "rote" "dim" "no" "first")
              txt
      )
      (slide 0)
      (slide 6)
      (action_tile "wid" "(#isnum 0 nil)(slide 0)")
      (action_tile "lon" "(#isnum 0 nil)(slide 0)")
      (action_tile "hp" "(#isnum nil nil)(slide 0)")
      (action_tile "zp" "(#isnum nil nil)(slide 0)")
      (action_tile "zhj" "(#isnum 0. 360.)(slide 0)")
      (action_tile "wids" "(slide 1)")
      (action_tile "lons" "(slide 2)")
      (action_tile "hps" "(slide 3)")
      (action_tile "zps" "(slide 4)")
      (action_tile "zhjs" "(slide 5)")
      (action_tile "no" "(slide 6)")
      (action_tile "rote" "(slide 6)")
      (action_tile "dim" "(slide 6)")
      (action_tile "first" "(slide 6)")
      (action_tile "sigl" "(slide 6)(setq what -8)(done_dialog 1)")
      (action_tile "mult" "(slide 6)(setq what -18)(done_dialog 2)")
      (action_tile "zhux" "(slide 6)(setq what -28)(done_dialog 2)")
      (action_tile "cancel" "(setq what -38)(done_dialog 3)")
      (action_tile "help" "(help \"Tssd\" \"Bdlzhj\")")
      (start_dialog)
    )
    (unload_dialog dia)
    what
  )
  (if (< (&UTXT) 0) (exit))
  (setq txt (&GPTS "Tssd40/Dcl_Hzh/Bdlzhj"))
  (if (or (= txt nil) (wcmatch txt "")) 
    (setq txt (list "2000" "2000" "0" "0" "0" "J-1" "1" "1" "1" "1"))
    (setq txt (&PLCN txt "\t"))
  )
  (draw (chs_dcl txt))
  (&TSTY)
)