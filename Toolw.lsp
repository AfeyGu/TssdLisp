(lib::lsp "Myfan")
(setfunhelp "c:flcpshg" "Tswd" "flcpshg")
(defun c:flcpshg (/ gdang ang ang1 ang2 dis p0 p1 p2 p3 p4 p5 p6 p7 pt pt1 ss flag pe) 
  (defun gdang (e / a l na p0 en) 
    (setq en (car e)
          p0 (cadr e)
          na (&DRAG en 0)
    )
    (cond 
      ((= na "LINE") (angle (&DRAG en 10) (&DRAG en 11)))
      ((= na "LWPOLYLINE")
       (setq l (@whpl (@pl2l (&DRAG en 10) (&DRAG en 70) (&DRAG en 42)) p0)
             a (if (= (length l) 2) 
                 (angle (car l) (cadr l))
                 (- (angle (car l) p0) _pi2)
               )
       )
       (if (< a (- pi 1e-3)) a (- a pi))
      )
    )
  )
  (if (< (&UTXT 2) 0) (exit))
  (setq pe (getvar "PICKSTYLE"))
  (setvar "PICKSTYLE" 0)
  (if 
    (and (setq pt (&OSNP "\n选取排水管反滤层所在的位置<退出>: ")) 
         (setq pt1 (&OSNP pt "\n选取排水管另一端所在的位置<退出>: "))
    )
    (progn 
      (setq ang (angle pt pt1)
            ss  (ssget "f" 
                       (list (polar pt (* 0.2 pi) &sp) 
                             pt
                             (polar pt (* 1.3 pi) &sp)
                       )
                       '((0 . "LINE,LWPOLYLINE"))
                )
      )
      (if ss 
        (setq ang1 (gdang (list (ssname ss 0) pt))
              ss   nil
        )
      )
      (setq ss (ssget "f" 
                      (list (polar pt1 (* 0.2 pi) &sp) 
                            pt1
                            (polar pt1 (* 1.3 pi) &sp)
                      )
                      '((0 . "LINE,LWPOLYLINE"))
               )
      )
      (if ss 
        (setq ang2 (gdang (list (ssname ss 0) pt1))
              ss   nil
        )
      )
      (setq dis (&OSNP pt "\n输入排水管的直径<100>: " 0))
      (if (not dis) (setq dis 100))
      (setq dis (* dis &sc))
      (if 
        (and ang1 
             (or (not (equal ang1 (+ ang (* 0.5 pi)) 0.01)) 
                 (not (equal ang1 (- ang (* 0.5 pi)) 0.01))
             )
        )
        (setq p0 (polar pt ang1 1000)
              p1 (polar pt (+ ang1 pi) 1000)
              p2 (polar pt (+ ang (* 0.5 pi)) (* 0.5 dis))
              p3 (polar pt (- ang (* 0.5 pi)) (* 0.5 dis))
        )
        (setq p2 (polar pt (+ ang (* 0.5 pi)) (* 0.5 dis))
              p3 (polar pt (- ang (* 0.5 pi)) (* 0.5 dis))
        )
      )
      (if 
        (and ang2 
             (or (not (equal ang2 (+ ang (* 0.5 pi)) 0.01)) 
                 (not (equal ang2 (- ang (* 0.5 pi)) 0.01))
             )
        )
        (setq p6 (polar pt1 ang2 1000)
              p7 (polar pt1 (+ ang2 pi) 1000)
              p4 (polar pt1 (+ ang (* 0.5 pi)) (* 0.5 dis))
              p5 (polar pt1 (- ang (* 0.5 pi)) (* 0.5 dis))
        )
        (setq p4 (polar pt1 (+ ang (* 0.5 pi)) (* 0.5 dis))
              p5 (polar pt1 (- ang (* 0.5 pi)) (* 0.5 dis))
        )
      )
      (if p0 
        (setq p2 (inters p2 p4 p0 p1 nil)
              p3 (inters p3 p5 p0 p1 nil)
        )
      )
      (if p6 
        (setq p4 (inters p2 p4 p6 p7 nil)
              p5 (inters p3 p5 p6 p7 nil)
        )
      )
      (&LJIG "粗线符号" T)
      (command ".line" p2 p4 "" ".line" p3 p5 "")
      (if ang1 
        (progn (setq flag (abs (- ang1 ang))) 
               (if (> flag pi) (setq flag (- (* 2.0 pi) flag)))
               (if (>= (setq flag (+ ang1 flag)) (* 2.0 pi)) 
                 (setq flag (- flag (* 2.0 pi)))
               )
               (if (equal flag ang 0.01) 
                 (command ".insert" 
                          "Ts_flc"
                          pt
                          (* 2.3 dis)
                          ""
                          (/ (* 180 (+ pi ang1)) pi)
                 )
                 (command ".insert" "Ts_flc" pt (* 2.3 dis) "" (/ (* 180 ang1) pi))
               )
        )
        (command ".insert" 
                 "Ts_flc"
                 pt
                 (* 2.3 dis)
                 ""
                 (/ (* 180 (+ (* 0.5 pi) ang)) pi)
        )
      )
      (command ".explode" (entlast))
    )
  )
  (setvar "PICKSTYLE" pe)
  (&TSTY)
)
(setfunhelp "c:shlfx" "Tswd" "shlfx")
(defun c:shlfx (/ ang b flag pt ss) 
  (if (< (&UTXT 2) 0) (exit))
  (setq pt (&OSNP "\n选取水流方向符号上端所在位置<退出>: "))
  (if pt 
    (progn (&LJIG "细线符号" T) 
           (initget 6)
           (setq b  (getreal "\n输入水流方向符号箭头横端的宽度<15>: ")
                 ss (ssadd)
           )
           (if (not b) (setq b 15.0))
           (command ".insert" "Ts_sl" pt (* (/ b 15) &sp) "" 90)
           (ssadd (entlast) ss)
           (initget 128)
           (setq ang (&END "\n选取指北针的角度方向(单位:度)<向下>: " ss pt 0))
           (setq flag (type ang))
           (if (= flag 'STR) 
             (if (= (read ang) (atof ang)) 
               (progn (ss::del ss) 
                      (command ".insert" 
                               "Ts_sl"
                               pt
                               (* (/ b 15.0) &sp)
                               ""
                               (- (atof ang) 270)
                      )
                      (command ".insert" "Ts_sl" pt (* (/ b 15.0) &sp) "" 0)
               )
             )
             (if (not ang) (command ".insert" "Ts_sl" pt (* (/ b 15) &sp) "" 0))
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:qmsx" "Tswd" "qmsx")
(defun c:qmsx (/ a a1 p0 p1 p2 p3 p4 p5 ss old en layx) 
  (if (< (&UTXT 2) 0) (exit))
  (if 
    (setq p0 (&OSNP "\n选取素线中心的起点位置<退出>: ")
          ss (ssadd)
    )
    (progn (initget 2) 
           (setq p1 (&OSNP p0 "\n选取素线的高度<退出>: " 0))
           (if p1 
             (progn (initget 6) 
                    (setq r (&OSNP p0 "\n输入素线的半宽度<500>: " 0))
                    (if (not r) (setq r 500.0))
                    (setq old (/ r 8)
                          old (* (fix (/ old 10)) 10)
                    )
                    (initget 6)
                    (setq b (getreal (strcat "\n输入最宽的素线间距<" (&RTXT old) ">: ")))
                    (if (not b) (setq b (* 1.0 old)))
                    (setq r  (* r &sc)
                          b  (* b &sc)
                          p1 (polar p0 (* 0.5 pi) p1)
                    )
                    (setq a  (/ b r)
                          a1 a
                          p2 (polar p0 0 r)
                          p3 (polar p1 0 r)
                          p4 (polar p1 pi r)
                          p5 (polar p0 pi r)
                    )
                    (setq layx (&LJIG "细线符号" T))
                    (@line p0 p1 layx)
                    (setq en (entlast))
                    (ssadd en ss)
                    (while (< a (* 0.5 pi)) 
                      (setq p2 (polar p0 0 (* r (sin a)))
                            p3 (polar p1 0 (* r (sin a)))
                            p4 (polar p0 pi (* r (sin a)))
                            p5 (polar p1 pi (* r (sin a)))
                            a  (+ a a1)
                      )
                      (@line p2 p3 layx)
                      (@line p5 p4 layx)
                    )
                    (while (entnext en) (ssadd (setq en (entnext en)) ss))
                    (&DGAR ss)
             )
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:fycm" "Tswd" "fycm")
(defun c:fycm (/ an an1 an2 b da en old p p0 p1 p2 ss layx) 
  (if (< (&UTXT 2) 0) (exit))
  (if 
    (and (setq p0 (&OSNP "\n选取素线集中起点O的位置<退出>: ")) 
         (setq p1 (&OSNP p0 "\n选取素线角点A的位置<退出>: "))
    )
    (progn (grdraw p0 p1 -1) 
           (if (setq p2 (&OSNP p0 "\n选取素线另一角点B的位置<退出>: ")) 
             (progn (grdraw p0 p2 -1) 
                    (setq old (+ 2 (fix (/ (distance p1 p2) &sp)))
                          ss  (ssadd)
                    )
                    (initget 6)
                    (setq b (getreal (strcat "\n输入素线的数量<" (&RTXT old) ">: ")))
                    (if (not b) (setq b old))
                    (setq an1 (angle p0 p1)
                          an2 (angle p0 p2)
                    )
                    (setq layx (&LJIG "细线符号" T))
                    (if (>= (setq an (abs (- an2 an1))) pi) 
                      (setq an1 (max an1 an2)
                            da  (/ (- (* 2 pi) an) (1- b))
                      )
                      (setq an1 (min an1 an2)
                            da  (/ an (1- b))
                      )
                    )
                    (@line p0 p1 layx)
                    (setq en (entlast))
                    (ssadd en ss)
                    (while (> b 1) 
                      (setq p (polar p0 (setq an1 (+ an1 da)) 1000)
                            p (inters p0 p p1 p2 nil)
                            b (1- b)
                      )
                      (if (not (equal p p2 (* 0.1 &sp))) (progn (@line p0 p layx)))
                    )
                    (@line p0 p2 layx)
                    (while (entnext en) (ssadd (setq en (entnext en)) ss))
                    (&DGAR ss)
             )
           )
           (grdraw p0 p1 -1)
           (grdraw p0 p2 -1)
    )
  )
  (&TSTY)
)
(setfunhelp "c:fydm" "Tswd" "fydm")
(defun c:fydm (/ a1 a2 an1 an2 b da el en old p p0 p1 p2 q0 r ss layx) 
  (if (< (&UTXT 2) 0) (exit))
  (if 
    (and (setq p0 (&OSNP "\n选取素线集中起点O的位置<退出>: ")) 
         (setq p1 (&OSNP p0 "\n选取圆弧上一点A的位置<退出>: "))
    )
    (progn (grdraw p0 p1 -1) 
           (if (setq p2 (&OSNP p0 "\n选取圆弧上另一点B的位置<退出>: ")) 
             (progn (grdraw p0 p2 -1) 
                    (if (setq p (&P2L p1 p2)) 
                      (progn 
                        (setq old (+ 2 (fix (/ (distance p1 p2) &sp)))
                              ss  (ssadd)
                        )
                        (initget 6)
                        (setq b (getreal (strcat "\n输入素线的数量<" (&RTXT old) ">: ")))
                        (if (not b) (setq b old))
                        (setq an1 (angle p0 p1)
                              an2 (angle p0 p2)
                        )
                        (command ".arc" p1 p p2)
                        (setq en (entlast)
                              el (entget en)
                              q0 (cdr (assoc 10 el))
                              r  (cdr (assoc 40 el))
                              a1 (cdr (assoc 50 el))
                              a2 (cdr (assoc 51 el))
                        )
                        (entdel en)
                        (if (>= (setq an (abs (- an2 an1))) pi) 
                          (setq an1 (max an1 an2)
                                da  (/ (- (* 2 pi) an) (1- b))
                          )
                          (setq an1 (min an1 an2)
                                da  (/ an (1- b))
                          )
                        )
                        (setq layx (&LJIG "细线符号" T))
                        (@line p0 p1 layx)
                        (setq en (entlast))
                        (ssadd en ss)
                        (while (> b 1) 
                          (setq p (polar p0 
                                         (setq an1 (+ an1 da))
                                         (+ (* 3 r) (distance p0 q0))
                                  )
                                p (car (&ORDR p0 p q0 r a1 a2))
                                b (1- b)
                          )
                          (if (not (equal p p2 (* 0.1 &sp))) (@line p0 p layx))
                        )
                        (@line p0 p2 layx)
                        (while (entnext en) (ssadd (setq en (entnext en)) ss))
                        (&DGAR ss)
                      )
                    )
             )
           )
           (grdraw p0 p1 -1)
           (grdraw p0 p2 -1)
    )
  )
  (&TSTY)
)
(setfunhelp "c:Zfych" "Tswd" "Zfych")
(defun c:Zfych (/ bzwz csh up_dow dcl_start hdsj dat_wz dat_bz dia fi fil what x oldm 
                txt
               ) 
  (defun bzwz (/ l_max i l p0 p1 zg ang le dis en ss) 
    (defun l_max (dat le / dis olddis pl p1 p2) 
      (command ".text" (list 0 0 0) zg "" ".")
      (entdel (entlast))
      (setq olddis 0)
      (while (> le 0) 
        (setq pl  (textbox (list (cons 1 (nth (- le 1) dat))))
              p1  (nth 0 pl)
              p2  (nth 1 pl)
              dis (distance p1 p2)
              le  (- le 1)
        )
        (if (> dis olddis) (setq olddis dis))
      )
      olddis
    )
    (setq i  0
          l  (length dat_bz)
          zg (&INTS "标号文字")
          ss (ssadd)
          le (* 1.03 (l_max dat_bz l))
    )
    (setq p0 (&OSNP "\n选取文字标注的起点位置<退出>: "))
    (if p0 
      (progn (setq p1 (&OSNP p0 "\n选取结束点的位置<退出>: ")) 
             (if p1 
               (progn (setq ang (angle p0 p1)) 
                      (&LJIG "粗线符号" T)
                      (command ".pline" 
                               p0
                               "w"
                               0
                               (* 40 &sc)
                               (polar p0 ang (* 200 &sc))
                               ""
                      )
                      (setq en (entlast))
                      (ssadd en ss)
                      (&LJIG "细线符号" T)
                      (command ".line" p0 p1 "")
                      (cond 
                        ((and (>= ang 0) (<= ang (* 0.5 pi)))
                         (setq dis (* l zg)
                               p0  (polar p1 0 le)
                         )
                         (command ".line" p1 (polar p1 (* 0.5 pi) (* 1.5 dis)) "")
                         (while (> l 0) 
                           (&LJIG "细线符号" T)
                           (command ".line" p1 p0 "")
                           (&LJIG "文字" T)
                           (command ".text" 
                                    (polar p1 (* 0.25 pi) (* 0.6 &sp))
                                    zg
                                    0
                                    (nth i dat_bz)
                           )
                           (setq l  (- l 1)
                                 i  (+ i 1)
                                 p1 (polar p1 (* 0.5 pi) (* 1.5 zg))
                                 p0 (polar p0 (* 0.5 pi) (* 1.5 zg))
                           )
                         )
                        )
                        ((and (> ang (* 0.5 pi)) (<= ang pi))
                         (setq dis (* l zg)
                               p0  (polar p1 pi le)
                         )
                         (command ".line" p1 (polar p1 (* 0.5 pi) (* 1.5 dis)) "")
                         (while (> l 0) 
                           (&LJIG "细线符号" T)
                           (command ".line" p1 p0 "")
                           (&LJIG "文字" T)
                           (command ".text" 
                                    (polar p0 (* 0.25 pi) (* 0.6 &sp))
                                    zg
                                    0
                                    (nth i dat_bz)
                           )
                           (setq l  (- l 1)
                                 i  (+ i 1)
                                 p1 (polar p1 (* 0.5 pi) (* 1.5 zg))
                                 p0 (polar p0 (* 0.5 pi) (* 1.5 zg))
                           )
                         )
                        )
                        ((and (> ang pi) (< ang (* 1.5 pi)))
                         (setq dis (* (- l 1) zg)
                               p0  (polar p1 pi le)
                         )
                         (command ".line" p1 (polar p1 (* 1.5 pi) (* 1.5 dis)) "")
                         (while (> l 0) 
                           (&LJIG "细线符号" T)
                           (command ".line" p1 p0 "")
                           (&LJIG "文字" T)
                           (command ".text" 
                                    (polar p0 (* 0.25 pi) (* 0.6 &sp))
                                    zg
                                    0
                                    (nth i dat_bz)
                           )
                           (setq l  (- l 1)
                                 i  (+ i 1)
                                 p1 (polar p1 (* 1.5 pi) (* 1.5 zg))
                                 p0 (polar p0 (* 1.5 pi) (* 1.5 zg))
                           )
                         )
                        )
                        ((and (>= ang (* 1.5 pi)) (< ang (* 2 pi)))
                         (setq dis (* (- l 1) zg)
                               p0  (polar p1 0 le)
                         )
                         (command ".line" p1 (polar p1 (* 1.5 pi) (* 1.5 dis)) "")
                         (while (> l 0) 
                           (&LJIG "细线符号" T)
                           (command ".line" p1 p0 "")
                           (&LJIG "文字" T)
                           (command ".text" 
                                    (polar p1 (* 0.25 pi) (* 0.6 &sp))
                                    zg
                                    0
                                    (nth i dat_bz)
                           )
                           (setq l  (- l 1)
                                 i  (+ i 1)
                                 p1 (polar p1 (* 1.5 pi) (* 1.5 zg))
                                 p0 (polar p0 (* 1.5 pi) (* 1.5 zg))
                           )
                         )
                        )
                      )
                      (while (entnext en) (ssadd (setq en (entnext en)) ss))
                      (&DGAR ss)
               )
             )
      )
    )
  )
  (defun csh (dat1 dat2 no / l i) 
    (setq l (length dat1)
          i 0
    )
    (if (> l 0) (progn (start_list "cyz" 3) (mapcar 'add_list dat1) (end_list)))
    (setq l (length dat2)
          i 0
    )
    (if (or (not no) (= l 0) (= no l)) 
      (mapcar 'mode_tile 
              (list "up" "dow" "del" "ins" "cha" "ed")
              (list 1 1 1 1 1 1)
      )
      (if (= l 1) 
        (mapcar 'mode_tile 
                (list "up" "dow" "del" "ins" "cha" "ed")
                (list 1 1 0 0 0 0)
        )
        (mapcar 'mode_tile 
                (list "up" "dow" "del" "ins" "cha" "ed")
                (list 0 0 0 0 0 0)
        )
      )
    )
    (start_list "bz" 3)
    (if (> l 0) (mapcar 'add_list dat2))
    (end_list)
    (if no 
      (progn (set_tile "bz" (itoa no)) 
             (if (= no 0) (mode_tile "up" 1))
             (if (= no (- (length dat2) 1)) (mode_tile "dow" 1))
      )
    )
  )
  (defun up_dow (flag / i l n m dat txt) 
    (setq i 0
          l (length dat_bz)
          n (read (get_tile "bz"))
          m (read (get_tile "cyz"))
    )
    (set_tile "error" "")
    (if (and n (= flag -2)) 
      (progn (setq dat dat_bz) (set_tile "txt" (nth n dat_bz)))
    )
    (if (= flag -1) 
      (progn 
        (if (= $reason 4) 
          (progn 
            (setq dat  dat_bz
                  flag 0
            )
            (set_tile "txt" (nth m dat_wz))
          )
        )
        (setq dat dat_bz)
      )
    )
    (cond 
      ((= flag 0)
       (if (not (wcmatch (setq txt (get_tile "txt")) "")) 
         (setq dat (append dat_bz (list (get_tile "txt"))))
         (if m 
           (setq dat (append dat_bz (list (nth m dat_wz))))
           (progn (setq dat dat_bz) (set_tile "error" "*****没有任何可以加入的操作选项*****"))
         )
       )
       (csh nil dat (- (length dat) 1))
      )
      ((= flag 1)
       (if (not (wcmatch (setq txt (get_tile "txt")) "")) 
         (setq dat_wz (append dat_wz (list (get_tile "txt"))))
         (set_tile "error" "*****编辑框中没有内容可以加入到常用列表*****")
       )
       (csh dat_wz (setq dat dat_bz) n)
      )
      ((= flag 2)
       (if (or (not n) (= n 0)) 
         (progn (setq dat dat_bz) (set_tile "error" "*****没有什么可以再进行上移的选项*****"))
         (progn 
           (while (> l 0) 
             (if (= i (- n 1)) 
               (setq dat (append dat (list (nth n dat_bz) (nth i dat_bz)))
                     i   (+ i 1)
                     l   (- l 1)
               )
               (setq dat (append dat (list (nth i dat_bz))))
             )
             (setq l (- l 1)
                   i (+ i 1)
             )
           )
           (csh nil dat (- n 1))
         )
       )
      )
      ((= flag 3)
       (if (or (not n) (= n (- l 1))) 
         (progn (setq dat dat_bz) (set_tile "error" "*****没有什么可以再进行下移的选项*****"))
         (progn 
           (while (> l 0) 
             (if (= i n) 
               (setq dat (append dat (list (nth (+ n 1) dat_bz) (nth n dat_bz)))
                     i   (+ i 1)
                     l   (- l 1)
               )
               (setq dat (append dat (list (nth i dat_bz))))
             )
             (setq l (- l 1)
                   i (+ i 1)
             )
           )
           (csh nil dat (+ n 1))
         )
       )
      )
      ((= flag 4)
       (if (not n) (set_tile "error" "*****没有什么可以可以进行删除的选项*****"))
       (while (> l 0) 
         (if (/= i n) (setq dat (append dat (list (nth i dat_bz)))))
         (setq l (- l 1)
               i (+ i 1)
         )
       )
       (if (= n (length dat)) (setq n (- n 1)))
       (csh nil dat n)
      )
      ((= flag 5)
       (if (not (wcmatch (get_tile "txt") "")) 
         (setq txt (get_tile "txt"))
         (if m (setq txt (nth m dat_wz)))
       )
       (if (or (not txt) (not n)) 
         (progn (setq dat dat_bz) (set_tile "error" "*****没有可以插入的内容或没有插入位置*****"))
         (while (> l 0) 
           (if (and txt (= i n)) (setq dat (append dat (list txt))))
           (setq dat (append dat (list (nth i dat_bz))))
           (setq l (- l 1)
                 i (+ i 1)
           )
         )
       )
       (csh nil dat n)
      )
      ((= flag 6)
       (if (not (wcmatch (get_tile "txt") "")) 
         (setq txt (get_tile "txt"))
         (if m (setq txt (nth m dat_wz)))
       )
       (if (or (not n) (not txt)) 
         (progn (setq dat dat_bz) (set_tile "error" "*****没有可以替换的内容或没有替换位置*****"))
         (while (> l 0) 
           (if (/= i n) 
             (setq dat (append dat (list (nth i dat_bz))))
             (setq dat (append dat (list (if txt txt (nth i dat_bz)))))
           )
           (setq l (- l 1)
                 i (+ i 1)
           )
         )
       )
       (csh nil dat n)
      )
      ((= flag 7)
       (if (= $reason 4) (set_tile "txt" (nth n dat_bz)))
       (csh nil (setq dat dat_bz) n)
      )
    )
    (setq dat_bz dat)
  )
  (defun dcl_start () 
    (action_tile "add1" "(up_dow 0)")
    (action_tile "add2" "(up_dow 1)")
    (action_tile "up" "(up_dow 2)")
    (action_tile "dow" "(up_dow 3)")
    (action_tile "del" "(up_dow 4)")
    (action_tile "ins" "(up_dow 5)")
    (action_tile "cha" "(up_dow 6)")
    (action_tile "bz" "(up_dow 7)")
    (action_tile "cyz" "(up_dow -1)")
    (action_tile "ed" "(up_dow -2)")
  )
  (defun hdsj (/ l i fil) 
    (setq what -8
          l    (length dat_wz)
          i    0
    )
    (setq fil (open (findfile "Wzbz.txt") "w"))
    (while (> l 0) 
      (write-line (nth i dat_wz) fil)
      (setq i (+ i 1)
            l (- l 1)
      )
    )
    (close fil)
    (done_dialog -8)
  )
  (defun gettxt (/ ent entl i l len na str1 str2 txt) 
    (if (setq ent (nentsel "\n选取文字对象<返回>: ")) 
      (progn 
        (setq entl (entget (car ent))
              na   (strcase (cdr (assoc 0 entl)))
        )
        (cond 
          ((or (wcmatch na "TEXT") (wcmatch na "ATTRIB"))
           (setq txt (cdr (assoc 1 entl)))
          )
          ((wcmatch na "ATTDEF") (setq txt (cdr (assoc 2 entl))))
          ((wcmatch na "MTEXT")
           (setq txt (cdr (assoc 1 entl))
                 len (strlen txt)
                 l   len
                 i   1
           )
           (while (> len 0) 
             (if (wcmatch (@substr txt i 1) ";") 
               (setq str1 (@substr txt 1 i)
                     str2 (@substr txt (+ i 1) (- l i))
                     len  0
               )
             )
             (setq i   (+ i 1)
                   len (- len 1)
             )
           )
           (if (wcmatch str1 "") (setq str2 txt))
           (setq txt str2)
          )
        )
        (if txt (setq dat_bz (append dat_bz (list txt))))
      )
    )
    txt
  )
  (if (< (&UTXT 2) 0) (exit))
  (setq fil (open (findfile "Wzbz.txt") "r"))
  (while (setq fi (read-line fil)) (setq dat_wz (append dat_wz (list fi))))
  (close fil)
  (setq what   2
        dat_bz nil
        dia    (lib::dcl "Wztool")
        x      0
        txt    nil
  )
  (while (> what 0) 
    (if (not (new_dialog "Wzbz" dia)) (exit))
    (csh dat_wz dat_bz nil)
    (dcl_start)
    (action_tile "gettxt" "(done_dialog 8)")
    (action_tile "accept" "(hdsj)")
    (action_tile "cancel" "(done_dialog 0)(setq what -2)")
    (action_tile "help" "(help \"Tswd\" \"Zfych\")")
    (if txt 
      (progn (set_tile "txt" txt) 
             (setq txt nil)
             (csh nil dat_bz (- (length dat_bz) 1))
      )
    )
    (setq what (start_dialog))
    (if (= what 8) (setq txt (gettxt)))
  )
  (unload_dialog dia)
  (if (and (> (length dat_bz) 0) (= what -8)) (bzwz))
  (&TSTY)
)
(setfunhelp "c:tlxold" "Tswd" "tlxold")
(defun C:tlxold (/ draw_l draw_a en ent entl flag len p0) 
  (defun draw_l (el l / p0 p1 ang fl) 
    (setq p0  (cdr (assoc 10 el))
          p1  (cdr (assoc 11 el))
          ang (angle p0 p1)
          fl  0
    )
    (if (< l 0) 
      (setq p0 (polar p0 ang (abs l))
            l  0
            fl 1
      )
    )
    (entdel ent)
    (while (> (distance p0 p1) (* 5.0 &sp)) 
      (command ".pline" 
               p0
               "w"
               &sp
               &sp
               (polar p0 ang (if (= l 0) (* 5.0 &sp) l))
               ""
      )
      (setq p0 (polar p0 ang (if (= l 0) (* 10.0 &sp) (+ l (* 5.0 &sp))))
            l  0
            fl 0
      )
    )
    (if 
      (and (= fl 0) 
           (equal ang (angle p0 p1) 0.01)
           (< (distance p0 p1) (* 5.0 &sp))
      )
      (progn (command ".pline" p0 "w" &sp &sp (if (= l 0) p1 (polar p0 ang l)) "") 
             (setq l (- (* 5.0 &sp) (distance p0 p1)))
      )
      (setq l (* -1 (distance p0 p1)))
    )
  )
  (defun draw_a (el l / p0 r qi zj p) 
    (setq p0 (cdr (assoc 10 el))
          r  (cdr (assoc 40 el))
          qi (cdr (assoc 50 el))
          zj (cdr (assoc 51 el))
          a  (/ (* 5.0 &sp) r)
    )
    (entdel ent)
    (while (< qi zj) 
      (setq p (polar p0 qi r))
      (command ".pline" p "w" &sp &sp "a" (polar p0 (+ qi a) r) "")
      (setq qi (+ qi (* 2.0 a)))
    )
    (setq l 0)
  )
  (&UTXT 2)
  (if (setq p0 (getpoint "\n点取铁路轨迹线的起点<退出>: ")) 
    (progn (&SWTO t) 
           (setvar "cmdecho" 0)
           (command ".pline")
           (setvar "cmdecho" 1)
           (command p0)
           (while (/= (getvar "cmdactive") 0) (command pause))
           (setvar "cmdecho" 0)
           (&SWTO)
           (setq ent (entlast))
           (command ".offset" 
                    (* 0.5 &sp)
                    ent
                    (polar p0 0.1 10000)
                    ""
                    ".offset"
                    (* 0.5 &sp)
                    ent
                    (polar p0 (* 1.1 pi) 10000)
                    ""
           )
           (setq en  (entlast)
                 len 0
           )
           (command ".explode" ent)
           (while ent 
             (setq ent  (entnext en)
                   entl (entget ent)
                   flag (cdr (assoc 0 entl))
             )
             (cond 
               ((= flag "LINE") (setq len (draw_l entl len)))
               ((= flag "ARC") (setq len (draw_a entl len)))
               ((= flag "LWPOLYLINE") (setq ent nil))
             )
           )
    )
  )
  (&TSTY)
)
(setfunhelp "c:tlx" "Tswd" "tlx")
(defun C:tlx (/ draw ang ent i l len p0 p1 pl ss p2 ss en) 
  (defun draw (p0 p1 l / ang fl) 
    (setq ang (angle p0 p1)
          fl  0
    )
    (if (< l 0) 
      (if (> (distance p0 p1) (abs l)) 
        (setq p0 (polar p0 ang (abs l))
              l  0
        )
        (setq l  (+ l (distance p0 p1))
              fl 1
        )
      )
      (if (> l (distance p0 p1)) (setq l (distance p0 p1)))
    )
    (while (and (equal ang (angle p0 p1) 0.01) (> (distance p0 p1) (* 5.0 &sp))) 
      (command ".pline" 
               p0
               "w"
               &sp
               &sp
               (polar p0 ang (if (= l 0) (* 5.0 &sp) l))
               ""
      )
      (setq p0  (polar p0 ang (if (= l 0) (* 10.0 &sp) (+ l (* 5.0 &sp))))
            l   0
            len 0
            fl  0
      )
    )
    (if 
      (and (= fl 0) 
           (equal ang (angle p0 p1) 0.01)
           (< (distance p0 p1) (* 5.0 &sp))
      )
      (progn (command ".pline" p0 "w" &sp &sp (if (= l 0) p1 (polar p0 ang l)) "") 
             (setq l (- (* 5.0 &sp) (+ len (distance p0 p1))))
      )
      (if (= fl 0) (setq l (* -1 (distance p0 p1))))
    )
    l
  )
  (if 
    (and (setq p0 (getpoint "\n点取铁路轨迹线的起点<退出>: ")) 
         (setq p1 (getpoint p0 "\t下一点: "))
    )
    (progn 
      (setq pl  (append pl (list p0))
            ang (+ (* 0.5 pi) (angle p0 p1))
            ss  (ssadd)
            len 0
            p2  p0
            ss  (ssadd)
      )
      (&UTXT 2)
      (&LJIG "细线符号" T)
      (while p1 
        (setq pl (append pl (list p1)))
        (command ".pline" p0 p1 "")
        (ssadd (entlast) ss)
        (setq p0 p1
              p1 (getpoint p0 "\t下一点<结束>: ")
        )
      )
      (setq l   (length pl)
            i   0
            ent (entlast)
            en  ent
      )
      (while (> l (+ i 1)) 
        (setq len (draw (nth i pl) (nth (+ i 1) pl) len)
              i   (+ i 1)
        )
      )
      (command ".pedit" ent "Join" ss "" "")
      (command ".offset" 
               "T"
               ent
               (polar p2 ang (* 0.5 &sp))
               ""
               ".offset"
               "T"
               ent
               (polar p2 (+ pi ang) (* 0.5 &sp))
               ""
      )
      (while (entnext en) (ssadd (setq en (entnext en)) ss))
      (&DGAR ss)
      (entdel ent)
    )
  )
  (&TSTY)
)
(setfunhelp "c:gcbch" "Tswd" "gcbch")
(defun C:gcbch (/ draw ma mi p p0 b bc f en ss) 
  (defun draw (p0 p1 / ang zg i p) 
    (setq ang (angle p0 p1)
          zg  (&INTS "标号文字")
          i   mi
    )
    (while (and (equal ang (angle p0 p1) 0.01) (>= (distance p0 p1) (* 10.0 &sp))) 
      (&LJIG "细线符号" T)
      (command ".pline" p0 "w" &sp &sp (setq p (polar p0 ang (* 10.0 &sp))) "")
      (&LJIG "文字" T)
      (command ".text" 
               "J"
               (if (= f "R") "MR" "ML")
               (polar p0 (if (= f "R") pi 0) (* 2 &sp))
               zg
               0
               i
               ".text"
               "J"
               (if (= f "R") "MR" "ML")
               (polar p (if (= f "R") pi 0) (* 2 &sp))
               zg
               0
               (+ i bc)
      )
      (setq p0 (polar p0 ang (* 20.0 &sp))
            i  (+ i (* 2 bc))
      )
    )
    (if (= (rem (- ma mi) 2) (if (= mi 0) 0 1)) 
      (command ".text" 
               "J"
               (if (= f "R") "MR" "ML")
               (polar (polar p ang (* 10.0 &sp)) (if (= f "R") pi 0) (* 2 &sp))
               zg
               0
               i
               ".text"
               "J"
               (if (= f "R") "ML" "MR")
               (polar (polar p ang (* 10.0 &sp)) (if (= f "R") 0 pi) (* 2 &sp))
               zg
               0
               "米"
      )
      (command ".text" 
               "J"
               (if (= f "R") "ML" "MR")
               (polar p (if (= f "R") 0 pi) (* 2 &sp))
               zg
               0
               "米"
      )
    )
  )
  (if (and (> (&UTXT 2) -1) (setq p0 (&OSNP "\n点取高程标尺的起点<退出>: "))) 
    (progn 
      (setq mi (getint "\n给定标尺的最小高程(单位:米)<0>: ")
            mi (if mi mi 0)
            ma (getint "\n给定标尺的最大高程(单位:米)<10>: ")
            ma (if ma ma 10)
            b  (/ (- ma mi) 10.0)
            b  (if (> (abs b) 1) (fix b) (if (> b 0) 1 -1))
            bc (getint (strcat "\n输入标尺的步长(单位:米)<" (&RTXT (abs b)) ">: "))
            bc (if bc bc b)
            ma (/ (- ma mi) (abs bc))
      )
      (initget "R L")
      (setq f (getkword "\n数字标注在哪一边? [左边(L)/右边(R)]<左边> :"))
      (&LJIG "细线符号" T)
      (command ".line" 
               (setq p (polar p0 0 (* 0.5 &sp)))
               (setq p (polar p (* 0.5 pi) (* 10 ma &sp)))
               ""
      )
      (setq en (entlast)
            ss (ssadd)
      )
      (ssadd en ss)
      (command ".line" 
               p
               (setq p (polar p pi &sp))
               (polar p (* 1.5 pi) (* 10 ma &sp))
               p0
               ""
      )
      (draw p0 (polar p0 (* 0.5 pi) (* 10 ma &sp)))
      (while (entnext en) (ssadd (setq en (entnext en)) ss))
      (&DGAR ss)
      (&TSTY)
    )
  )
)
(setfunhelp "c:npmjbd" "Tswd" "npmjbd")
(defun c:npmjbd (/ draw dcl what dia e ed ed1 ed2 ed3 ed4 ed5 ed6 bl) 
  (defun draw (/ b en p0 p1 p2 p3 p4 p5 ss yk ykg zk zkg w h l) 
    (&GLAY 
      "AppData/tssd14/Dcl/Npm"
      (strcat (&RTXT ed1) 
              "\t"
              (&RTXT ed2)
              "\t"
              (&RTXT ed3)
              "\t"
              (&RTXT ed4)
              "\t"
              (&RTXT ed5)
              "\t"
              (&RTXT ed6)
              "\t"
              (&RTXT bl)
      )
    )
    (setq p0  (getvar "viewctr")
          sc  (/ &sp bl 1.0)
          zk  (* sc ed1)
          yk  (* sc ed2)
          l   (* sc ed3)
          w   (* sc ed4)
          h   (* sc ed5)
          b   (fix ed6)
          p1  (polar p0 0 l)
          ss  (ssadd)
          zk  (* zk &sc)
          yk  (* yk &sc)
          b   (fix (* b &sc))
          zkg (/ zk b)
          ykg (/ yk b)
          p2  (polar p0 (* 1.5 pi) zk)
          p3  (polar p1 (* 1.5 pi) yk)
    )
    (&LJIG "粗线符号" T)
    (command ".line" p0 p2 "")
    (setq en (entlast))
    (ssadd en ss)
    (command ".line" p2 p3 p1 p0 "")
    (&GVAL (fix bl))
    (&LJIG "尺寸" T)
    (command ".dimlinear" 
             p2
             p3
             (polar (if (>= zk yk) p2 p3) (* 1.5 pi) (* 8 &sp))
             ".dimlinear"
             p1
             p3
             (polar p1 0 (* 8 &sp))
             ".dimlinear"
             p0
             p2
             (polar p0 pi (* 8 &sp))
    )
    (&LJIG "细线符号" T)
    (repeat (- b 1) 
      (setq p2 (polar p0 (* 1.5 pi) zkg)
            p3 (polar p1 (* 1.5 pi) ykg)
      )
      (command ".line" p2 p3 "")
      (setq p0 p2
            p1 p3
      )
    )
    (while (setq en (entnext en)) (ssadd en ss) (setq e en))
    (if (&END "\n选取扭平面正视图的插入点<退出>: " ss (getvar "viewctr")) (&DGAR ss))
    (setq ss  nil
          ss  (ssadd)
          zkg (/ h b)
          p0  (getvar "viewctr")
          p1  (polar p0 0 l)
          p2  (polar p0 (* 1.5 pi) h)
    )
    (&LJIG "粗线符号" T)
    (command ".line" 
             p0
             p1
             p2
             (polar p2 (* 0.5 pi) (+ w h h))
             (setq p3 (polar p1 (* 0.5 pi) w))
             (polar p3 pi l)
             ""
             ".line"
             p1
             p3
             ""
    )
    (&GVAL (fix bl))
    (&LJIG "尺寸" T)
    (command ".dimlinear" p0 p2 (polar p0 pi (* 8 &sp)))
    (&LJIG "细线符号" T)
    (repeat (- b 1) 
      (setq p2 (polar p0 (* 1.5 pi) zkg))
      (command ".line" p2 p1 "")
      (setq p0 p2)
    )
    (setq p0 (getvar "viewctr")
          p1 (polar p0 (* 0.5 pi) w)
          p2 (polar p1 (* 0.5 pi) h)
    )
    (repeat (- b 1) (setq p1 (polar p1 (* 0.5 pi) zkg)) (command ".line" p1 p3 ""))
    (while (setq e (entnext e)) (ssadd e ss) (setq en e))
    (if (&END "\n选取扭平面俯视图的插入点<退出>: " ss (getvar "viewctr")) (&DGAR ss))
    (setq ss nil
          ss (ssadd)
          p0 (getvar "viewctr")
    )
    (setq p1 (polar p0 (* 0.5 pi) (min zk yk))
          p2 (polar p1 pi h)
    )
    (&LJIG "粗线符号" T)
    (command ".line" 
             p1
             p0
             p2
             "c"
             ".line"
             (polar p1 0 w)
             (polar p1 0 (+ w h))
             (setq p3 (polar p0 0 w))
             (polar p3 (* 0.5 pi) (min zk yk))
             ""
             ".line"
             p0
             p3
             ""
    )
    (if (> zk yk) 
      (command ".line" 
               p0
               (setq p4 (polar p0 (* 1.5 pi) (- zk yk)))
               (setq p5 (polar p4 0 w))
               p3
               ""
      )
    )
    (&GVAL (fix bl))
    (&LJIG "尺寸" T)
    (command ".dimlinear" p1 (polar p1 0 w) (polar p1 (* 0.5 pi) (* 8 &sp)))
    (&LJIG "细线符号" T)
    (if (< zk yk) 
      (command ".line" 
               p0
               (setq p4 (polar p0 (* 1.5 pi) (- yk zk)))
               (setq p5 (polar p4 0 w))
               p3
               ""
      )
    )
    (if (not p4) (setq p4 p0))
    (repeat (- b 1) 
      (setq p1 (polar p1 pi zkg)
            p  (inters p1 p4 p0 p2)
      )
      (command ".line" p p1 "")
    )
    (setq p2 (polar p2 0 (+ h w))
          p1 (polar p0 0 w)
          p3 (polar p2 0 h)
    )
    (if (not p5) (setq p5 p1))
    (repeat (- b 1) 
      (setq p2 (polar p2 0 zkg)
            p  (inters p2 p5 p1 p3)
      )
      (command ".line" p p2 "")
    )
    (while (setq en (entnext en)) (ssadd en ss))
    (if (&END "\n选取扭平面侧视图的插入点<退出>: " ss (getvar "viewctr")) (&DGAR ss))
  )
  (defun dcl (/ vslide csh hs) 
    (defun vslide (na img / x y) 
      (setq x (dimx_tile img)
            y (dimy_tile img)
      )
      (start_image img)
      (fill_image 0 0 x y 0)
      (slide_image 0 0 (- x 10) (- y 10) (strcat "Tssdw(" na ")"))
      (end_image)
    )
    (defun csh (/ val i) 
      (set_tile "error" " N  为所画素线的根数,用户可在最后修改")
      (vslide "nmzs" "img1")
      (vslide "nmcs" "img2")
      (vslide "nmfs" "img3")
      (setq i 0)
      (repeat 6 
        (setq val (nth i ed)
              i   (+ i 1)
        )
        (set (read (strcat "ed" (itoa i))) (atof val))
      )
      (setq bl (atof (nth 6 ed)))
      (mapcar 'set_tile '("ed1" "ed2" "ed3" "ed4" "ed5" "ed6" "bl") ed)
    )
    (defun hs () 
      (setq n (fix (/ (min ed1 ed2) (* 20 &sc))))
      (set_tile "ed6" (&RTXT n))
      (set_tile "error" " N  为所画素线的根数,用户可在最后修改")
    )
    (setq what 2
          dia  (lib::dcl "Npm")
          ed   (&GPTS "AppData/tssd14/Dcl/Npm")
    )
    (if (or (= ed nil) (wcmatch ed "")) 
      (setq ed (list "300" "200" "1000" "500" "300" "10" "10"))
      (setq ed (&PLCN ed "\t"))
    )
    (while (>= what 2) 
      (if (not (new_dialog "Npm" dia)) (exit))
      (csh)
      (action_tile "ed1" "(#isnum 0 100000)(hs)")
      (action_tile "ed2" "(#isnum 0 100000)(hs)")
      (action_tile "ed3" "(#isnum 0 100000)(hs)")
      (action_tile "ed4" "(#isnum 0 100000)(hs)")
      (action_tile "ed5" "(#isnum 0 100000)(hs)")
      (action_tile "ed6" "(#isnum 0 100000)")
      (action_tile "bl" "(#isnum 0 10000)")
      (action_tile "accept" "(setq what -8)(done_dialog -1)")
      (action_tile "cancel" "(setq what -1)(done_dialog -1)")
      (action_tile "help" "(help \"Tswd\" \"npmjbd\")")
      (start_dialog)
    )
    (unload_dialog dia)
  )
  (&UTXT 2)
  (dcl)
  (if (= what -8) (draw))
  (&TSTY)
)
(setfunhelp "c:Shgfh" "Tswd" "Shgfh")
(defun C:SHGFH () (menucmd "I=TSSD.WATER") (menucmd "I=*") (princ))