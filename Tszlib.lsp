(setq _pi2(* pi 0.5)_2pi(+ pi pi)mma 1e-6)(Defun lib::LspBeg(/ l)(if(or(null &UTXT)(<(&UTXT)0))(quit)(progn(setq l(&SWAP T)&sp(float(cadr l))&sc(/ &sp(car l)))(setvar"NOMUTT"0))))(Defun lib::lset(@l_1 @l_2 / @x_1 @x_2)(foreach @x_1 @l_1(setq @x_2(car @l_2)@l_2(cdr @l_2))(if(='SYM(type @x_2))(setq @x_2(eval @x_2)))(set @x_1 @x_2)))(defun lib::u2wcs(p)(if(listp p)(trans p 1 0)(+ p(angle(trans'(0 0 0)1 0)(trans'(1 0 0)1 0)))))(defun lib::w2ucs(p)(if(listp p)(trans p 0 1)(+ p(angle(trans'(0 0 0)0 1)(trans'(1 0 0)0 1)))))(defun lib::u2dcs(p)(trans p 1 2))(defun lib::d2ucs(p)(trans p 2 1))(defun lib::r2a(ra)(/(* 180 an)pi))(defun lib::a2r(an)(/(* pi an)180))(defun lib::and(n1 n2)(=(logand n1 n2)n2))(defun lib::Xor(n1 n2)(boole 6 n1 n2))(Defun lib::lncp(p1 p2 dx dy / ax ay q1 q2 q3 q4)(if(listp p2)(setq ax(angle p1 p2))(setq ax p2 p2 p1))(if(not(zerop dx))(setq p1(polar p1 ax(- dx))p2(polar p2 ax dx)))(setq ay(- ax _pi2)q1(polar p1 ay(- dy))q2(polar p2 ay(- dy))q4(polar p1 ay dy)q3(polar p2 ay dy))(list q1 q2 q3 q4))(Defun lib::curpt(/ pt)(while(/= 5(car(setq pt(grread T)))))(cadr pt))(Defun lib::lscat(l / s sr)(foreach s l(setq sr(if sr(strcat sr","s)s)))sr)(Defun str::iwcm(sto stm)(and(='Str(type sto))(='Str(type stm))(wcmatch(strcase sto)(strcase stm))))(defun lib::ran1(a / b mn mx)(if a(progn(setq mn(apply'min a)mn(1- mn))(while(< mn(setq mx(apply'max a)))(setq b(cons mx b)a(subst mn mx a)))b)))(defun lib::ran2(a / b c mn mx)(if a(progn(setq mn(apply'min a)mn(1- mn))(while(< mn(setq mx(apply'max a)))(setq c a a(subst mn mx a))(while(setq c(member mx c))(setq c(cdr c)b(cons mx b))))b)))(defun lib::ran3(a / b c d mn mx)(if a(progn(setq c(mapcar'car a)mn(apply'min c)mn(1- mn))(while(< mn(setq mx(apply'max c)))(setq c(subst mn mx c))(while(setq d(assoc mx a))(setq a(subst'(nil)d a)b(cons d b))))b)))(defun lib::ran4(a / b c d e mn mx)(if a(progn(setq c(mapcar'car a)mn(apply'min c)mn(1- mn))(while(< mn(setq mx(apply'max c)))(setq e a c(subst mn mx c))(while(setq d(assoc mx e))(setq e(cdr(member d e))b(cons d b))))b)))(defun lib::ran5(a / b x x1)(if a(progn(while(setq x(car a))(setq x1 x a(cdr a))(foreach y a(if(>(car y)(car x))(setq x y)))(setq a(subst x1 x a))(if(or(<(car x)(caar b))(not b))(setq b(cons x b))))b)))(Defun lib::ranp2l(lp p1 p2)(mapcar'cdr(lib::ran3(mapcar'(lambda(p0)(cons(&MIDP p0 p1 p2)p0))lp))))(Defun lib::ranp(lp p1)(mapcar'cdr(lib::ran3(mapcar'(lambda(p0)(cons(distance p0 p1)p0))lp))))(Defun lib::nealp(p0 lp / di p1)(setq lp(mapcar'(lambda(p1)(cons(distance p0 p1)p1))lp)di(apply'min(mapcar'car lp)))(cdr(assoc di lp)))(Defun lib::laym2n(ll)(mapcar'cons(mapcar'&LJIG(mapcar'car ll))(mapcar'cdr ll)))(Defun lib::layflt(ll)(cons 8(lib::lscat(mapcar'car ll))))(Defun lib::layidx(ll lay i ty / l lay1)(if(setq l(assoc lay ll))(progn(setq lay(nth i l)lay1(&LJIG lay))(if(lib::and ty 1)(&LJIG lay t))(if(lib::and ty 2)lay1 lay))))(defun lib::gdist(p0 msg d0 ig / ctn d1 pt)(setq msg(strcat msg"<"(if d0(&RTXT d0)"退出")">: ")ctn t)(while ctn(initget 128)(setq pt(&OSNP p0 msg))(cond((null pt)(setq d1(if d0(* d0 &sc))ctn nil))((listp pt)(setq d1(distance p0 pt)ctn nil))((=(setq d1(atof pt))(read pt))(cond((and ig(lib::and ig 2)(zerop d1))(princ"\n**不能输入0值！请重新输入。"))((and ig(lib::and ig 4)(minusp d1))(princ"\n**不能输入负值！请重新输入。"))(t(setq d1(* d1 &sc)ctn nil))))(t(princ"\n**输入值不是实数！请重新输入。"))))d1)(Defun lib::drag1e(e0 p0 msg mod / a ctn d1 e el en p1 p2 pt r ss movln)(Defun movln(el p1 p2 d / a pt)(setq pt(lib::curpt)a(angle p1 p2)a((if(minusp(&MIDP pt p1 p2))+ -)a _pi2)el(subst(cons 10(polar p1 a d))(assoc 10 el)el)el(subst(cons 11(polar p2 a d))(assoc 11 el)el))(entmod el))(setq el(entget e0)en(&DRAG e0 0))(cond((and(="LINE"en)(= mod -1))(setq p0(osnap p0"nea")p1(&DRAG 10)p2(&DRAG 11)))((and(wcmatch en"ARC,CIRCLE")(= mod 1))(setq el(subst'(40 .  1.0)(assoc 40 el)el)))((and(="LINE"en)(= mod 2))(setq p1(&DRAG 10)p2(&DRAG 11)el(subst(cons 10(polar p0 0(distance p0 p1)))(assoc 10 el)el)el(subst(cons 11(polar p0 0(distance p0 p2)))(assoc 11 el)el)))(t(princ"\n[lib::drag] 输入的实体与拖动方式不匹配。")))(entmake el)(setq e(entlast)el(entget e)ss(ssadd e)ctn t)(while ctn(initget 128)(setq pt(&END msg ss p0 mod))(cond((null pt)(setq ctn nil e nil))((listp pt)(setq ctn nil)(if(and(="LINE"en)(= mod -1))(progn(setq d1(abs(&MIDP pt p1 p2)))(movln el p1 p2 d1))))((=(setq d1(atof pt))(read pt))(setq ctn nil)(cond((and(="LINE"en)(= mod -1))(movln el p1 p2(* d1 &sc)))((and(wcmatch en"ARC,CIRCLE")(= mod 1))(setq pt(lib::curpt)r(&DRAG 40)r((if(>(distance pt p0)r)+ -)r(* d1 &sc))el(subst(cons 40 r)(assoc 40 el)el))(entmod el))((and(="LINE"en)(= mod 2))(setq pt(lib::curpt)a(angle p0 p1)a((if(minusp(&MIDP pt p0 p1))+ -)a(lib::a2r d1))el(subst(cons 10(polar p0 a(distance p0 p1)))(assoc 10 el)el)el(subst(cons 11(polar p0 a(distance p0 p2)))(assoc 11 el)el))(entmod el))))(t(princ"\n**输入值不是实数！请重新输入。"))))e)(Defun lib::axcpt(p1 p2 / a a1 a2 e1 e2 lp lr si1 si2 ss tfz x1 x2 y1 y2 getan)(Defun getan(p e / a p1 p2)(setq p1(&DRAG e 10)p2(&DRAG 11)a(if p2(angle p1 p2)(-(angle p1 p)_pi2))a(lib::atidy a pi)))(if(setq lp(list p1 p2)tfz(lib::zoomw &sp lp)ss(ssget"c"p1 p2(list(cons 8(&LJIG"平面轴线"))'(0 . "line,arc,circle"))))(progn(setq x2(mapcar'car lp)x1(apply'min x2)x2(apply'max x2)y2(mapcar'cadr lp)y1(apply'min y2)y2(apply'max y2)si1 -1)(while(setq si1(1+ si1)e1(ssname ss si1))(setq si2 si1)(while(setq si2(1+ si2)e2(ssname ss si2))(foreach p1(&ORDR e1 e2)(if(and(< x1(car p1)x2)(< y1(cadr p1)y2))(setq a1(getan p1 e1)a2(getan p1 e2)a(cond((wcmatch(&DRAG e1 0)"ARC,CIRCLE")a2)((wcmatch(&DRAG e2 0)"ARC,CIRCLE")a1)(T(min a1 a2)))lr(cons(list p1 a)lr))))))))(if tfz(command".zoom""p"))lr)(defun lib::zoomw(c0 lp / p1 p2 q1 q2 tfo tfz x1 x2 xmax xmin xy y1 y2 ymax ymin lw)(setq p1(getvar"viewctr")x1(car p1)y1(cadr p1)y2(getvar"viewsize")lw(cons y2 p1)y2(* 0.5 y2)p1(getvar"vsmin")p2(getvar"vsmax")p2(mapcar'- p2 p1)xy(/(car p2)(cadr p2))x2(* y2 xy)xmin(- x1 x2)xmax(+ x1 x2)ymin(- y1 y2)ymax(+ y1 y2)tfz(minusp c0)c0(abs c0)q1(lib::w2ucs(getvar"extmin"))q2(lib::w2ucs(getvar"extmax")))(if(null lp)(setq lp(list q1 q2)))(foreach p1 lp(setq x1(car p1)y1(cadr p1))(if(< x1 xmin)(setq xmin(- x1 c0)tfo T))(if(> x1 xmax)(setq xmax(+ x1 c0)tfo T))(if(< y1 ymin)(setq ymin(- y1 c0)tfo T))(if(> y1 ymax)(setq ymax(+ y1 c0)tfo T)))(if tfo(progn(if(null tfz)(setq q1(list xmin ymin)q2(list xmax ymax)))(command".zoom""w"q1 q2)lw)))(defun lib::memb(x l mm / y)(car(vl-member-if'(lambda(y)(equal x y mm))l)))(defun lib::asso(x ll mm)(car(vl-member-if'(lambda(l)(equal x(car l)mm))ll)))(defun lib::pinl(p1 lp mm / p2 p3 px tf tf1 x y y1 y2)(setq x(car p1)y(cadr p1)px(list(+ 1e8 x)y)p2(last lp))(if(setq tf1(minusp mm))(setq mm(- mm)))(while lp(setq p3(car lp)lp(cdr lp)y1(cadr p2)y2(cadr p3))(if(equal(distance p2 p3)(+(distance p1 p2)(distance p1 p3))mm)(setq tf tf1 lp nil)(cond((equal y1 y2 mm))((equal y1 y mm)(if(and(>(car p2)x)(> y2 y))(setq tf(not tf))))((equal y2 y mm)(if(and(>(car p3)x)(> y1 y))(setq tf(not tf))))((inters p1 px p2 p3)(setq tf(not tf)))))(setq p2 p3))tf)(defun lib::atidy(a amx)(cond((equal a 0 mma)0.)((> a(- amx mma))(rem a amx))((minusp(+ a mma))(+(rem a amx)amx))(a)))(defun lib::upang(a2 a1)(setq a2(lib::atidy a2 _2pi)a1(- a1 mma))(while(< a2 a1)(setq a2(+ a2 _2pi)))a2)(Defun lib::lnay(p0 p1 p2 / a)(if(numberp p2)(setq a p2 p2(polar p1 a 1e3))(setq a(angle p1 p2)))((if(minusp(&MIDP p0 p1 p2))+ -)a _pi2))(defun lib::arpl(pc r a1 a2 / n an rw plt plt1)(if(null a1)(setq a1 0 a2 _2pi)(setq a1(- a1 mma)a2(+ a2 mma)a1(lib::atidy a1 _2pi)a2(lib::upang a2 a1)))(setq n(fix(/(- a2 a1)(* 0.05 pi)))n(if(< n 2)2 n)an(/(- a2 a1)n 2)rw(/ r(cos an))plt(cons(polar pc a1 r)plt))(repeat n(setq a1(+ a1 an)plt(cons(polar pc a1 rw)plt)a1(+ a1 an)pn(polar pc a1 r)plt(cons pn plt)))plt)(defun l_anth(l n x)(cond((null l)(list x))((zerop n)(cons x l))((cons(car l)(l_anth(cdr l)(1- n)x)))))(defun l_rnth(l n)(cond((null l)nil)((zerop n)(cdr l))((cons(car l)(l_rnth(cdr l)(1- n))))))(defun l_SNth(l n x)(cond((null l)nil)((zerop n)(cons x(cdr l)))((cons(car l)(l_SNth(cdr l)(1- n)x)))))(defun l_WNth(l n)(cond((null l)nil)((and(zerop n)(cdr l))(append(list(cadr l)(car l))(cddr l)))((zerop n)l)((cons(car l)(l_WNth(cdr l)(1- n))))))(defun lib::gpal(msg / a di dm e l na p0 p1 pa pb lay)(initget"A")(setq msg(strcat"\n选取"(if msg msg"线、文字或尺寸")"以确定角度或 [输入角度(A)]<水平>：")e(&DOVR msg'((0 . "line,arc,circle,lwpolyline,*text,dimension"))))(cond((null e)(setq a 0))((atom e)(setq a(&OSNP"\n输入角度<水平>："1))(if a(setq a a)(setq a 0)))((listp e)(setq p0(cadr e)na(&DRAG 0)lay(&DRAG 8))(cond((= na"LINE")(setq a(angle(&DRAG 10)(&DRAG 11))))((or(= na"ARC")(= na"CIRCLE"))(setq a(-(angle(&DRAG 10)(cadr e))(* 0.5 pi))))((= na"DIMENSION")(setq a(lib::gdman(car e))))((wcmatch na"*TEXT")(setq a(&DRAG 50)))(t(setq l(lib::whpl(lib::pl2l(&DRAG 10)(&DRAG 70)(&DRAG 42))p0)a(if(=(length l)2)(angle(car l)(cadr l))(-(angle(car l)p0)_pi2)))))))(list(lib::atidy a pi)lay))(defun lib::gpels(n)(* n(/(float(getvar"viewsize"))(cadr(getvar"screensize")))))(defun lib::area(l1 / s x1 y1 x2 y2 p1)(setq s 0. p1(last l1)x1(car p1)y1(cadr p1))(foreach p1 l1(setq x2(car p1)y2(cadr p1)s(-(+ s(* x1 y2))(* x2 y1))x1 x2 y1 y2))s)(defun lib::ptoa(p1 p2 e42 / zf p0 r a a1 a2)(setq zf(> e42 0)e42(abs e42)r(distance p1 p2)a1(angle p1 p2)a2(* 4(atan e42))r(/(* r(1+(* e42 e42)))e42 4)a1((if zf + -)a1(* 0.5 pi)(/ a2 -2))p0(polar p1 a1 r)a1(+ pi a1))(if zf(setq a2(+ a1 a2))(setq a a1 a1(- a1 a2)a2 a))(if(< a2 a1)(setq a2(+ a2 pi pi)))(list p0 r a1 a2))(defun lib::pl2l(lp n70 l42 / l p1 e42)(if(= n70 1)(setq lp(append lp(list(car lp)))))(setq p1(car lp)lp(cdr lp))(foreach p2 lp(setq e42(car l42)l42(cdr l42)l(cons(if(zerop e42)(list p1 p2)(lib::ptoa p1 p2 e42))l)p1 p2))l)(defun lib::whpl(ll p0 / p1 p2)(setq lr(car ll)mx 1e6)(foreach l ll(setq p1(car l)p2(cadr l)ds(if(=(length l)2)(if(<(distance p1 p0)(distance p1 p2))(abs(&MIDP p0 p1 p2))mx)(abs(-(distance p0 p1)p2))))(if(< ds mx)(setq lr l mx ds)))lr)(defun lib::line(p1 p2 el)(entmake(append(list'(0 . "LINE")(cons 10(lib::u2wcs p1))(cons 11(lib::u2wcs p2)))el)))(defun lib::arc(pc r a1 a2 el)(entmake(append(list'(0 . "ARC")(cons 10(lib::u2wcs pc))(cons 40 r)(cons 50(lib::u2wcs a1))(cons 51(lib::u2wcs a2)))el)))(defun lib::circle(pc r el)(entmake(append(list'(0 . "CIRCLE")(cons 10(lib::u2wcs pc))(cons 40 r))el)))(defun lib::pline(lp el / p td)(setq el(if el(reverse el)))(foreach l lp(if(listp(setq p(car l)))(setq td(cdr l))(setq p l td 0))(setq el(cons(cons 10(lib::u2wcs p))el)el(cons(cons 42 td)el)))(entmake(append'((0 . "LWPOLYLINE")(100 . "AcDbEntity")(100 . "AcDbPolyline"))(list(cons 90(length lp)))(reverse el))))(defun lib::text(str pt hi ang mod wf el / i72 i73 sty)(setq sty(getvar"textstyle")pt(lib::u2wcs pt)ang(lib::u2wcs ang)mod(if mod mod"")i72(cond((wcmatch mod"*C*")1)((wcmatch mod"*R*")2)(t 0))i73(cond((wcmatch mod"*B*")1)((wcmatch mod"*M*")2)((wcmatch mod"*T*")3)(t 0)))(entmake(append(list'(0 . "TEXT")(cons 1 str)(cons 7 sty)(cons 10 pt)(cons 11 pt)(cons 40 hi)(cons 41 wf)(cons 50 ang)(cons 72 i72)(cons 73 i73))el)))(defun lib::DimR(ang p13 p14 p10 el)(if(entmake(append(list'(0 . "DIMENSION")'(100 . "AcDbEntity")'(100 . "AcDbDimension")(cons 10 p10)'(11 0. 0. 0.)'(70 .  32)'(100 . "AcDbAlignedDimension")(cons 13 p13)(cons 14 p14)(cons 50 ang)'(100 . "AcDbRotatedDimension"))el))(entlast)))(Defun lib::ssp(p0 mm flt / lp ss tf)(setq lp(lib::lncp p0 0 mm mm)tf(lib::zoomw mm lp)ss(ssget"cp"lp flt))(if tf(command".zoom""p"))ss)(Defun lib::ssf(e0 flt / a a1 a2 dl e li lp lr p0 p1 r sl ss tfz)(if(null flt)(setq flt'((8 . "*"))))(setq dl(max(* 2 &sp)(* 0.2(getvar"ltscale"))))(if(="LINE"(&DRAG e0 0))(setq p0(&DRAG 10)p1(&DRAG 11)a(+(angle p0 p1)_pi2)lp(list(polar p0 a dl)(polar p1 a dl)(polar p1 a(- dl))(polar p0 a(- dl))))(setq p0(&DRAG 10)r(&DRAG 40)a1(&DRAG 50)a2(&DRAG 51)dl(min(* 0.2 r)dl)lp(append(lib::arpl p0(- r dl)a1 a2)(reverse(lib::arpl p0(+ r dl)a1 a2)))))(setq tfz(lib::zoomw &sp lp))(if(setq ss(ssget"cp"lp flt))(progn(ssdel e0 ss)(setq sl(sslength ss))(while(> sl 0)(setq sl(1- sl)e(ssname ss sl))(if(setq li(&ORDR 0 e e0))(setq lr(cons(cons e li)lr))))))(if tfz(command".zoom""p"))lr)(Defun lib::sslf(p1 p2 flt / e0 l)(lib::line p1 p2 nil)(setq e0(entlast)l(lib::ssf e0 flt))(entdel e0)l)(Defun lib::ssaf(pc r a1 a2 flt / e0 l)(lib::arc pc r a1 a2 nil)(setq e0(entlast)l(lib::ssf e0 flt))(entdel e0)l)(Defun lib::ssl(ss flt / ls)(setq ls(ssgetfirst))(sssetfirst ss ss)(setq ss(ssget"i"flt))(apply'sssetfirst ls)ss)(Defun ss::del(ss / e si)(setq si -1)(while(setq si(1+ si)e(ssname ss si))(entdel e)))(defun lib::substr(str beg len / ch)(if(and(= len 1)(>(ascii(substr str beg))159))(setq ch(substr str beg 2)Tsz_If_Unicode T)(setq ch(substr str beg len)Tsz_If_Unicode nil))ch)(defun lib::peronl(p0 p1 p2 / da db dx dy x0 x1 x2 y0 y1 y2)(if(or(equal p0 p1 1e-3)(equal p0 p2 1e-3))p0(progn(setq x0(car p0)x1(car p1)x2(car p2)y0(cadr p0)y1(cadr p1)y2(cadr p2)dx(- x2 x1)dy(- y2 y1)da(+(* dx dx)(* dy dy))db(+(* dx(- x0 x1))(* dy(- y0 y1)))da(/ db da))(list(+ x1(* dx da))(+ y1(* dy da))))))(defun lib::run_exe(st)(lib::LspBeg)(if(setq st(findfile st))(startapp st)(princ"\n**系统错误，无法找到相应资源!"))(&TSTY))(defun lib::GetGrps(e / dxf el grp l ll)(foreach dxf(entget e)(if(and(=(car dxf)330)(setq el(entget(cdr dxf)))(="GROUP"(strcase(cdr(assoc 0 el)))))(progn(setq l nil)(foreach grp el(if(=(car grp)340)(setq l(cons(cdr grp)l))))(setq ll(cons(cons(cdr dxf)l)ll)))))ll)(defun lib::rtxt(str ty / i len lnk st1 stn)(if(null ty)(setq ty 7))(if(or(and(lib::and ty 1)(wcmatch str"*[dDfF][1-9]*"))(and(lib::and ty 2)(wcmatch str"*[LHCI][1-9]*"))(and(lib::and ty 4)(wcmatch str"*#[@-][1-9]*")))(progn(setq lnk(if(zerop(&GSYS"钢筋间距符号"))"@""-")i 1 len(strlen str)stn"")(while(<= i len)(setq st1(substr str i))(cond((>(ascii st1)159)(setq st1(substr st1 1 2)i(1+ i)))((and(=(substr st1 1 1)"\\")(wcmatch(strcase(substr st1 2))"U+[0-9A-F][0-9A-F][0-9A-F][0-9A-F]*"))(setq st1(substr st1 1 7)i(+ i 6)))((wcmatch st1"%%[oudpcOUDPC%]*")(setq st1(substr st1 1 3)i(+ i 2)))((and(lib::and ty 1)(wcmatch st1"[dDfF][1-9]*"))(setq st1(substr st1 1 1)st1(cond((= st1"d")(&FLD"GJFH1"))((= st1"D")(&FLD"GJFH2"))((= st1"f")(&FLD"GJFH3"))((= st1"F")(&FLD"GJFH4")))))((and(lib::and ty 2)(wcmatch st1"[LHCI][1-9]*"))(setq st1(substr st1 1 1)st1(cond((= st1"L")(&FLD"XG2"))((= st1"H")(&FLD"XG4"))((= st1"C")(&FLD"XG5"))((= st1"I")(&FLD"XG3")))))((and(lib::and ty 4)(wcmatch st1"#[@-][1-9]*"))(setq st1(strcat(substr st1 1 1)lnk)i(1+ i)))(T(setq st1(substr st1 1 1))))(setq stn(strcat stn st1)i(1+ i)))(setq str stn)))str)(defun lib::gstr(key msg nam eget / e en el na str regex _rplc)(defun _rplc(sour targ)(vlax-put-property regex"Pattern"sour)(vlax-invoke-method regex"Replace"str targ))(setq nam(strcase nam)eget(if eget nentsel entsel))(while(and msg(progn(if key(initget key))t)(setq e(eget msg)))(if(listp e)(if(and(setq en(car(reverse(nth 3 e))))(setq el(entget en)el(member(assoc 8 el)el))(=(strcase(cdr(assoc 100 el)))"ACDBMINSERTBLOCK")(wcmatch(cdr(assoc 2 el))"`**"))(setq e(prompt"\n**不能编辑只读图形！！！")msg nil)(if(wcmatch(setq na(strcase(&DRAG(car e)0)))nam)(progn(setq msg nil)(cond((wcmatch na"TEXT,ATTRIB")(setq str(&DRAG 1)))((= na"ATTDEF")(setq str(&DRAG 2)))((= na"MTEXT")(setq regex(vlax-create-object"Vbscript.RegExp"))(vlax-put-property regex"IgnoreCase"0)(vlax-put-property regex"Global"1)(setq str(vla-get-textstring(vlax-ename->vla-object(car e)))str(_rplc"\\\\\\\\"(chr 1))str(_rplc"\\\\{"(chr 2))str(_rplc"\\\\}"(chr 3))str(_rplc"\\\\S(.[^;]*)(\\^|#|/)(.[^;]*);""")str(_rplc"\\\\(F|f|C|H|\T|Q|W|A|p)(.[^;]*);""")str(_rplc"\\\\(L|l|O|o|~|P)""")str(_rplc"\n""")str(_rplc"({|})""")str(_rplc"\\x01""\\")str(_rplc"\\x02""{")str(_rplc"\\x03""}"))(vlax-release-object regex))('T(setq e(prompt"\n(lib::gstr key msg **nam)参数出错！！！"))))(if(and e str)(setq e(append(list(&GENT str)na)e))))(princ"\n**没有选中指定实体，重新选择...")))(setq msg nil)))e)(defun lib::txt2lst(st0 / i j n ll sl so st1 su tf stll)(defun stll(st)(cons(strcat su so st so su)ll))(setq i 1 sl(strlen st0)su""so"")(if(> sl 1)(progn(while(< i sl)(setq st1(strcase(substr st0 i)))(cond((>(ascii(substr st0 i 1))159)(setq ll(stll(substr st0 i 2))i(+ 2 i)))((or(setq n(wcmatch st1"%%###*"))(and(=(substr st1 1 1)"\\")(wcmatch(substr st1 2)"U+[0-9A-F][0-9A-F][0-9A-F][0-9A-F]*")))(setq tf nil)(cond((wcmatch st1(strcat(&FLD"KZZF1")"*"))(setq j(vl-string-search(&FLD"KZZF2")st1)tf t))((wcmatch st1(strcat(&FLD"KZZF3")"*"))(setq j(vl-string-search(&FLD"KZZF4")st1)tf t))((wcmatch st1(strcat(&FLD"KZZF5")"*"))(setq j(vl-string-search(&FLD"KZZF6")st1)))((wcmatch st1(strcat(&FLD"KZZF6")"*"))(setq j(vl-string-search(&FLD"KZZF5")st1)))((wcmatch st1(strcat(&FLD"YQ1")"*"))(setq j(vl-string-search(&FLD"YQ2")st1)))((wcmatch st1(strcat(&FLD"YQ3")"*"))(setq j(vl-string-search(&FLD"YQ4")st1)))((wcmatch st1(strcat(&FLD"YQ5")"*"))(setq j(vl-string-search(&FLD"YQ6")st1)))(t(setq j -1)))(setq n(if n 5 7))(if(= j -1)(setq ll(stll(substr st0 i n))i(+ n i))(setq j(if j(+ j n)(- sl i -1))ll(if(and tf ll)(cons(@mrg2str(car ll)(strcat su so(substr st0 i j)so su))(cdr ll))(stll(substr st0 i j)))i(+ j i))))((wcmatch st1"%%[%DPC]*")(setq ll(stll(substr st0 i 3))i(+ 3 i)))((wcmatch st1"%%O*")(setq so(if(= so"")"%%O""")i(+ 3 i)))((wcmatch st1"%%U*")(setq su(if(= su"")"%%U""")i(+ 3 i)))(t(setq ll(stll(substr st0 i 1))i(1+ i)))))(if(= i sl)(setq ll(stll(substr st0 sl 1))))(setq ll(reverse ll)))(setq ll(list st0)))ll)(defun lib::mrg2str(st1 st2)(setq si1(strlen st1))(cond((and(wcmatch st1"*%%O%%U")(wcmatch st2"%%U%%O*"))(strcat(substr st1 1(- si1 6))(substr st2 7)))((and(wcmatch st1"*%%O")(wcmatch st2"%%U%%O*"))(strcat(substr st1 1(- si1 3))"%%U"(substr st2 7)))((and(wcmatch st1"*%%O%%U")(wcmatch st2"%%O*"))(strcat(substr st1 1(- si1 6))"%%U"(substr st2 4)))((or(and(wcmatch st1"*%%O")(wcmatch st2"%%O*"))(and(wcmatch st1"*%%U")(wcmatch st2"%%U*")))(strcat(substr st1 1(- si1 3))(substr st2 4)))('T(strcat st1 st2))))(defun lib::Hlt(e no / l1)(if(and(=(type e)'ENAME)(member no'(1 2 3 4)))(progn(redraw e no)(cond((= no 3)(if(listp le@Hlt)(if(not(member e le@Hlt))(setq le@Hlt(cons e le@Hlt)))(setq le@Hlt(list e))))((= no 4)(if(and(listp le@Hlt)(setq l1(member e le@Hlt)))(setq le@Hlt(append(reverse(cdr(member e(reverse le@Hlt))))(cdr l1))))))T)(princ"\n**【@Hlt(e no)】函数调用参数错误！")))(defun lib::eUpd(el lu / i l l1 ll x)(setq el(entget el))(foreach l lu(setq i(car l)l(cdr l))(if(assoc i el)(progn(setq ll el)(foreach x l(if(setq l1(assoc i ll))(setq el(subst(cons i x)l1 el)ll(cdr(member l1 ll))))))(setq el(append el(list(cons i(car l)))))))(entmod el))(defun Dcl::cls()(set_tile"error"""))(defun Dcl::isnum(n1 n2 tf / lab sg1 sg2 st1 st2 vl)(Dcl::cls)(if n1(if(=(type n1)'REAL)(setq sg1 >= st1"≥")(setq sg1 > st1"＞")))(if n2(if(=(type n2)'REAL)(setq sg2 <= st2"≤")(setq sg2 < st2"＜")))(if(wcmatch $value"[.]*")(setq $value(strcat"0"$value)))(if(and(=(setq vl((if tf atof atoi)$value))(read $value))(or(and(null n1)(null n2))(and n1(null n2)(sg1 vl n1))(and n2(null n1)(sg2 vl n2))(and n1 n2(sg1 vl n1)(sg2 vl n2))))(set(read $key)vl)(progn(setq lab(get_attr $key"label")lab(if(= lab"")"**该项值"(strcat"**["lab"]")))(set_tile"error"(cond((and(null n1)(null n2))(strcat lab"应为"(if tf"实""整")"数值!"))((and n1(null n2))(strcat lab"应"st1(&RTXT n1)"!"))((and n2(null n1))(strcat lab"应"st2(&RTXT n2)"!"))((and n1 n2)(strcat lab"应在"(&RTXT n1)"～"(&RTXT n2)"之间!"))))(set_tile $key(&RTXT(eval(read $key))))nil)))(Defun Dcl::nbox(key n1 n2 tf / cbf n2s)(Defun n2s(n / st)(setq st(if n(&RTXT n)"nil"))(if(and(=(type n)'REAL)(wcmatch st"~*.*"))(setq st(strcat st".")))st)(setq n1(n2s n1)n2(n2s n2)cbf(strcat"(Dcl::isnum "n1" "n2" "(if tf"T""nil")") (if #Dclcb (#Dclcb))"))(set_tile key(&RTXT(eval(read key))))(action_tile key cbf))(Defun Dcl::lrad(key lk)(set_tile key(eval(read key)))(foreach k lk(action_tile k"(set (read (substr $key 1 (1- (strlen $key)))) $key) (if #Dclcb (#Dclcb))")))(Defun Dcl::tile(key)(set_tile key(eval(read key)))(action_tile key"(set (read $key) $value) (if #Dclcb (#Dclcb))"))(defun Dcl::dis_list(key / l)(setq l(eval(read key)))(start_list key)(mapcar'add_list l)(end_list)(if l(progn(set_tile key(eval(read(strcat"n"key))))(mode_tile key 2))))(Defun Dcl::lbox(key)(Dcl::dis_list key)(action_tile key"(set (read (strcat \"n\" $key)) $value) (if #Dclcb (#Dclcb))"))(defun Dcl::apd_list(key new / l pos)(setq pos(1+(atoi(eval(read(strcat"n"key)))))l(eval(read key))l(l_anth l pos new))(if(=(length l)pos)(setq pos(1- pos)))(set(read key)l)(set(read(strcat"n"key))(itoa pos))(Dcl::dis_list key))(defun Dcl::del_list(key / l pos)(if(setq l(eval(read key)))(progn(setq pos(atoi(eval(read(strcat"n"key))))l(l_rnth l pos)pos(cond((< pos 1)0)((= pos(length l))(1- pos))(pos)))(set(read key)l)(set(read(strcat"n"key))(itoa pos))(Dcl::dis_list key))))(defun Dcl::cln_list(key)(set(read key)nil)(set(read(strcat"n"key))"0")(Dcl::dis_list key))(defun Dcl::rpc_list(key new / l pos)(if(setq l(eval(read key)))(progn(setq pos(atoi(eval(read(strcat"n"key))))l(l_SNth l pos new))(set(read key)l)(Dcl::dis_list key))))(defun Dcl::fimg(key val / x y val)(setq x(dimx_tile key)y(dimy_tile key))(start_image key)(cond((numberp val)(fill_image 0 0 x y val))((='STR(type val))(slide_image 0 0 x y val))(T(fill_image 0 0 x y -2)))(end_image))(Defun Dcl::cross(p0 ax d co / p1 p2 p3 p4)(lib::lset'(p1 p2 p3 p4)(lib::lncp p0 ax d d))(vector_image(fix(car p1))(fix(cadr p1))(fix(car p3))(fix(cadr p3))co)(vector_image(fix(car p2))(fix(cadr p2))(fix(car p4))(fix(cadr p4))co))(defun Dcl::rwdata(_#fn _#l _#tf / _#l1 _#x _#x1 _#tf1)(setq _#tf1(wcmatch _#fn"*`.*"))(if(and(if(and(null _#tf1)(null(wcmatch _#fn"*/*")))(prompt(strcat"\n***[Dcl::rwdata]中["_#fn"]的格式不对！"))T)(if(=(rem(length _#l)2)1)(prompt"\n***[Dcl::rwdata]输入列表长度为单数！")T))(progn(if(and _#tf1(null(wcmatch _#fn"*/*")))(setq _#fn(strcat(&SGET)"prg\\"_#fn)))(while _#l(if(=(type(setq _#x(car _#l)))'STR)(setq _#x(strcase _#x t)_#x1(if _#tf(cadr _#l)(eval(read _#x)))_#l1(cons(cons _#x _#x1)_#l1)_#l(cddr _#l))(progn(princ"**\n[")(princ _#x)(princ"]索引项应该为字符型！")(setq _#l nil))))(setq _#l(reverse _#l1)_#l1 nil)(if _#tf(progn(if _#tf1(if(setq _#fn(open _#fn"r"))(progn(setq _#l1(read(read-line _#fn)))(close _#fn)))(setq _#l1(read(&GPTS _#fn))))(foreach _#x _#l(if(setq _#x1(assoc(car _#x)_#l1))(setq _#l(subst _#x1 _#x _#l)_#x _#x1))(if(/= _#tf 0)(set(read(car _#x))(cdr _#x)))))(if _#tf1(if(setq _#fn(open _#fn"w"))(progn(prin1 _#l _#fn)(close _#fn)))(progn(setq _#x(vl-prin1-to-string _#l))(&GLAY _#fn _#x))))_#l)))