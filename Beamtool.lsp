(lib::lsp "MyFan.lsp")
(lib::lsp "tszlib.lsp")


(setfunhelp "c:Lxbl" "Tssd" "lxbl")
(defun c:Lxbl (/ tran txt lay1 lay2 lay3 p1 p2 p3 p4 i szl scl szz flag ang e el l py 
               py1 py2 pl1 zoom pl2 tpl1 tpl2 str1 str2 st1 st2 ss lk op2 y_n pl
              ) 
  (defun tran (p an / dis ka p_x p_y px py t_a) 
    (setq px (car p)
          py (cadr p)
    )
    (cond 
      ((equal an _pi2 0.001)
       (setq p_x py
             p_y (* -1 px)
       )
      )
      ((equal an pi 0.001)
       (setq p_x (* -1 px)
             p_y (* -1 py)
       )
      )
      ((equal an (* 1.5 pi) 0.001)
       (setq p_x (* -1 py)
             p_y px
       )
      )
      (T
       (setq dis (sqrt (+ (* px px) (* py py)))
             ka  (atan (/ py px))
       )
       (cond 
         ((and (< px 0) (> py 0)) (setq ka (+ pi ka)))
         ((and (< px 0) (< py 0)) (setq ka (+ pi ka)))
         ((and (> px 0) (< py 0)) (setq ka (+ (* 2 pi) ka)))
       )
       (setq t_a (- ka an)
             p_x (* dis (cos t_a))
             p_y (* dis (sin t_a))
       )
      )
    )
    (list p_x p_y (caddr p))
  )
  (defun txt (pl tpl lay no cl / pts find find1 find2 tp l p p1 pt pt1 pt2 zg an ang1 
              ang an1 zom
             ) 
    (defun zom (pt / p1 p2 x1 x2 y1 y2 xy xmin xmax ymin ymax ptzoom ptmin ptmax) 
      (setq p1    (@wcs (getvar "viewctr"))
            x1    (car p1)
            y1    (cadr p1)
            y2    (/ (getvar "viewsize") 2)
            p1    (@wcs (getvar "vsmin"))
            p2    (@wcs (getvar "vsmax"))
            p2    (mapcar '- p2 p1)
            xy    (/ (car p2) (cadr p2))
            x2    (* y2 xy)
            xmin  (- x1 x2)
            xmax  (+ x1 x2)
            ymin  (- y1 y2)
            ymax  (+ y1 y2)
            ptmin (@ucs (list xmin ymin))
            ptmax (@ucs (list xmax ymax))
      )
      (setq pt (@wcs pt))
      (if (<= (car pt) xmin) 
        (setq ptmin  (list (car pt) (cadr ptmin) 0)
              ptzoom 1
        )
      )
      (if (<= (cadr pt) ymin) 
        (setq ptmin  (list (car ptmin) (cadr pt) 0)
              ptzoom 1
        )
      )
      (if (>= (car pt) xmax) 
        (setq ptmax  (list (car pt) (cadr ptmax) 0)
              ptzoom 1
        )
      )
      (if (>= (cadr pt) ymax) 
        (setq ptmax  (list (car ptmax) (cadr pt) 0)
              ptzoom 1
        )
      )
      (if (= ptzoom 1) 
        (progn 
          (setq zoom  1
                ptmin (polar ptmin (* 1.25 pi) (* 2 &sp))
                ptmax (polar ptmax (* 0.25 pi) (* 2 &sp))
          )
          (command ".zoom" "w" ptmin ptmax)
        )
      )
    )
    (defun pts (pt / s1 p0 p1 p2 p3 l what) 
      (setq p0 (polar pt (* 0.25 pi) (* 0.5 &sp))
            p1 (polar pt (* 0.75 pi) (* 0.5 &sp))
            p2 (polar pt (* 1.25 pi) (* 0.5 &sp))
            p3 (polar pt (* 1.75 pi) (* 0.5 &sp))
            s1 (ssget 
                 "cp"
                 (list p0 p1 p2 p3)
                 (list (cons 0 "LINE,LWPOLYLINE") (cons 8 lay))
               )
      )
      (if (wcmatch lay (strcase (&LJIG "平面柱子"))) 
        (if s1 
          (if (>= (sslength s1) 1) (setq what T) (setq what nil))
          (setq what nil)
        )
        (if (= no 0) 
          (if s1 
            (if (>= (sslength s1) 1) (setq what T) (setq what nil))
            (setq what nil)
          )
          (if s1 
            (if (> (sslength s1) 1) (setq what T) (setq what nil))
            (setq what nil)
          )
        )
      )
      (if what (setq flag what))
      what
    )
    (defun find (str p0 / d p1 p2 p3 p4 s) 
      (while s 
        (setq d  (caadr (textbox (list (cons 1 str))))
              p1 (polar p0 (+ ang pi) (* 0.5 d))
              p2 (polar p0 ang (* 0.5 d))
              p3 (polar p2 (- ang _pi2) zg)
              p4 (polar p1 (- ang _pi2) zg)
        )
        (setq s (ssget "cp" (list p1 p2 p3 p4)))
        (if s (setq p0 (polar p0 ang (* 0.1 zg))))
      )
      (if 
        (or 
          (and (> ang (* 0.25 pi)) (< ang (* 0.75 pi)))
          (and (> ang (* 1.25 pi)) (< ang (* 1.75 pi)))
        )
        (&LJIG "平面主梁竖直原位标" T)
        (&LJIG "平面主梁水平原位标" T)
      )
      (command ".text" "J" "TC" p0 zg (/ (* 180 ang) pi) str)
    )
    (defun find1 (str p0 / d p1 p2 p3 p4 s) 
      (while s 
        (setq d  (caadr (textbox (list (cons 1 str))))
              p1 (polar p0 ang d)
              p2 (polar p1 (+ ang _pi2) zg)
              p3 (polar p0 (+ ang _pi2) zg)
              s  (ssget "cp" (list p0 p1 p2 p3))
        )
        (if s (setq p0 (polar p0 ang (* 0.1 zg))))
      )
      (if 
        (or 
          (and (> ang (* 0.25 pi)) (< ang (* 0.75 pi)))
          (and (> ang (* 1.25 pi)) (< ang (* 1.75 pi)))
        )
        (&LJIG "平面主梁竖直原位标" T)
        (&LJIG "平面主梁水平原位标" T)
      )
      (command ".text" p0 zg (/ (* 180 ang) pi) str)
    )
    (defun find2 (str p0 / d p1 p2 p3 p4 s) 
      (while s 
        (setq d  (caadr (textbox (list (cons 1 str))))
              p1 (polar p0 (+ ang pi) d)
              p2 (polar p1 (+ ang _pi2) zg)
              p3 (polar p0 (+ ang _pi2) zg)
              s  (ssget "cp" (list p0 p1 p2 p3))
        )
        (if s (setq p0 (polar p0 (+ ang pi) (* 0.1 zg))))
      )
      (if 
        (or 
          (and (> ang (* 0.25 pi)) (< ang (* 0.75 pi)))
          (and (> ang (* 1.25 pi)) (< ang (* 1.75 pi)))
        )
        (&LJIG "平面主梁竖直原位标" T)
        (&LJIG "平面主梁水平原位标" T)
      )
      (command ".text" "J" "BR" p0 zg (/ (* 180 ang) pi) str)
    )
    (setq tp (@ran4 tpl)
          l  (length tpl)
          zg (&INTS "钢筋文字")
    )
    (while (setq p (car tp)) 
      (setq p1   (cadr tp)
            tp   (cddr tp)
            pt   (nth (- l (length (member p tpl))) pl)
            pt1  (nth (- l (length (member p1 tpl))) pl)
            ang  (angle pt pt1)
            ang1 (+ ang (* 0.25 pi))
            an   (angle pt1 pt)
            an1  (- an (* 0.25 pi))
      )
      (if (= cl 1) 
        (progn 
          (setq cl  8
                pt2 pt
          )
          (find1 str1 (polar pt ang1 (* 0.45 zg)))
        )
        (progn 
          (if (pts pt) 
            (progn 
              (if pt2 
                (find 
                  str2
                  (polar (&N2S pt pt2) (- ang _pi2) (+ py (/ zg 3)))
                )
              )
              (setq pt2 pt)
              (find1 str1 (polar pt ang1 (* 0.45 zg)))
            )
          )
          (if (not tp) 
            (progn 
              (if (= cl 8) 
                (find2 str1 (polar pt1 an1 (* 0.45 zg)))
                (if (pts pt1) (find2 str1 (polar pt1 an1 (* 0.45 zg))))
              )
              (if pt2 
                (find 
                  str2
                  (polar (&N2S pt1 pt2) (- ang _pi2) (+ py (/ zg 3)))
                )
              )
            )
          )
        )
      )
    )
  )
  (defun y_n (ss / l e el p1 p2 aa aaa) 
    (if ss 
      (progn 
        (setq l (sslength ss))
        (while (> l 0) 
          (setq l  (1- l)
                e  (ssname ss l)
                p1 (&DRAG e 10)
                p2 (&DRAG e 11)
                aa (angle p1 p2)
          )
          (if (> aa pi) (setq aa (- aa pi)))
          (if (equal aa pi 0.01) (setq aa 0))
          (if (not aaa) (setq aaa aa))
          (if (not (equal aa aaa 0.01)) 
            (progn (prompt "\n选择的不是一根梁线?!!") 
                   (setq ss nil
                         l  0
                   )
            )
          )
        )
      )
    )
    ss
  )
  (if (< (&UTXT) 0) (exit))
  (setq i    0
        lay1 (strcase (&LJIG "平面主梁,平面主梁实线"))
        lay2 (strcase (&LJIG "平面次梁,平面次梁实线"))
        lay3 (strcase (&LJIG "平面柱子,平面柱子粗线,平面柱子虚线,平面柱子粗虚线"))
        st1  (&GPTS "Tssd/Dcl_Hzh/Beam/str1")
        st2  (&GPTS "Tssd/Dcl_Hzh/Beam/str2")
        pl   1
  )
  (if (or (not st1) (wcmatch st1 "")) (setq st1 "4D20"))
  (if (or (not st2) (wcmatch st2 "")) (setq st2 "4D20"))
  (while pl 
    (setq pl   nil
          pl1  nil
          pl2  nil
          tpl1 nil
          tpl2 nil
          flag nil
    )
    (initget "M")
    (setq p1 (&OSNP "\n用窗选的方法选取一根要标注的梁线，指定窗口的第一角点或 [三点框选(M)]<退出>: "))
    (if (= p1 "M") 
      (setq pl (cadr (@sget "LINE" lay1 "wp" T)))
      (if p1 
        (progn 
          (setq p2 (&OSNP p1 "\n另一角点<退出>: " T))
          (if p2 
            (setq p3 p2
                  p2 (@ucs (list (car (@wcs p3)) (cadr (@wcs p1))))
                  p4 (@ucs (list (car (@wcs p1)) (cadr (@wcs p3))))
                  pl (list p1 p2 p3 p4)
            )
          )
        )
      )
    )
    (if pl 
      (progn 
        (setq zoom (@zoome &sp pl)
              szl  (y_n 
                     (ssget "wp" pl (list (cons 0 "LINE") (cons 8 lay1)))
                   )
              scl  (y_n 
                     (ssget "wp" pl (list (cons 0 "LINE") (cons 8 lay2)))
                   )
        )
        (if (or szl scl) 
          (progn 
            (prompt "\n钢筋直径助记符：d=HPB300 D=HRB335 f=HRB400 F=HRB500。")
            (setq str1 (getstring T (strcat "\n输入支座负筋<" st1 ">: "))
                  str2 (getstring T (strcat "\n输入跨中钢筋<" st2 ">: "))
            )
            (if (wcmatch str1 "") (setq str1 st1))
            (if (wcmatch str2 "") (setq str2 st2))
            (&GLAY "Tssd/Dcl_Hzh/Beam/str1" str1)
            (&GLAY "Tssd/Dcl_Hzh/Beam/str2" str2)
            (setq st1  str1
                  st2  str2
                  str1 (@rtxt str1)
                  str2 (@rtxt str2)
            )
            (if szl 
              (progn 
                (setq l  (sslength szl)
                      py nil
                )
                (while (> l 0) 
                  (setq e   (ssname szl (1- l))
                        el  (entget e)
                        p1  (&DRAG e 10)
                        p2  (&DRAG e 11)
                        ang (angle p1 p2)
                        l   (1- l)
                  )
                  (if 
                    (and 
                      (> ang (+ (/ (* 2 pi) 3) 0.005))
                      (< ang (+ (/ (* 5 pi) 3) 0.005))
                    )
                    (setq ang (- ang pi))
                  )
                  (setq p3 (tran p1 ang)
                        p4 (tran p2 ang)
                  )
                  (if (not py) (setq py (cadr p3)))
                  (if (equal py (cadr p3) 0.01) 
                    (setq pl1  (append pl1 (list p1 p2))
                          tpl1 (append tpl1 (list p3 p4))
                    )
                    (setq pl2  (append pl2 (list p1 p2))
                          tpl2 (append tpl2 (list p3 p4))
                    )
                  )
                )
                (setq py1 (cadar tpl1)
                      py2 (cadar tpl2)
                      py  (abs (- py1 py2))
                )
                (if (> py1 py2) 
                  (txt 
                    pl1
                    tpl1
                    (strcat (&LJIG "平面砼墙,平面砼墙虚线") "," lay3)
                    0
                    0
                  )
                  (txt 
                    pl2
                    tpl2
                    (strcat (&LJIG "平面砼墙,平面砼墙虚线") "," lay3)
                    0
                    0
                  )
                )
                (if (not flag) 
                  (if (> py1 py2) 
                    (txt pl1 tpl1 lay1 1 0)
                    (txt pl2 tpl2 lay1 1 0)
                  )
                )
              )
              (if scl 
                (progn 
                  (setq l  (sslength scl)
                        py nil
                  )
                  (while (> l 0) 
                    (setq e   (ssname scl (1- l))
                          el  (entget e)
                          p1  (&DRAG e 10)
                          p2  (&DRAG e 11)
                          ang (angle p1 p2)
                          l   (1- l)
                    )
                    (if 
                      (and 
                        (> ang (+ (/ (* 2 pi) 3) 0.005))
                        (< ang (+ (/ (* 5 pi) 3) 0.005))
                      )
                      (setq ang (- ang pi))
                    )
                    (setq p3 (tran p1 ang)
                          p4 (tran p2 ang)
                    )
                    (if (not py) (setq py (cadr p3)))
                    (if (equal py (cadr p3) 0.01) 
                      (setq pl1  (append pl1 (list p1 p2))
                            tpl1 (append tpl1 (list p3 p4))
                      )
                      (setq pl2  (append pl2 (list p1 p2))
                            tpl2 (append tpl2 (list p3 p4))
                      )
                    )
                  )
                  (setq py1 (cadar tpl1)
                        py2 (cadar tpl2)
                        py  (abs (- py1 py2))
                  )
                  (if (> py1 py2) 
                    (txt pl1 tpl1 lay1 0 0)
                    (txt pl2 tpl2 lay1 0 0)
                  )
                  (if (not flag) 
                    (if (> py1 py2) 
                      (txt pl1 tpl1 lay2 1 0)
                      (txt pl2 tpl2 lay2 1 0)
                    )
                  )
                )
              )
            )
            (if zoom (command ".zoom" "p"))
          )
        )
      )
    )
  )
  (&TSTY)
)




(setfunhelp "c:Cshxl" "Tssd" "cshxl")
(defun c:Cshxl (/ an1 an2 ang ang1 ang2 c1 c2 cen e e1 e1l e2 e2l el en en_l enl fl1 
                fl2 flag i vct vsz devs la la1 lay p p0 p1 p10 p11 p2 p3 p4 pl pmid 
                pp10 pp11 qi r r1 r2 s s1 s2 s3 zoom s4 ss wallwid zh pts emk emka 
                emkar emkarc del int mid ints pp lt len ptl jion zom txy
               ) 
  (defun zom (pt / p1 p2 x1 x2 y1 y2 xy xmin xmax ymin ymax ptzoom ptmin ptmax) 
    (setq p1    (@wcs (getvar "viewctr"))
          x1    (car p1)
          y1    (cadr p1)
          y2    (/ (getvar "viewsize") 2)
          p1    (@wcs (getvar "vsmin"))
          p2    (@wcs (getvar "vsmax"))
          p2    (mapcar '- p2 p1)
          xy    (/ (car p2) (cadr p2))
          x2    (* y2 xy)
          xmin  (- x1 x2)
          xmax  (+ x1 x2)
          ymin  (- y1 y2)
          ymax  (+ y1 y2)
          ptmin (@ucs (list xmin ymin))
          ptmax (@ucs (list xmax ymax))
    )
    (setq pt (@wcs pt))
    (if (<= (car pt) xmin) 
      (setq ptmin  (list (car pt) (cadr ptmin) 0)
            ptzoom 1
      )
    )
    (if (<= (cadr pt) ymin) 
      (setq ptmin  (list (car ptmin) (cadr pt) 0)
            ptzoom 1
      )
    )
    (if (>= (car pt) xmax) 
      (setq ptmax  (list (car pt) (cadr ptmax) 0)
            ptzoom 1
      )
    )
    (if (>= (cadr pt) ymax) 
      (setq ptmax  (list (car ptmax) (cadr pt) 0)
            ptzoom 1
      )
    )
    (if (= ptzoom 1) 
      (progn 
        (setq zoom  1
              ptmin (polar ptmin (* 1.25 pi) (* 2 &sp))
              ptmax (polar ptmax (* 0.25 pi) (* 2 &sp))
        )
        (command ".zoom" "w" ptmin ptmax)
      )
    )
  )
  (defun pts (pt / e l p0 p1 p2 p3 s) 
    (zom pt)
    (setq p0 (polar pt (* 0.25 pi) &sp)
          p1 (polar pt (* 0.75 pi) &sp)
          p2 (polar pt (* 1.25 pi) &sp)
          p3 (polar pt (* 1.75 pi) &sp)
          s  (ssget 
               "cp"
               (list p0 p1 p2 p3)
               (list (cons 0 "LINE,ARC") (cons 8 la))
             )
    )
    (if s 
      (progn 
        (setq l (sslength s))
        (while (> l 0) 
          (setq e (ssname s (1- l))
                l (1- l)
          )
          (if (ssmemb e ss) (ssdel e s))
        )
      )
      (setq s (ssadd))
    )
    s
  )
  (defun emk (p0 p1 enl / el) 
    (setq el (subst (cons 10 (@wcs p0)) (assoc 10 enl) enl)
          el (subst (cons 11 (@wcs p1)) (assoc 11 el) el)
    )
    (entmake el)
  )
  (defun emka (qi zh enl / el) 
    (setq el (subst (cons 50 (@wcs qi)) (assoc 50 enl) enl)
          el (subst (cons 51 (@wcs zh)) (assoc 51 el) el)
    )
    (entmake el)
  )
  (defun emkar (qi zh an enl / dan da1 da2 el) 
    (setq dan (- zh qi)
          da1 (- zh an)
          da2 (- qi an)
          da3 (- an qi)
    )
    (if (< dan 0) (setq dan (+ dan (* 2 pi))))
    (if (< da1 0) (setq da1 (+ da1 (* 2 pi))))
    (if (< da2 0) (setq da2 (+ da2 (* 2 pi))))
    (if (< da3 0) (setq da3 (+ da3 (* 2 pi))))
    (if (> dan da1) 
      (if (> da1 da3) 
        (setq el (subst (cons 50 (@wcs an)) (assoc 50 enl) enl)
              el (subst (cons 51 (@wcs zh)) (assoc 51 el) el)
        )
        (setq el (subst (cons 50 (@wcs qi)) (assoc 50 enl) enl)
              el (subst (cons 51 (@wcs an)) (assoc 51 el) el)
        )
      )
      (setq el (subst (cons 50 (@wcs an)) (assoc 50 enl) enl)
            el (subst (cons 51 (@wcs zh)) (assoc 51 el) el)
      )
    )
    (entmake el)
  )
  (defun emkarc (qi1 zh1 qi2 zh2 enl / el da1 da2) 
    (setq da1 (- zh2 qi1)
          da2 (- zh1 qi2)
    )
    (if (< da1 0) (setq da1 (+ da1 (* 2 pi))))
    (if (< da2 0) (setq da2 (+ da2 (* 2 pi))))
    (if (< da1 da2) 
      (setq el (subst (cons 50 (@wcs qi1)) (assoc 50 enl) enl)
            el (subst (cons 51 (@wcs zh2)) (assoc 51 el) el)
      )
      (setq el (subst (cons 50 (@wcs qi2)) (assoc 50 enl) enl)
            el (subst (cons 51 (@wcs zh1)) (assoc 51 el) el)
      )
    )
    (entmake el)
  )
  (defun del (l / i) 
    (setq i 0)
    (while (< i (length l)) 
      (entdel (nth i l))
      (setq i (1+ i))
    )
  )
  (defun txy (/ po1 po2 po3 po4 dpo1 dpo2 dpo3 dpo4 apo) 
    (setq po1  (polar c1 (&DRAG e1 50) r1)
          po2  (polar c1 (&DRAG e1 51) r1)
          po3  (polar c1 (&DRAG e2 50) r1)
          po4  (polar c1 (&DRAG e2 51) r1)
          dpo1 (distance po1 po3)
          dpo2 (distance po1 po4)
          dpo3 (distance po2 po3)
          dpo4 (distance po2 po4)
    )
    (cond 
      ((= dpo1 (min dpo1 dpo2 dpo3 dpo4))
       (setq apo (angle c1 (&N2S po1 po3)))
       (emka apo (&DRAG e1 51) e1l)
       (emka apo (&DRAG e2 51) e2l)
       (@line 
         (polar c1 apo r1)
         (polar c1 apo r2)
         (cdr (assoc 8 e1l))
       )
      )
      ((= dpo2 (min dpo1 dpo2 dpo3 dpo4))
       (setq apo (angle c1 (&N2S po1 po4)))
       (emka apo (&DRAG e1 51) e1l)
       (emka (&DRAG e2 50) apo e2l)
       (@line 
         (polar c1 apo r1)
         (polar c1 apo r2)
         (cdr (assoc 8 e1l))
       )
      )
      ((= dpo3 (min dpo1 dpo2 dpo3 dpo4))
       (setq apo (angle c1 (&N2S po1 po3)))
       (emka (&DRAG e1 50) apo e1l)
       (emka apo (&DRAG e2 51) e2l)
       (@line 
         (polar c1 apo r1)
         (polar c1 apo r2)
         (cdr (assoc 8 e1l))
       )
      )
      ((= dpo4 (min dpo1 dpo2 dpo3 dpo4))
       (setq apo (angle c1 (&N2S po1 po3)))
       (emka (&DRAG e1 50) apo e1l)
       (emka (&DRAG e2 50) apo e2l)
       (@line 
         (polar c1 apo r1)
         (polar c1 apo r2)
         (cdr (assoc 8 e1l))
       )
      )
    )
  )
  (defun int (p0 p1 p2 p3 l1 l2 / p pp pp1 pp3 p4 p5 p6 p7 dis a1 a2) 
    (setq dis (* 2 (distance p1 p3))
          p4  (polar p1 (+ (angle p0 p1) _pi2) dis)
          p5  (polar p1 (- (angle p0 p1) _pi2) dis)
          p6  (polar p3 (+ (angle p2 p3) _pi2) dis)
          p7  (polar p3 (- (angle p2 p3) _pi2) dis)
          p   (inters p0 p1 p6 p7 nil)
          pp  (inters p2 p3 p4 p5 nil)
          a1  (angle p0 p1)
          a2  (angle p1 p)
    )
    (if (equal a1 (* 2 pi) 0.01) (setq a1 0.))
    (if (equal a2 (* 2 pi) 0.01) (setq a2 0.))
    (if (equal a1 a2 0.01) 
      (progn (emk p0 p l1) (emk p p3 l1) (emk p2 p3 l2))
      (progn (emk p0 p1 l1) (emk p1 pp l1) (emk p2 pp l2))
    )
  )
  (defun mid (p0 p1 p2 p3 l1 l2 / a a1 p pp) 
    (setq a  (angle p0 p1)
          a1 (+ a _pi2)
          p  (&N2S p1 p2)
          pp (polar p a1 wallwid)
          p1 (inters p0 p1 p pp nil)
          p2 (inters p2 p3 p pp nil)
    )
    (emk p0 p1 l1)
    (emk p2 p3 l2)
    (emk p1 p2 l1)
  )
  (defun jion (pl / jionbeam p1 l p od pl1 p2 d) 
    (defun jionbeam (pt1 pt2 / s1 p0 p1 p2 p3 s1 e1 e2 e1l e2l fl1 fl2 an1 an2 pt) 
      (setq p0   (polar pt1 (* 0.25 pi) (* 0.1 &sp))
            p1   (polar pt1 (* 0.75 pi) (* 0.1 &sp))
            p2   (polar pt1 (* 1.25 pi) (* 0.1 &sp))
            p3   (polar pt1 (* 1.75 pi) (* 0.1 &sp))
            s1   (ssget 
                   "cp"
                   (list p0 p1 p2 p3)
                   (list (cons 0 "LINE,ARC") (cons 8 lay))
                 )
            e1   (ssname s1 0)
            e1l  (entget e1)
            fl1  (strcase (cdr (assoc 0 e1l)))
            lay1 (strcase (cdr (assoc 8 e1l)))
            p0   (polar pt2 (* 0.25 pi) (* 0.1 &sp))
            p1   (polar pt2 (* 0.75 pi) (* 0.1 &sp))
            p2   (polar pt2 (* 1.25 pi) (* 0.1 &sp))
            p3   (polar pt2 (* 1.75 pi) (* 0.1 &sp))
            s1   (ssget 
                   "cp"
                   (list p0 p1 p2 p3)
                   (list (cons 0 "LINE,ARC") (cons 8 lay))
                 )
            e2   (ssname s1 0)
            e2l  (entget e2)
            fl2  (strcase (cdr (assoc 0 e2l)))
            lay2 (strcase (cdr (assoc 8 e2l)))
      )
      (if (and (wcmatch fl1 fl2) (wcmatch lay1 lay2)) 
        (if (wcmatch fl1 "LINE") 
          (progn 
            (setq p1  (&DRAG e1 10)
                  p2  (&DRAG e1 11)
                  an1 (angle p1 p2)
                  p3  (&DRAG e2 10)
                  p4  (&DRAG e2 11)
                  an2 (angle p3 p4)
            )
            (if (equal an1 (* 2 pi) 0.01) (setq an1 0.))
            (if (equal an2 (* 2 pi) 0.01) (setq an2 0.))
            (if (>= an1 pi) (setq an1 (- an1 pi)))
            (if (>= an2 pi) (setq an2 (- an2 pi)))
            (if (equal an1 pi 0.01) (setq an1 0.))
            (if (equal an2 pi 0.01) (setq an2 0.))
            (if (equal an1 an2 0.01) 
              (cond 
                ((and (equal pt1 p1 1.) (equal pt2 p3 1.))
                 (del (list e1 e2))
                 (int p2 p1 p4 p3 e1l e2l)
                )
                ((and (equal pt1 p1 1.) (equal pt2 p4 1.))
                 (del (list e1 e2))
                 (int p2 p1 p3 p4 e1l e2l)
                )
                ((and (equal pt1 p2 1.) (equal pt2 p3 1.))
                 (del (list e1 e2))
                 (int p1 p2 p4 p3 e1l e2l)
                )
                ((and (equal pt1 p2 1.) (equal pt2 p4 1.))
                 (del (list e1 e2))
                 (int p1 p2 p3 p4 e1l e2l)
                )
              )
              (progn 
                (setq pt (inters p1 p2 p3 p4 nil))
                (if (equal pt1 p1 1.) 
                  (progn (entdel e1) (emk p2 pt e1l))
                  (progn (entdel e1) (emk p1 pt e1l))
                )
                (if (equal pt2 p3 1.) 
                  (progn (entdel e2) (emk p4 pt e2l))
                  (progn (entdel e2) (emk p3 pt e2l))
                )
              )
            )
            (if (wcmatch fl1 "ARC") 
              (progn 
                (setq p1 (&DRAG e1 10)
                      r1 (&DRAG e1 40)
                      p2 (&DRAG e2 10)
                      r2 (&DRAG e2 40)
                )
                (if (equal p1 p2 1.0) 
                  (progn 
                    (if (equal r1 r2 0.1) 
                      (progn 
                        (setq an1 (angle p1 (&N2S pt1 pt2))
                              p0  (polar p1 an1 r1)
                        )
                        (command ".arc" pt1 p0 pt2)
                        (setq e2  (entlast)
                              e2l (entget e2)
                              e2l (subst (cons 8 lay1) (assoc 8 e2l) e2l)
                        )
                        (entdel e2)
                        (entmake e2l)
                      )
                      (@line pt1 pt2 lay1)
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    (while (setq p1 (car pl)) 
      (setq pl  (cdr pl)
            l   (length pl)
            p   nil
            od  (* 100 wallwid)
            pl1 nil
      )
      (while (> l 0) 
        (setq p2 (nth (1- l) pl)
              d  (distance p1 p2)
              l  (1- l)
        )
        (if (< d od) 
          (progn 
            (if p (setq pl1 (append pl1 (list p))))
            (setq p  p2
                  od d
            )
          )
          (setq pl1 (append pl1 (list p2)))
        )
      )
      (if p (jionbeam p p1))
      (setq pl pl1)
    )
  )
  (defun devs (s / l e s1 px py a a1) 
    (setq l  (sslength s)
          l  (1- l)
          s1 (ssadd)
          s1 (ssadd en s1)
    )
    (while (setq e (ssname s l)) 
      (setq px (&DRAG e 10)
            py (&DRAG 11)
            a  (angle px py)
            a1 (angle py px)
            l  (1- l)
      )
      (if (or (equal ang a 0.01) (equal ang a1 0.01)) 
        (ssadd e s1)
      )
    )
    s1
  )
  (if (< (&UTXT) 0) (exit))
  (setq lay     (strcase (&LJIG "平面主梁,平面主梁实线,平面次梁,平面次梁实线"))
        wallwid (* &sc 1500)
        i       0
        lt      (getvar "ltscale")
        ss      (&DSTR 
                  "\n选择要擦除梁线<退出>: "
                  (list (cons 0 "LINE,ARC") (cons 8 lay))
                )
        vct     (getvar "viewctr")
        vsz     (getvar "viewsize")
  )
  (if ss 
    (progn 
      (command ".change" ss "" "P" "lt" "Continuous" "")
      (while (setq en (ssname ss i)) 
        (setq enl  (entget en)
              flag (strcase (cdr (assoc 0 enl)))
              la   (strcase (cdr (assoc 8 enl)))
              la   (cond 
                     ((wcmatch la (setq la1 (&LJIG "平面主梁,平面主梁实线"))) la1)
                     ((wcmatch la (setq la1 (&LJIG "平面次梁,平面次梁实线"))) la1)
                   )
        )
        (if (wcmatch flag "LINE") 
          (progn 
            (setq p10  (&DRAG en 10)
                  p11  (&DRAG en 11)
                  ang  (angle p10 p11)
                  pmid (&N2S p10 p11)
                  p1   (polar pmid (+ ang _pi2) wallwid)
                  p2   (polar pmid (- ang _pi2) wallwid)
            )
            (zom p10)
            (zom p11)
            (setq s (ssget 
                      "f"
                      (list p1 p2)
                      (list (cons 0 "LINE") (cons 8 la))
                    )
            )
            (if s 
              (setq s   (devs s)
                    len (sslength s)
              )
            )
            (if (or (/= len 2) (not s)) 
              (setq pmid (&N2S p10 pmid)
                    p1   (polar pmid (+ ang _pi2) wallwid)
                    p2   (polar pmid (- ang _pi2) wallwid)
                    s    (ssget 
                           "f"
                           (list p1 p2)
                           (list (cons 0 "LINE") (cons 8 la))
                         )
              )
            )
          )
          (progn 
            (setq cen  (&DRAG en 10)
                  r    (&DRAG en 40)
                  qi   (&DRAG en 50)
                  zh   (&DRAG en 51)
                  p10  (polar cen qi r)
                  p11  (polar cen zh r)
                  pl   (@arpl cen r qi zh)
                  pmid (nth (fix (/ (length pl) 2)) pl)
                  p1   (polar pmid (angle cen pmid) wallwid)
                  p2   (polar pmid (angle pmid cen) wallwid)
            )
            (zom p1)
            (zom p2)
            (setq s (ssget 
                      "f"
                      (list p1 p2)
                      (list (cons 0 "ARC") (cons 8 la))
                    )
            )
            (if (not s) (setq s (ssadd)))
          )
        )
        (if s (ssdel en s) (setq s (ssadd)))
        (if (= (sslength s) 1) 
          (progn 
            (setq e (ssname s 0))
            (if (ssmemb e ss) 
              (progn 
                (if (wcmatch flag "LINE") 
                  (progn 
                    (setq el   (entget e)
                          pp10 (&DRAG e 10)
                          pp11 (&DRAG e 11)
                          ang1 (angle pp10 pp11)
                          ang2 (angle pp11 pp10)
                          an1  (abs (- ang ang1))
                          an2  (abs (- ang ang2))
                    )
                    (if (> an1 (* 1.5 pi)) (setq an1 (- (* 2 pi) an1)))
                    (if (> an2 (* 1.5 pi)) (setq an2 (- (* 2 pi) an2)))
                    (if (> an1 an2) 
                      (setq p    pp10
                            pp10 pp11
                            pp11 p
                      )
                    )
                  )
                  (progn 
                    (setq el   (entget e)
                          cen  (&DRAG e 10)
                          r    (&DRAG e 40)
                          qi   (&DRAG e 50)
                          zh   (&DRAG e 51)
                          pp10 (polar cen qi r)
                          pp11 (polar cen zh r)
                    )
                  )
                )
                (entdel e)
                (entdel en)
                (ssdel e ss)
                (ssdel en ss)
                (if (member e en_l) (setq i (1- i)))
                (setq s1 nil
                      s2 nil
                      s3 nil
                      s4 nil
                      s1 (pts p10)
                      s2 (pts pp10)
                      s3 (pts p11)
                      s4 (pts pp11)
                )
                (if (and (= (sslength s1) 1) (= (sslength s2) 1)) 
                  (progn 
                    (setq e1  (ssname s1 0)
                          e2  (ssname s2 0)
                          e1l (entget e1)
                          e2l (entget e2)
                          fl1 (strcase (&DRAG e1 0))
                          fl2 (strcase (&DRAG e2 0))
                    )
                    (cond 
                      ((and (wcmatch fl1 "LINE") (wcmatch fl2 "LINE"))
                       (setq p0 (&DRAG e1 10)
                             p1 (&DRAG e1 11)
                             p2 (&DRAG e2 10)
                             p3 (&DRAG e2 11)
                       )
                       (if (equal p0 p10 0.1) 
                         (setq p  p0
                               p0 p1
                               p1 p
                         )
                       )
                       (if (equal p3 pp10 0.1) 
                         (setq p  p2
                               p2 p3
                               p3 p
                         )
                       )
                       (setq an1  (angle p0 p1)
                             an2  (angle p2 p3)
                             ang1 (angle p0 p3)
                             ang2 (angle p3 p2)
                       )
                       (if (equal an1 (* 2 pi) 0.01) (setq an1 0.))
                       (if (equal an2 (* 2 pi) 0.01) (setq an2 0.))
                       (if (equal ang1 (* 2 pi) 0.01) (setq ang1 0.))
                       (if (equal ang2 (* 2 pi) 0.01) (setq ang2 0.))
                       (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                         (cond 
                           ((and (equal an1 an2 0.01) (equal an1 ang1 0.01))
                            (del (list e1 e2))
                            (emk p0 p3 e1l)
                           )
                           ((and (equal an1 an2 0.01) (not (equal an1 ang1 0.01)))
                            (del (list e1 e2))
                            (if (< (distance p1 p2) (* 2 wallwid)) 
                              (mid p0 p1 p2 p3 e1l e2l)
                              (progn 
                                (setq p  (car (&ORDR 2 p10 p11 p2 p3))
                                      pp (car (&ORDR 2 pp10 pp11 p0 p1))
                                )
                                (if p 
                                  (progn (entdel e1) (emk p1 p e1l) (emk p p3 e2l))
                                )
                                (if pp 
                                  (progn (emk p0 pp e1l) 
                                         (emk pp p2 e1l)
                                         (entdel e2)
                                  )
                                )
                              )
                            )
                           )
                           ((equal an1 ang2 0.01)
                            (del (list e1 e2))
                            (int p0 p1 p3 p2 e1l e2l)
                           )
                           (T
                            (del (list e1 e2))
                            (setq p (inters p0 p1 p2 p3 nil))
                            (emk p0 p e1l)
                            (emk p p3 e2l)
                           )
                         )
                       )
                      )
                      ((and (wcmatch fl1 "LINE") (wcmatch fl2 "ARC"))
                       (setq p0  (&DRAG e1 10)
                             p1  (&DRAG e1 11)
                             cen (&DRAG e2 10)
                             r   (&DRAG e2 40)
                             p3  nil
                             p4  nil
                             p   (&ORDR 1 p0 p1 cen r)
                       )
                       (if p 
                         (progn 
                           (if (= (length p) 2) 
                             (setq p3 (car p)
                                   p4 (cadr p)
                             )
                             (setq p3 (car p))
                           )
                           (if (equal p0 p10 0.1) 
                             (setq p  p0
                                   p0 p1
                                   p1 p
                             )
                           )
                           (if p4 
                             (if (> (distance p1 p3) (distance p1 p4)) 
                               (setq p p4)
                               (setq p p3)
                             )
                             (setq p p3)
                           )
                           (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                             (progn 
                               (del (list e1 e2))
                               (if p (emk p0 p e1l) (emk p0 p1 e1l))
                               (if 
                                 (> 
                                   (distance p (polar cen (&DRAG e2 50) r))
                                   (distance p (polar cen (&DRAG e2 51) r))
                                 )
                                 (emka (&DRAG e2 50) (angle cen p) e2l)
                                 (emka (angle cen p) (&DRAG e2 51) e2l)
                               )
                             )
                           )
                         )
                       )
                      )
                      ((and (wcmatch fl1 "ARC") (wcmatch fl2 "LINE"))
                       (setq p0  (&DRAG e2 10)
                             p1  (&DRAG e2 11)
                             cen (&DRAG e1 10)
                             r   (&DRAG e1 40)
                             p3  nil
                             p4  nil
                             p   (&ORDR 2 cen r p0 p1)
                       )
                       (if p 
                         (progn 
                           (if (= (length p) 2) 
                             (setq p3 (car p)
                                   p4 (cadr p)
                             )
                             (setq p3 (car p))
                           )
                           (if (equal p0 pp10 0.1) 
                             (setq p  p0
                                   p0 p1
                                   p1 p
                             )
                           )
                           (if p4 
                             (if (> (distance p1 p3) (distance p1 p4)) 
                               (setq p p4)
                               (setq p p3)
                             )
                             (setq p p3)
                           )
                           (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                             (progn 
                               (del (list e1 e2))
                               (if p (emk p0 p e2l) (emk p0 p1 e2l))
                               (if 
                                 (> 
                                   (distance p (polar cen (&DRAG e1 50) r))
                                   (distance p (polar cen (&DRAG e1 51) r))
                                 )
                                 (emka (&DRAG e1 50) (angle cen p) e1l)
                                 (emka (angle cen p) (&DRAG e1 51) e1l)
                               )
                             )
                           )
                         )
                       )
                      )
                      ((and (wcmatch fl1 "ARC") (wcmatch fl2 "ARC"))
                       (setq c1 (&DRAG e1 10)
                             r1 (&DRAG e1 40)
                             c2 (&DRAG e2 10)
                             r2 (&DRAG e2 40)
                       )
                       (if (and (not (equal c1 c2 1.0)) (not (equal r1 r2 1.0))) 
                         (progn 
                           (setq p  (&ORDR c1 r1 c2 r2)
                                 p3 nil
                                 p4 nil
                           )
                           (if p 
                             (if (= (length p) 2) 
                               (setq p3 (car p)
                                     p4 (cadr p)
                               )
                               (setq p3 (car p))
                             )
                           )
                           (if p4 
                             (if (> (distance p1 p3) (distance p1 p4)) 
                               (setq p p4)
                               (setq p p3)
                             )
                             (setq p p3)
                           )
                           (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                             (progn 
                               (del (list e1 e2))
                               (if p 
                                 (emkar 
                                   (&DRAG e1 50)
                                   (&DRAG e1 51)
                                   (angle c1 p)
                                   e1l
                                 )
                                 (entdel e1)
                               )
                               (if p 
                                 (emkar 
                                   (&DRAG e2 50)
                                   (&DRAG e2 51)
                                   (angle c2 p)
                                   e2l
                                 )
                                 (entdel e2)
                               )
                             )
                           )
                         )
                         (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                           (progn 
                             (del (list e1 e2))
                             (if (equal r1 r2 (* 0.01 &sp)) 
                               (emkarc 
                                 (&DRAG e1 50)
                                 (&DRAG e1 51)
                                 (&DRAG e2 50)
                                 (&DRAG e2 51)
                                 e1l
                               )
                               (tyx)
                             )
                           )
                         )
                       )
                      )
                    )
                  )
                  (progn 
                    (if (= (sslength s1) 1) 
                      (setq ptl (append ptl (list p10)))
                    )
                    (if (= (sslength s2) 1) 
                      (setq ptl (append ptl (list pp10)))
                    )
                  )
                )
                (if (and (= (sslength s3) 1) (= (sslength s4) 1)) 
                  (progn 
                    (setq e1  (ssname s3 0)
                          e2  (ssname s4 0)
                          e1l (entget e1)
                          e2l (entget e2)
                          fl1 (strcase (cdr (assoc 0 e1l)))
                          fl2 (strcase (cdr (assoc 0 e2l)))
                    )
                    (cond 
                      ((and (wcmatch fl1 "LINE") (wcmatch fl2 "LINE"))
                       (setq p0 (&DRAG e1 10)
                             p1 (&DRAG e1 11)
                             p2 (&DRAG e2 10)
                             p3 (&DRAG e2 11)
                       )
                       (if (equal p0 p11 0.1) 
                         (setq p  p0
                               p0 p1
                               p1 p
                         )
                       )
                       (if (equal p3 pp11 0.1) 
                         (setq p  p2
                               p2 p3
                               p3 p
                         )
                       )
                       (setq an1  (angle p0 p1)
                             an2  (angle p2 p3)
                             ang1 (angle p0 p3)
                             ang2 (angle p3 p2)
                       )
                       (if (equal an1 (* 2 pi) 0.01) (setq an1 0.))
                       (if (equal an2 (* 2 pi) 0.01) (setq an2 0.))
                       (if (equal ang1 (* 2 pi) 0.01) (setq ang1 0.))
                       (if (equal ang2 (* 2 pi) 0.01) (setq ang2 0.))
                       (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                         (cond 
                           ((and (equal an1 an2 0.01) (equal an1 ang1 0.01))
                            (del (list e1 e2))
                            (emk p0 p3 e1l)
                           )
                           ((and (equal an1 an2 0.01) (not (equal an1 ang1 0.01)))
                            (del (list e1 e2))
                            (if (< (distance p1 p2) (* 2 wallwid)) 
                              (mid p0 p1 p2 p3 e1l e2l)
                              (progn 
                                (setq p  (car (&ORDR 2 p10 p11 p2 p3))
                                      pp (car (&ORDR 2 pp10 pp11 p0 p1))
                                )
                                (if p 
                                  (progn (entdel e1) (emk p1 p e1l) (emk p p3 e2l))
                                )
                                (if pp 
                                  (progn (emk p0 pp e1l) 
                                         (emk pp p2 e1l)
                                         (entdel e2)
                                  )
                                )
                              )
                            )
                           )
                           ((equal an1 ang2 0.01)
                            (del (list e1 e2))
                            (int p0 p1 p3 p2 e1l e2l)
                           )
                           (T
                            (del (list e1 e2))
                            (setq p (inters p0 p1 p2 p3 nil))
                            (emk p0 p e1l)
                            (emk p p3 e2l)
                           )
                         )
                       )
                      )
                      ((and (wcmatch fl1 "LINE") (wcmatch fl2 "ARC"))
                       (setq p0  (&DRAG e1 10)
                             p1  (&DRAG e1 11)
                             cen (&DRAG e2 10)
                             r   (&DRAG e2 40)
                             p3  nil
                             p4  nil
                             p   (&ORDR 1 p0 p1 cen r)
                       )
                       (if p 
                         (progn 
                           (if (= (length p) 2) 
                             (setq p3 (car p)
                                   p4 (cadr p)
                             )
                             (setq p3 (car p))
                           )
                           (if (equal p0 p11 0.1) 
                             (setq p  p0
                                   p0 p1
                                   p1 p
                             )
                           )
                           (if p4 
                             (if (> (distance p1 p3) (distance p1 p4)) 
                               (setq p p4)
                               (setq p p3)
                             )
                             (setq p p3)
                           )
                           (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                             (progn 
                               (del (list e1 e2))
                               (if p (emk p0 p e1l) (emk p0 p1 e1l))
                               (if 
                                 (> 
                                   (distance p (polar cen (&DRAG e2 50) r))
                                   (distance p (polar cen (&DRAG e2 51) r))
                                 )
                                 (emka (&DRAG e2 50) (angle cen p) e2l)
                                 (emka (angle cen p) (&DRAG e2 51) e2l)
                               )
                             )
                           )
                         )
                       )
                      )
                      ((and (wcmatch fl1 "ARC") (wcmatch fl2 "LINE"))
                       (setq p0  (&DRAG e2 10)
                             p1  (&DRAG e2 11)
                             cen (&DRAG e1 10)
                             r   (&DRAG e1 40)
                             p3  nil
                             p4  nil
                             p   (&ORDR 2 cen r p0 p1)
                       )
                       (if p 
                         (progn 
                           (if (= (length p) 2) 
                             (setq p3 (car p)
                                   p4 (cadr p)
                             )
                             (setq p3 (car p))
                           )
                           (if (equal p0 pp11 0.1) 
                             (setq p  p0
                                   p0 p1
                                   p1 p
                             )
                           )
                           (if p4 
                             (if (> (distance p1 p3) (distance p1 p4)) 
                               (setq p p4)
                               (setq p p3)
                             )
                             (setq p p3)
                           )
                           (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                             (progn 
                               (del (list e1 e2))
                               (if p (emk p0 p e2l) (emk p0 p1 e2l))
                               (if 
                                 (> 
                                   (distance p (polar cen (&DRAG e1 50) r))
                                   (distance p (polar cen (&DRAG e1 51) r))
                                 )
                                 (emka (&DRAG e1 50) (angle cen p) e1l)
                                 (emka (angle cen p) (&DRAG e1 51) e1l)
                               )
                             )
                           )
                         )
                       )
                      )
                      ((and (wcmatch fl1 "ARC") (wcmatch fl2 "ARC"))
                       (setq c1 (&DRAG e1 10)
                             r1 (&DRAG e1 40)
                             c2 (&DRAG e2 10)
                             r2 (&DRAG e2 40)
                       )
                       (if (and (not (equal c1 c2 1.0)) (not (equal r1 r2 1.0))) 
                         (progn 
                           (setq p  (&ORDR c1 r1 c2 r2)
                                 p3 nil
                                 p4 nil
                           )
                           (if p 
                             (if (= (length p) 2) 
                               (setq p3 (car p)
                                     p4 (cadr p)
                               )
                               (setq p3 (car p))
                             )
                           )
                           (if p4 
                             (if (> (distance p1 p3) (distance p1 p4)) 
                               (setq p p4)
                               (setq p p3)
                             )
                             (setq p p3)
                           )
                           (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                             (progn 
                               (del (list e1 e2))
                               (if p 
                                 (emkar 
                                   (&DRAG e1 50)
                                   (&DRAG e1 51)
                                   (angle c1 p)
                                   e1l
                                 )
                                 (entdel e1)
                               )
                               (if p 
                                 (emkar 
                                   (&DRAG e2 50)
                                   (&DRAG e2 51)
                                   (angle c2 p)
                                   e2l
                                 )
                                 (entdel e2)
                               )
                             )
                           )
                         )
                         (if (and (not (ssmemb e1 ss)) (not (ssmemb e2 ss))) 
                           (progn 
                             (del (list e1 e2))
                             (if (equal r1 r2 (* 0.01 &sp)) 
                               (emkarc 
                                 (&DRAG e1 50)
                                 (&DRAG e1 51)
                                 (&DRAG e2 50)
                                 (&DRAG e2 51)
                                 e1l
                               )
                               (txy)
                             )
                           )
                         )
                       )
                      )
                    )
                  )
                  (progn 
                    (if (= (sslength s3) 1) 
                      (setq ptl (append ptl (list p11)))
                    )
                    (if (= (sslength s4) 1) 
                      (setq ptl (append ptl (list pp11)))
                    )
                  )
                )
              )
              (setq i    (1+ i)
                    en_l (append en_l (list en))
              )
            )
          )
          (if (= (sslength s) 0) 
            (setq i    (1+ i)
                  en_l (append en_l (list en))
            )
            (progn 
              (entdel en)
              (ssdel en ss)
              (setq ptl (append ptl (list p10 p11)))
            )
          )
        )
      )
      (while (setq e1 (ssname ss 0)) 
        (ssdel e1 ss)
        (setq e1l  (entget e1)
              flag (strcase (cdr (assoc 0 e1l)))
        )
        (if (wcmatch flag "LINE") 
          (setq p10 (&DRAG e1 10)
                p11 (&DRAG e1 11)
          )
          (setq p10 (&DRAG e1 10)
                p11 (polar p10 (&DRAG e1 51) (&DRAG e1 40))
                p10 (polar p10 (&DRAG e1 50) (&DRAG e1 40))
          )
        )
        (if (= (sslength (pts p10)) 2) 
          (setq ptl (append ptl (list p10)))
        )
        (if (= (sslength (pts p11)) 2) 
          (setq ptl (append ptl (list p11)))
        )
        (entdel e1)
      )
      (jion ptl)
    )
  )
  (if (= zoom 1) (command ".zoom" "c" vct vsz))
  (&TSTY)
)





(setfunhelp "c:Jchjc" "Tssd" "jchjc")
(defun c:Jchjc (/ p_l break_beam dcl_chl cen a p2 p3 p4 bfpl ar are are1 are2 no a1 
                a2 e el en en1 enl ent flag i j lay lay1 p0 p1 p10 p11 pint pintl pl r 
                s ss el pt brpl
               ) 
  (defun p_l (el / p pl) 
    (setq pt (list 0 0 0))
    (while (setq p (cdr (assoc 10 el))) 
      (setq p  (@ucs p)
            pl (append pl (list p))
            el (subst (cons 11 "旧") (assoc 10 el) el)
      )
      (setq pt (list (+ (car pt) (car p)) (+ (cadr pt) (cadr p))))
    )
    (setq pt (list 
               (/ (car pt) (length pl))
               (/ (cadr pt) (length pl))
             )
    )
    (if (= (cdr (assoc 70 el)) 1) 
      (setq pl (append pl (list (car pl))))
    )
    pl
  )
  (defun break_beam (pl p / ent dis1 dis2 len p1 p2 px1 px2) 
    (setq len (length pl)
          ent en
    )
    (if (> len 1) 
      (progn 
        (setq p1   (nth 0 pl)
              p2   (nth (1- len) pl)
              dis1 (distance p p1)
              dis2 (distance p p2)
        )
        (if (< dis2 dis1) (setq pl (reverse pl)))
        (if (= (rem len 2) 1) 
          (setq pl (reverse (cdr (reverse pl))))
        )
        (while (and (setq px1 (car pl)) (setq px2 (cadr pl))) 
          (command ".break" ent px1 px2)
          (setq ent (entlast)
                pl  (cddr pl)
          )
        )
      )
    )
    ent
  )
  (defun dcl_chl (/ what dia no) 
    (defun vslide (img name / x y) 
      (setq x (dimx_tile img)
            y (dimy_tile img)
      )
      (start_image img)
      (fill_image 0 0 x y -2)
      (slide_image 
        -10
        0
        (+ x 10)
        (- y 5)
        (strcat "Tssd (" name ")")
      )
      (end_image)
      (setq no 1)
      (mode_tile "img1" 4)
    )
    (defun hdsj (fl /) 
      (if (= fl 1) 
        (mode_tile "img1" 4)
        (if (= fl 2) (mode_tile "img2" 4) (mode_tile "img3" 4))
      )
      (if (= no 1) 
        (mode_tile "img1" 4)
        (if (= no 2) 
          (mode_tile "img2" 4)
          (if (= no 3) (mode_tile "img3" 4))
        )
      )
      (setq no fl)
      (if (= $reason 4) (done_dialog 0) (setq what -2))
    )
    (setq what 2
          dia  (lib::dcl "BeamWall")
    )
    (while (> what 0) 
      (if (not (new_dialog "Jchjc" dia)) (exit))
      (vslide "img1" "jchjc1")
      (vslide "img2" "jchjc2")
      (vslide "img3" "jchjc3")
      (action_tile "img1" "(hdsj 1)")
      (action_tile "img2" "(hdsj 2)")
      (action_tile "img3" "(hdsj 3)")
      (action_tile "accept" "(done_dialog 0)(setq what -2)")
      (action_tile "cancel" "(done_dialog 0)(setq what -2 no 0)")
      (action_tile "help" "(help \"Tssd\" \"Jchjc\")")
      (start_dialog)
    )
    (unload_dialog dia)
    no
  )
  (defun ar (pl pt / p0 p1 mj) 
    (setq p0 (car pl)
          pl (cdr pl)
          mj 0
    )
    (while (setq p1 (car pl)) 
      (setq mj (+ mj (abs (@area (list pt p0 p1))))
            p0 p1
            pl (cdr pl)
      )
    )
    mj
  )
  (if (< (&UTXT) 0) (exit))
  (setq no   (dcl_chl)
        brpl nil
  )
  (if (> no 0) 
    (progn 
      (setq lay  (strcase (&LJIG "平面独立基础"))
            i    0
            ss   (&DSTR 
                   "\n选择要进行基础剪裁的梁线<退出>: "
                   (list (cons 0 "LWPOLYLINE") (cons 8 lay))
                 )
            lay1 (strcase (&LJIG "平面独立基础,平面主梁,平面主梁实线,平面次梁,平面次梁实线"))
      )
      (if ss 
        (progn 
          (while (setq en (ssname ss i)) 
            (setq enl (entget en)
                  pl  (p_l enl)
                  p0  (car pl)
                  p1  (cadr pl)
                  i   (1+ i)
                  ent (entlast)
                  s   nil
                  s   (ssget "cp" pl (list (cons 0 "LINE,ARC") (cons 8 lay1)))
            )
            (setq bfpl pl
                  are  (abs (@area (cdr bfpl)))
            )
            (while (and p0 p1 s) 
              (setq j  0
                    p0 (polar p0 (angle p0 p1) (* 0.01 &sp))
                    p1 (polar p1 (angle p1 p0) (* 0.01 &sp))
              )
              (while (and (setq e (ssname s j)) (setq el (entget e))) 
                (setq flag (strcase (cdr (assoc 0 el))))
                (if (wcmatch flag "LINE") 
                  (setq p10  (&DRAG e 10)
                        p11  (&DRAG e 11)
                        pint (inters p0 p1 p10 p11)
                  )
                  (setq cen  (&DRAG e 10)
                        r    (&DRAG e 40)
                        a1   (&DRAG e 50)
                        a2   (&DRAG e 51)
                        pint (car (&ORDR p0 p1 cen r a1 a2))
                        p11  (polar cen (+ a2 0.005) r)
                        p10  (polar cen (- a1 0.005) r)
                  )
                )
                (if pint 
                  (progn 
                    (setq pintl (append pintl (list pint)))
                    (if (> no 1) 
                      (if (setq pint (&ORDR e en)) 
                        (if (= (length pint) 2) 
                          (setq brpl (cons (cons e pint) brpl))
                          (if (= (length pint) 1) 
                            (progn 
                              (setq pint (car pint)
                                    are1 (ar bfpl p10)
                                    are2 (ar bfpl p11)
                              )
                              (if 
                                (or 
                                  (equal are are1 (* 0.01 are))
                                  (equal are are2 (* 0.01 are))
                                )
                                (progn 
                                  (if (< (distance pt p10) (distance pt p11)) 
                                    (if (wcmatch flag "LINE") 
                                      (setq el (subst (cons 10 (@wcs pint)) 
                                                      (assoc 10 el)
                                                      el
                                               )
                                      )
                                      (setq el (subst 
                                                 (cons 50 (@wcs (angle cen pint)))
                                                 (assoc 50 el)
                                                 el
                                               )
                                      )
                                    )
                                    (if (wcmatch flag "LINE") 
                                      (setq el (subst (cons 11 (@wcs pint)) 
                                                      (assoc 11 el)
                                                      el
                                               )
                                      )
                                      (setq el (subst 
                                                 (cons 51 (@wcs (angle cen pint)))
                                                 (assoc 51 el)
                                                 el
                                               )
                                      )
                                    )
                                  )
                                  (entmod el)
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
                (setq j (1+ j))
              )
              (if (or (= no 1) (= no 3)) 
                (progn 
                  (setq en1   (break_beam pintl p0)
                        pintl nil
                  )
                  (if (not (equal en1 ent)) (setq en en1))
                )
              )
              (setq pl (cdr pl)
                    p0 (car pl)
                    p1 (cadr pl)
              )
            )
          )
        )
      )
      (while (setq el (car brpl)) 
        (setq p1 (cadr el)
              p2 (caddr el)
              a  (angle p1 p2)
              p3 (polar p1 (+ a _pi2) (* 10 &sc))
              p4 (polar p2 (- a _pi2) (* 10 &sc))
              ss (ssget 
                   "cp"
                   (list p1 p3 p2 p4)
                   (list (cons 0 "LINE,ARC") (cons 8 lay1))
                 )
        )
        (while (setq e (ssname ss 0)) 
          (ssdel e ss)
          (command ".Break" e (cadr el) (caddr el))
        )
        (setq brpl (cdr brpl))
      )
    )
  )
  (&TSTY)
)
(defun mvln (e a wd lay / a0 a1 a2 ei el i lp mm p1 p2 p3 pa pb pc q1 q2 r si sl ss 
             tfz
            ) 
  (setq p1  (&DRAG e 10)
        p2  (&DRAG 11)
        a0  (angle p1 p2)
        q1  (polar p1 a wd)
        q2  (polar p2 a wd)
        el  (entget e)
        el  (@subst el 10 (@wcs q1))
        el  (@subst el 11 (@wcs q2))
        si  (@gpels 2)
        lp  (list 
              (polar p1 (- a0 (* 1.25 pi)) si)
              (polar p1 (+ a0 (* 1.25 pi)) si)
              (polar p2 (- a0 (* 0.25 pi)) si)
              (polar p2 (+ a0 (* 0.25 pi)) si)
            )
        tfz (@zoome (- si) lp)
        ss  (ssget "cp" lp (list '(0 . "line,arc") (cons 8 lay)))
  )
  (if ss 
    (progn 
      (ssdel e ss)
      (setq si 0
            sl (sslength ss)
            mm 1.0
            wd (* 2 (abs wd))
      )
      (while (< si sl) 
        (setq ei (ssname ss si)
              si (1+ si)
              pa (&DRAG ei 10)
        )
        (if (setq pb (&DRAG 11)) 
          (progn 
            (setq i (cond 
                      ((equal (&MIDP pa p1 p2) 0 mm) 10)
                      ((equal (&MIDP pb p1 p2) 0 mm) 11)
                      (t nil)
                    )
            )
            (if (and i (setq p3 (inters q1 q2 pa pb nil))) 
              (progn 
                (if (or (= i 10) (= i 11)) 
                  (entmod (@subst (entget ei) i (@wcs p3)))
                  (entmod (@subst (entget ei) i (@wcs p3)))
                )
                (cond 
                  ((or (equal p1 pa mm) (equal p1 pb mm))
                   (setq el (@subst el 10 (@wcs p3)))
                  )
                  ((or (equal p2 pa mm) (equal p2 pb mm))
                   (setq el (@subst el 11 (@wcs p3)))
                  )
                )
              )
            )
          )
          (progn 
            (setq pc pa
                  r  (&DRAG 40)
                  a1 (&DRAG 50)
                  a2 (&DRAG 51)
                  pa (polar pc a1 r)
                  pb (polar pc a2 r)
                  ei (entget ei)
            )
            (if 
              (and 
                (or 
                  (equal (&MIDP pa p1 p2) 0 mm)
                  (equal (&MIDP pb p1 p2) 0 mm)
                )
                (setq p3 (&ORDR 3 q1 q2 pc r a1 a2))
              )
              (progn 
                (foreach p p3 
                  (if (or (< (distance p q1) wd) (< (distance p q2) wd)) 
                    (progn 
                      (setq a1 (angle pc p)
                            ei (@subst 
                                 ei
                                 (if (< (distance p pa) (distance p pb)) 50 51)
                                 (@wcs a1)
                               )
                      )
                      (cond 
                        ((or (equal p1 pa mm) (equal p1 pb mm))
                         (setq el (@subst el 10 (@wcs p)))
                        )
                        ((or (equal p2 pa mm) (equal p2 pb mm))
                         (setq el (@subst el 11 (@wcs p)))
                        )
                      )
                    )
                  )
                )
                (entmod ei)
              )
            )
          )
        )
      )
    )
  )
  (entmod el)
  tfz
)
(defun mvarc (e wd lay / a1 a2 ei el lp mm p1 p2 p3 pa pb pc r r1 si sl ss tfz q1 q2) 
  (setq pc  (&DRAG e 10)
        r   (&DRAG 40)
        r1  (+ r wd)
        a1  (&DRAG 50)
        a2  (&DRAG 51)
        p1  (polar pc a1 r)
        p2  (polar pc a2 r)
        q1  (polar pc a1 r1)
        q2  (polar pc a2 r1)
        el  (@subst (entget e) 40 r1)
        lp  (@arpl pc r a1 a2)
        si  (@gpels 2)
        tfz (@zoome (- si) lp)
        ss  (ssget "cp" lp (list '(0 . "line") (cons 8 lay)))
  )
  (if ss 
    (progn 
      (ssdel e ss)
      (setq si 0
            sl (sslength ss)
            mm 1.0
            wd (* 2 (abs wd))
      )
      (while (< si sl) 
        (setq ei (ssname ss si)
              si (1+ si)
              pa (&DRAG ei 10)
              pb (&DRAG 11)
              ei (entget ei)
        )
        (if 
          (and 
            (or 
              (equal (distance pc pa) r mm)
              (equal (distance pc pb) r mm)
            )
            (setq p3 (&ORDR 3 pa pb pc r1 a1 a2))
          )
          (progn 
            (foreach p p3 
              (if (or (< (distance p q1) wd) (< (distance p q2) wd)) 
                (progn 
                  (setq ei (@subst 
                             ei
                             (if (< (distance p pa) (distance p pb)) 10 11)
                             (@wcs p)
                           )
                  )
                  (cond 
                    ((or (equal p1 pa mm) (equal p1 pb mm))
                     (setq el (@subst el 50 (@wcs (angle pc p))))
                    )
                    ((or (equal p2 pa mm) (equal p2 pb mm))
                     (setq el (@subst el 51 (@wcs (angle pc p))))
                    )
                  )
                )
              )
            )
            (entmod ei)
          )
        )
      )
      (entmod el)
    )
  )
  tfz
)



;;; 改变宽度
(defun dbthk (msg1 msg2 lay / member1 inlist inalst wlthk gdist a a1 as e l1 la1 ll 
              mm mma mx notwo na p00 p1 p2 r si sl ss tfz wd wn wo
             ) 
  (defun member1 (x l / y) 
    (while (and (setq y (car l)) (not (equal x y mm))) 
      (setq l (cdr l))
    )
    l
  )
  (defun inlist (/ ll ll1 q1 q2 x1 x2) 
    (setq q1  (polar p00 a mx)
          q2  (polar p00 (+ a _pi2) mx)
          x1  (&MIDP p1 p00 q2)
          x2  (&MIDP p2 p00 q2)
          ll  (assoc as l1)
          ll1 (list 
                (list (&MIDP p1 p00 q1) (min x1 x2) (max x1 x2) e)
              )
          l1  (if ll 
                (subst (append ll ll1) ll l1)
                (cons (cons as (cons a ll1)) l1)
              )
    )
  )
  (defun inalst (/ l ll) 
    (setq ll la1)
    (while (and la1 (not (equal p1 (caar la1) mm))) 
      (setq la1 (cdr la1))
    )
    (setq l   (car la1)
          la1 (if la1 
                (subst (append l (list (list r a a1 e))) l ll)
                (cons (list p1 (list r a a1 e)) ll)
              )
    )
  )
  (defun wlthk (a1 l0 / a2 la lb lb0 le le0 ll ll1 ll2 w y1 y2 xa1 xa2 e1 xb1 xb2 e2) 
    (setq a1 (+ a1 _pi2)
          a2 (+ a1 pi)
          l0 (if l0 (@ran3 l0))
          la (car l0)
          y1 (car la)
          la (list (cdr la))
    )
    (foreach lb (cdr l0) 
      (setq y2 (car lb))
      (if (equal y1 y2 mm) 
        (setq la (cons (cdr lb) la))
        (setq ll (cons (cons y1 la) ll)
              la (list (cdr lb))
              y1 y2
        )
      )
    )
    (setq ll (reverse (cons (cons y1 la) ll)))
    (while ll 
      (setq la  (car ll)
            y1  (car la)
            la  (cdr la)
            le0 (last la)
      )
      (while (setq ll (cdr ll)) 
        (setq lb (car ll)
              y2 (car lb)
              lb (cdr lb)
              w  (- y2 y1)
        )
        (if notwo 
          (setq wo w
                wd (/ (- wn wo) 2.0)
          )
        )
        (cond 
          ((equal w wo mm)
           (foreach l la 
             (mapcar 'set '(xa1 xa2 e1) l)
             (foreach l lb 
               (mapcar 'set '(xb1 xb2 e2) l)
               (if (or (<= xa1 xb1 xa2) (<= xb1 xa1 xb2)) 
                 (progn 
                   (if (not (member e1 le)) 
                     (setq le  (cons e1 le)
                           tfz (or (mvln e1 a1 wd lay) tfz)
                     )
                   )
                   (if (not (member e2 le)) 
                     (setq le  (cons e2 le)
                           tfz (or (mvln e2 a2 wd lay) tfz)
                     )
                   )
                 )
               )
             )
           )
           (setq lb0 nil)
           (foreach l lb 
             (if (not (member (last l) le)) 
               (setq lb0 (cons l lb0))
             )
           )
           (if lb0 
             (setq la lb0
                   y1 y2
             )
             (setq ll (cdr ll)
                   la (car ll)
                   y1 (car la)
                   la (cdr la)
             )
           )
          )
          ((< w wo) (setq ll1 (cons (cons y2 lb) ll1)))
          (T
           (if (not (equal le0 (last la))) 
             (setq ll1 (cons (cons y1 la) ll1))
           )
           (setq la lb
                 y1 y2
           )
          )
        )
      )
      (if (and ll1 la (not (equal ll1 ll2))) 
        (setq ll2 ll1
              ll1 (cons (cons y1 la) ll1)
        )
      )
      (setq ll  (if ll1 (@ran3 ll1))
            ll1 nil
      )
    )
  )
  (defun wathk (p1 l0 / la lb lb0 le le0 ll ll1 ll2 r1 r2 w aa1 aa2 e1 aa2 ab2 e2) 
    (setq l0 (if l0 (@ran3 l0))
          la (car l0)
          r1 (car la)
          la (list (cdr la))
    )
    (foreach lb (cdr l0) 
      (setq r2 (car lb))
      (if (equal r1 r2 mm) 
        (setq la (cons (cdr lb) la))
        (setq ll (cons (cons r1 la) ll)
              la (list (cdr lb))
              r1 r2
        )
      )
    )
    (setq ll (reverse (cons (cons r1 la) ll)))
    (while ll 
      (setq la  (car ll)
            r1  (car la)
            la  (cdr la)
            le0 (last la)
      )
      (while (setq ll (cdr ll)) 
        (setq lb (car ll)
              r2 (car lb)
              lb (cdr lb)
              w  (- r2 r1)
        )
        (if notwo 
          (setq wo w
                wd (/ (- wn wo) 2.0)
          )
        )
        (cond 
          ((equal w wo mm)
           (foreach l la 
             (mapcar 'set '(aa1 aa2 e1) l)
             (foreach l lb 
               (mapcar 'set '(ab1 ab2 e2) l)
               (if 
                 (or 
                   (<= aa1 ab1 aa2)
                   (<= ab1 aa1 ab2)
                   (<= aa1 (+ ab1 _2pi) aa2)
                   (<= ab1 (+ aa1 _2pi) ab2)
                 )
                 (progn 
                   (if (not (member e1 le)) 
                     (setq le  (cons e1 le)
                           tfz (or (mvarc e1 (- wd) lay) tfz)
                     )
                   )
                   (if (not (member e2 le)) 
                     (setq le  (cons e2 le)
                           tfz (or (mvarc e2 wd lay) tfz)
                     )
                   )
                 )
               )
             )
           )
           (setq lb0 nil)
           (foreach l lb 
             (if (not (member (last l) le)) 
               (setq lb0 (cons l lb0))
             )
           )
           (if lb0 
             (setq la lb0
                   r1 r2
             )
             (setq ll (cdr ll)
                   la (car ll)
                   r1 (car la)
                   la (cdr la)
             )
           )
          )
          ((< w wo) (setq ll1 (cons (cons r2 lb) ll1)))
          (T
           (if (not (equal le0 (last la))) 
             (setq ll1 (cons (cons r1 la) ll1))
           )
           (setq la lb
                 r1 r2
           )
          )
        )
      )
      (if (and ll1 la (not (equal ll1 ll2))) 
        (setq ll2 ll1
              ll1 (cons (cons r1 la) ll1)
        )
      )
      (setq ll  (if ll1 (@ran3 ll1))
            ll1 nil
      )
    )
  )
  (defun gdist (msg / p0 pt ds gd1) 
    (defun gd1 (p0 msg ig / ctn d1 pt) 
      (setq ctn t)
      (while ctn 
        (initget 128)
        (setq pt (if p0 (&OSNP p0 msg) (&OSNP msg)))
        (cond 
          ((null pt)
           (setq d1  nil
                 ctn nil
           )
          )
          ((listp pt)
           (setq d1  (if p0 (distance p0 pt) pt)
                 ctn nil
           )
          )
          ((= (setq d1 (atof pt)) (read pt))
           (cond 
             ((and ig (= (logand ig 2) 2) (zerop d1))
              (princ "\n**不能输入0值！请重新输入。")
             )
             ((and ig (= (logand ig 4) 4) (minusp d1))
              (princ "\n**不能输入负值！请重新输入。")
             )
             (t
              (setq d1  (* d1 &sc)
                    ctn nil
              )
             )
           )
          )
          (t (princ "\n**输入值不是实数！请重新输入。"))
        )
      )
      d1
    )
    (setq p0 (gd1 nil msg 6)
          ds (cond 
               ((null p0) nil)
               ((listp p0) (gd1 p0 msg 6))
               (t p0)
             )
    )
    ds
  )
  (if (< (&UTXT) 0) (exit))
  (setq wo (gdist (strcat "\n输入" msg1 "的原有" msg2 "度<所有" msg2 "度>: ")))
  (if 
    (and 
      (setq wn (gdist (strcat "\t新的" msg2 "度<退出>: ")))
      (if (and wo (= wo wn)) 
        (prompt (strcat "\n新旧" msg2 "度不能相等!"))
        T
      )
      (if (= msg1 "墙") 
        (setq ss (&DSTR 
                   (strcat "\n选择要改变" msg2 "度的" msg1 "线<退出>: ")
                   (list 
                     '(-4 . "<OR")
                     '(-4 . "<AND")
                     '(0 . "LINE,ARC")
                     (cons 8 lay)
                     '(-4 . "AND>")
                     '(2 . "Ts_Dk")
                     '(-4 . "OR>")
                   )
                 )
        )
        (setq ss (&DSTR 
                   (strcat "\n选择要改变" msg2 "度的" msg1 "线<退出>: ")
                   (list '(0 . "LINE,ARC") (cons 8 lay))
                 )
        )
      )
    )
    (progn 
      (setq mm  1.0
            mma 1e-4
            mx  1e4
            p00 '(0 0)
            si  0
            sl  (sslength ss)
            lay (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线,平面主梁,平面主梁实线,平面次梁,平面次梁实线")
      )
      (if wo (setq wd (/ (- wn wo) 2)) (setq notwo T))
      (while (< si sl) 
        (setq e  (ssname ss si)
              si (1+ si)
              p1 (&DRAG e 10)
              na (strcase (&DRAG 0))
        )
        (cond 
          ((= na "LINE")
           (setq p2 (&DRAG 11)
                 a  (angle p1 p2)
           )
           (cond 
             ((equal p1 p2 mm) (entdel e))
             ((and wo (equal (distance p1 p2) wo mm))
              (setq p1 (polar p1 a (- wd))
                    p2 (polar p2 a wd)
                    e  (entget e)
                    e  (@subst e 10 (@wcs p1))
                    e  (@subst e 11 (@wcs p2))
              )
              (entmod e)
             )
             (T
              (setq a  (cond 
                         ((or (equal a pi mma) (equal a _2pi mma)) 0)
                         ((< a pi) a)
                         ((- a pi))
                       )
                    as (rtos a 2 4)
              )
              (inlist)
             )
           )
          )
          ((= na "ARC")
           (setq r  (&DRAG 40)
                 a  (&DRAG 50)
                 a1 (&DRAG 51)
           )
           (if (> a a1) (setq a1 (+ a1 _2pi)))
           (if (equal a a1 mma) (entdel e) (inalst))
          )
          (t
           (setq e (entget e)
                 e (@subst e 42 wn)
           )
           (entmod e)
          )
        )
      )
      (foreach ll l1 
        (setq a  (cadr ll)
              ll (cddr ll)
        )
        (if (cdr ll) (wlthk a ll))
      )
      (foreach ll la1 
        (setq p1 (car ll)
              ll (cdr ll)
        )
        (if (cdr ll) (wathk p1 ll))
      )
      (if tfz (command ".zoom" "p"))
    )
  )
  (&TSTY)
)




;;; 改变梁宽
(setfunhelp "c:Gblk" "Tssd" "GBLK")
(defun c:Gblk () 
  (dbthk "梁" "宽" (&LJIG "平面主梁,平面主梁实线,平面次梁,平面次梁实线"))
)
(setfunhelp "c:Gbqk" "Tssd" "GBQK")
(defun c:Gbqk () 
  (dbthk "墙" "厚" (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"))
)
(defun gbdcqlk (str / a1 a2 dist en enl flt lay lft mm p p10 p11 pt pt10 pt11 ptmp 
                s10 s11
               ) 
  (defun gdist- (en p0 str flag / p p10 p11 pt) 
    (initget 128)
    (if (setq pt (&OSNP p0 str)) 
      (if (listp pt) 
        (if flag 
          (if (= "LINE" (&DRAG en 0)) 
            (setq p10  (&DRAG en 10)
                  p11  (&DRAG en 11)
                  p    (inters 
                         p10
                         p11
                         pt
                         (polar pt (+ (angle p10 p11) _pi2) 100)
                         nil
                       )
                  dist (distance p pt)
            )
            (setq dist (abs (- (distance pt (&DRAG en 10)) (&DRAG en 40))))
          )
          (setq dist (distance p0 pt))
        )
        (if (and (= (setq dist (atof pt)) (read pt)) (> dist 0)) 
          (setq dist (* dist &sc))
          (progn 
            (princ "\n**无效的输入，请重新输入!")
            (gdist- en p0 str flag)
          )
        )
      )
    )
    (list dist (cadr (grread 1)))
  )
  (defun ydql- (e en pf pe / el enl pl pt) 
    (setq pl (&ORDR 3 e en)
          pt (if 
               (and 
                 (= 2 (length pl))
                 (> (distance pe (car pl)) (distance pe (cadr pl)))
               )
               (cadr pl)
               (car pl)
             )
    )
    (if pt 
      (progn 
        (setq el  (entget e)
              enl (entget en)
        )
        (if (= "LINE" (strcase (cdr (assoc 0 enl)))) 
          (progn 
            (if (equal pe (&DRAG en 10) 0.01) 
              (setq enl (subst (cons 10 (@wcs pt)) (assoc 10 enl) enl))
            )
            (if (equal pe (&DRAG en 11) 0.01) 
              (setq enl (subst (cons 11 (@wcs pt)) (assoc 11 enl) enl))
            )
            (entmod enl)
          )
          (progn 
            (if (equal (angle (&DRAG en 10) pe) (&DRAG en 50) 0.01) 
              (setq enl (subst 
                          (cons 50 (@wcs (angle (&DRAG en 10) pt)))
                          (assoc 50 enl)
                          enl
                        )
              )
            )
            (if (equal (angle (&DRAG en 10) pe) (&DRAG en 51) 0.01) 
              (setq enl (subst 
                          (cons 51 (@wcs (angle (&DRAG en 10) pt)))
                          (assoc 51 enl)
                          enl
                        )
              )
            )
            (entmod enl)
          )
        )
        (if (= "LINE" (strcase (cdr (assoc 0 el)))) 
          (progn 
            (if (equal pf (&DRAG e 10) 0.01) 
              (setq el (subst (cons 10 (@wcs pt)) (assoc 10 el) el))
            )
            (if (equal pf (&DRAG e 11) 0.01) 
              (setq el (subst (cons 11 (@wcs pt)) (assoc 11 el) el))
            )
            (entmod el)
          )
          (progn 
            (if (equal (angle (&DRAG e 10) pf) (&DRAG e 50) 0.01) 
              (setq el (subst 
                         (cons 50 (@wcs (angle (&DRAG e 10) pt)))
                         (assoc 50 el)
                         el
                       )
              )
            )
            (if (equal (angle (&DRAG e 10) pf) (&DRAG e 51) 0.01) 
              (setq el (subst 
                         (cons 51 (@wcs (angle (&DRAG e 10) pt)))
                         (assoc 51 el)
                         el
                       )
              )
            )
            (entmod el)
          )
        )
      )
    )
  )
  (lib::LspBeg)
  (setq lft (list 
              (cons 
                8
                (&LJIG 
                  (if (= str "梁") 
                    "平面主梁,平面主梁实线,平面次梁,平面次梁实线"
                    "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"
                  )
                )
              )
              '(0 . "line,arc")
            )
        mm  (* 0.01 &sp)
  )
  (while (setq en (&DOVR (strcat "\n选取一根要单侧变宽的" str "线<退出>: ") lft)) 
    (setq pt  (cadr en)
          en  (car en)
          enl (entget en)
          flt (list (assoc 8 enl) '(0 . "line,arc"))
    )
    (if (= "LINE" (&DRAG en 0)) 
      (progn 
        (setq p10  (&DRAG 10)
              p11  (&DRAG 11)
              ptmp (polar pt (+ (angle p10 p11) _pi2) 100)
              pt   (inters p10 p11 pt ptmp nil)
              dist (gdist- en pt (strcat "\n输入" str "线偏移的距离<结束>: ") T)
              ptmp (cadr dist)
              dist (car dist)
        )
        (if dist 
          (progn 
            (setq s10 (lib::ssp p10 mm flt)
                  s11 (lib::ssp p11 mm flt)
            )
            (ssdel en s10)
            (ssdel en s11)
            (setq pt (inters 
                       p10
                       p11
                       ptmp
                       (polar ptmp (+ (angle p10 p11) _pi2) 100)
                       nil
                     )
            )
            (command 
              ".Move"
              en
              ""
              pt
              (polar pt (angle pt ptmp) dist)
            )
            (setq enl  (entget en)
                  pt10 (&DRAG en 10)
                  pt11 (&DRAG en 11)
            )
            (if (= 1 (sslength s10)) 
              (ydql- (ssname s10 0) en p10 pt10)
            )
            (if (= 1 (sslength s11)) 
              (ydql- (ssname s11 0) en p11 pt11)
            )
          )
        )
      )
      (progn 
        (setq p    (&DRAG 10)
              a1   (&DRAG 50)
              a2   (&DRAG 51)
              lay  (&DRAG 8)
              p10  (polar p a1 (&DRAG 40))
              p11  (polar p a2 (&DRAG 40))
              ptmp (polar pt (angle p pt) 100)
        )
        (command ".Line" pt ptmp "")
        (setq pt (car (&ORDR 1 (entlast) en)))
        (entdel (entlast))
        (setq dist (gdist- en pt (strcat "\n输入" str "线偏移的距离<结束>: ") T)
              ptmp (cadr dist)
              dist (car dist)
        )
        (if dist 
          (progn 
            (setq s10 (lib::ssp p10 mm flt)
                  s11 (lib::ssp p11 mm flt)
            )
            (ssdel en s10)
            (ssdel en s11)
            (if (> (distance (&DRAG en 10) ptmp) (&DRAG en 40)) 
              (setq pt (polar p (angle p pt) (+ (&DRAG en 40) dist)))
              (setq pt (polar p (angle p pt) (- (&DRAG en 40) dist)))
            )
            (command ".Offset" dist en pt "")
            (entdel en)
            (setq en   (entlast)
                  enl  (entget en)
                  p    (&DRAG en 10)
                  a1   (&DRAG en 50)
                  a2   (&DRAG en 51)
                  pt10 (polar p a1 (&DRAG en 40))
                  pt11 (polar p a2 (&DRAG en 40))
            )
            (if (= 1 (sslength s10)) 
              (ydql- (ssname s10 0) en p10 pt10)
            )
            (if (= 1 (sslength s11)) 
              (ydql- (ssname s11 0) en p11 pt11)
            )
          )
        )
      )
    )
  )
  (&TSTY)
)
(setfunhelp "c:Lxyd" "Tssd" "Lxyd")
(defun c:Lxyd () (Gbdcqlk "梁"))
(setfunhelp "c:Qxyd" "Tssd" "Qxyd")
(defun c:Qxyd () (Gbdcqlk "墙"))
(defun dboft (msg flt / addln addarc a a1 a2 d1 d2 e la lea lel ln mm p1 p11 p12 p2 
              p21 p22 pc px r r1 r2 si ss tf tfz
             ) 
  (defun addln (tf) 
    (setq lel (if tf (cons e lel) (append lel (list e)))
          ln  (cons (&MIDP p2 p11 px) (cons (&MIDP p1 p11 px) ln))
    )
  )
  (defun addarc (tf) 
    (setq lea (if tf (cons e lea) (append lea (list e)))
          la  (cons (min a1 (car la)) (max a2 (cdr la)))
    )
  )
  (if (> (&UTXT) -1) 
    (progn 
      (setq flt (list '(0 . "line,arc") (cons 8 flt))
            mm  1.0
      )
      (while 
        (and 
          (null ss)
          (setq ss (&DSTR (strcat "\n选择要偏心的" msg "<退出>: ") flt))
        )
        (setq si  0
              pc  nil
              p11 nil
              d1  nil
              d2  nil
              r1  nil
              r2  nil
              lel nil
              lea nil
              ln  nil
              la  nil
        )
        (while (and ss (setq e (ssname ss si))) 
          (setq p1 (&DRAG e 10)
                p2 (&DRAG 11)
                si (1+ si)
          )
          (if p2 
            (cond 
              ((null p11)
               (setq p11 p1
                     p12 p2
                     a1  (angle p1 p2)
                     a   (+ a1 _pi2)
                     px  (polar p11 a 1e4)
                     lel (list e)
                     ln  (list 0 (&MIDP p2 p11 px))
               )
              )
              ((equal 
                 (setq d1 (&MIDP p1 p11 p12))
                 (&MIDP p2 p11 p12)
                 mm
               )
               (cond 
                 ((equal d1 0 mm) (addln nil))
                 ((null d2) (setq d2 d1) (addln t))
                 ((equal d1 d2 mm) (addln t))
                 (t (setq ss (prompt (strcat "\n**所选的不是" msg "，重新选取！"))))
               )
              )
              (t (setq ss (prompt (strcat "\n**所选的不是" msg "，重新选取！"))))
            )
            (progn 
              (setq r  (&DRAG 40)
                    a1 (&DRAG 50)
                    a2 (&DRAG 51)
              )
              (if (< a2 a1) (setq a2 (+ a2 pi pi)))
              (cond 
                ((null pc)
                 (setq pc  p1
                       r1  r
                       lea (list e)
                       la  (cons a1 a2)
                 )
                )
                ((equal pc p1 mm)
                 (cond 
                   ((equal r r1 mm) (addarc nil))
                   ((null r2) (setq r2 r) (addarc t))
                   ((equal r r2 mm) (addarc t))
                   (t (setq ss (prompt (strcat "\n**所选的不是" msg "，重新选取！"))))
                 )
                )
                (t (setq ss (prompt (strcat "\n**所选的不是" msg "，重新选取！"))))
              )
            )
          )
        )
      )
      (setq flt (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线,平面主梁,平面主梁实线,平面次梁,平面次梁实线"))
      (cond 
        (lel
         (setq p12 (polar p11 a1 (apply 'max ln))
               p11 (polar p11 a1 (apply 'min ln))
               p2  (&N2S p11 p12)
               a   (- a pi)
               p1  nil
         )
         (if (null d2) 
           (setq d2  0
                 p21 p11
                 p22 p12
           )
           (setq p21 (polar p11 a d2)
                 p22 (polar p12 a d2)
                 p2  (polar p2 a (* 0.5 d2))
           )
         )
         (while 
           (and 
             (null p1)
             (progn (initget 128) t)
             (setq p1 (&OSNP p2 "\n指定偏移距离(光标位置决定方向)或点取对齐点<退出>："))
           )
           (cond 
             ((listp p1)
              (setq d1 (&MIDP p1 p11 p12)
                    d2 (&MIDP p1 p21 p22)
                    tf (< (abs d2) (abs d1))
              )
              (if tf (setq d1 d2))
              (if (equal d1 0 mm) 
                (setq p1 (prompt "\n**偏移点在原地, 重新输入！"))
              )
             )
             ((and 
                (= (read p1) (setq si (atof p1)))
                (not (zerop si))
              )
              (setq p1 (cadr (grread 5))
                    d1 (&MIDP p1 p11 p12)
                    d2 (&MIDP p1 p21 p22)
                    tf (< (abs d2) (abs d1))
              )
              (if tf (setq d1 d2))
              (setq d1 (* &sc (if (minusp d1) (- si) si)))
             )
             (t (setq p1 (prompt "\n**无效的输入，重新输入！")))
           )
         )
         (if p1 
           (foreach e (if tf lel (reverse lel)) 
             (setq tfz (or (mvln e a d1 flt) tfz))
           )
         )
        )
        (lea
         (if (null r2) (setq r2 r1))
         (setq r  (* 0.5 (+ r1 r2))
               p2 (polar pc (* 0.5 (+ (car la) (cdr la))) r)
               p1 nil
         )
         (while 
           (and 
             (null p1)
             (progn (initget 128) t)
             (setq p1 (&OSNP p2 "\n输入偏移距离(光标位置决定方向)或点取对齐点<退出>："))
           )
           (cond 
             ((listp p1)
              (setq r  (distance pc p1)
                    d1 (- r r1)
                    d2 (- r r2)
                    tf (< (abs d2) (abs d1))
              )
              (if tf (setq d1 d2))
              (if (equal d1 0 mm) 
                (setq p1 (prompt "\n**偏移点在原地, 重新输入！"))
              )
             )
             ((and 
                (= (read p1) (setq si (atof p1)))
                (not (zerop si))
              )
              (setq p1 (cadr (grread 5))
                    r  (distance pc p1)
                    d1 (- r r1)
                    d2 (- r r2)
                    tf (< (abs d2) (abs d1))
              )
              (setq d1 (* &sc (if (< r (* 0.5 (+ r1 r2))) (- si) si)))
             )
             (t (setq p1 (prompt "\n**无效的输入，重新输入！")))
           )
         )
         (if p1 
           (foreach e (if tf lea (reverse lea)) 
             (setq tfz (or (mvarc e d1 flt) tfz))
           )
         )
        )
      )
      (if tfz (command ".zoom" "p"))
    )
  )
  (&TSTY)
)
(setfunhelp "c:Lxpy" "Tssd" "LXPY")
(defun c:Lxpy () 
  (dboft "一根梁" (&LJIG "平面主梁,平面主梁实线,平面次梁,平面次梁实线"))
)
(setfunhelp "c:Qxpy" "Tssd" "QXPY")
(defun c:Qxpy () 
  (dboft "一道墙" (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线"))
)
(setfunhelp "c:ldmh" "Tssd" "ldmh")
(defun c:ldmh (/ dcl_chs findbeam drawbeam p p1 p2 enl dim ssbak ldel) 
  (defun dcl_chs (el / vslide show_data change_list txt what dia len i ll data_l unit 
                  hig bg turn drw bl br hl hr a1 a2
                 ) 
    (defun vslide (/ drw x y) 
      (setq drw (get_tile "drw")
            x   (dimx_tile "img")
            y   (dimy_tile "img")
      )
      (start_image "img")
      (fill_image 0 0 x y -2)
      (if (= drw "0") 
        (slide_image 80 0 x y "Tssd(ldmh)")
        (slide_image 10 -50 (+ x 120) (+ y 100) "Tssd(ldmh1)")
      )
      (end_image)
    )
    (defun show_data (/ no data) 
      (setq no   (atoi (get_tile "no"))
            data (nth no data_l)
      )
      (mapcar 'set_tile 
              (list "hig" "bg" "turn" "drw" "bl" "br" "hl" "hr" "a1" "a2")
              (cdr data)
      )
      (if (equal (atof (nth 6 data)) 0 0.01) 
        (progn (set_tile "hr" "0") (mode_tile "a2" 1))
        (mode_tile "a2" 0)
      )
      (if (and (> no 0) (= "1" (nth 3 (nth (1- no) data_l)))) 
        (progn (mode_tile "bl" 1) (mode_tile "a1" 1))
        (if (equal (atof (nth 5 data)) 0 0.01) 
          (progn (set_tile "hl" "0") (mode_tile "a1" 1))
          (progn (mode_tile "bl" 0) (mode_tile "a1" 0))
        )
      )
    )
    (defun change_list (/ tan no hig bg turn drw bl br hl hr a1 a2 dis dis1 dis2 data 
                        i
                       ) 
      (defun tan (a) 
        (setq a (/ (sin (/ (* pi a) 180)) (cos (/ (* pi a) 180))))
      )
      (setq no   (atoi (get_tile "no"))
            hig  (get_tile "hig")
            bg   (get_tile "bg")
            turn (get_tile "turn")
            drw  (get_tile "drw")
            bl   (get_tile "bl")
            br   (get_tile "br")
            hl   (get_tile "hl")
            hr   (get_tile "hr")
            a1   (get_tile "a1")
            a2   (get_tile "a2")
            dim  (get_tile "dim")
      )
      (if (or (/= no 0) (/= no (1- len))) 
        (progn 
          (if (and (/= no 0) (equal (atof bl) 0 0.01)) 
            (progn 
              (setq bl (nth 5 (nth no data_l)))
              (set_tile "bl" bl)
            )
          )
          (if (and (/= no (1- len)) (equal (atof br) 0 0.01)) 
            (progn 
              (setq br (nth 6 (nth no data_l)))
              (set_tile "br" br)
            )
          )
        )
      )
      (if (= drw "1") 
        (progn (setq turn "1") (set_tile "turn" "1"))
      )
      (if (equal (atof br) 0 0.01) 
        (progn 
          (set_tile "hr" "0")
          (setq hr "0")
          (mode_tile "a2" 1)
        )
        (mode_tile "a2" 0)
      )
      (if (and (> no 0) (= "1" (nth 3 (nth (1- no) data_l)))) 
        (progn (mode_tile "bl" 1) (mode_tile "a1" 1))
        (if (equal (atof bl) 0 0.01) 
          (progn 
            (set_tile "hl" "0")
            (setq hl "0")
            (mode_tile "a1" 1)
          )
          (progn (mode_tile "bl" 0) (mode_tile "a1" 0))
        )
      )
      (if (< (atof hig) (+ (atof br) (atof hr))) 
        (progn 
          (setq hig (itoa (+ (atoi br) (atoi hr))))
          (set_tile "hig" hig)
        )
      )
      (if (< (atof hig) (+ (atof bl) (atof hl))) 
        (progn 
          (setq hig (itoa (+ (atoi bl) (atoi hl))))
          (set_tile "hig" hig)
        )
      )
      (setq data (list (itoa no) hig bg turn drw bl br hl hr a1 a2)
            i    no
      )
      (if (= turn "1") 
        (while 
          (or 
            (= i no)
            (and (< no len) (= "1" (nth 3 (nth (1- no) data_l))))
          )
          (setq data_l (@subst data_l no data)
                no     (1+ no)
                data   (nth no data_l)
          )
          (if (/= no len) 
            (progn 
              (setq dis1 (last (nth (1- no) el))
                    dis2 (last (nth no el))
                    dis  (- (last dis2) (last dis1))
                    dis1 (caddr dis1)
                    dis2 (caddr dis2)
              )
              (if (= 90 (atof a1)) (setq dis (- dis (* 0.5 dis1))))
              (setq bg   (- 
                           (* 1000 (atof bg))
                           (/ (/ dis &sc) (tan (atof a2)))
                         )
                    bg   (&RTXT (/ bg 1000))
                    data (@subst data 2 bg)
              )
            )
          )
          (setq a1   (rtos (- 180 (atof a2)) 2 0)
                data (@subst data 9 a1)
                data (@subst data 10 a2)
                bl   br
                data (@subst data 5 bl)
          )
        )
        (setq data_l (@subst data_l no data))
      )
      data_l
    )
    (setq len (length el)
          i   0
          txt (list "0" "1000" "0.0" "1" "0" "100" "100" "0" "0" "90" "90")
    )
    (while (> len i) 
      (setq i      (1+ i)
            ll     (append ll (list (itoa i)))
            data_l (append data_l (list txt))
      )
    )
    (setq what 8
          dia  (lib::dcl "BeamWall")
          unit (getvar "LUPREC")
    )
    (setvar "LUPREC" 3)
    (while (> what 0) 
      (if (not (new_dialog "Ldmh" dia)) (exit))
      (mapcar 'set_tile 
              (list "no" "hig" "bg" "turn" "drw" "bl" "br" "hl" "hr" "a1" "a2")
              txt
      )
      (mapcar 'set 
              '(hig bg turn drw bl br hl hr a1 a2)
              (mapcar 'read (cdr txt))
      )
      (set_tile "error" (strcat "当前共选择了 " (itoa len) " 个梁断面"))
      (set_tile "dim" "0")
      (vslide)
      (start_list "no")
      (mapcar 'add_list ll)
      (end_list)
      (action_tile "drw" "(vslide)(change_list)")
      (action_tile "no" "(show_data)")
      (action_tile "turn" "(change_list)")
      (action_tile "hig" "(#isnum 10 nil)(change_list)")
      (action_tile "bg" "(#isnum nil nil)(change_list)")
      (action_tile "bl" "(#isnum 0.0 nil)(change_list)")
      (action_tile "br" "(#isnum 0.0 nil)(change_list)")
      (action_tile "hl" "(#isnum 0.0 nil)(change_list)")
      (action_tile "hr" "(#isnum 0.0 nil)(change_list)")
      (action_tile "a1" "(#isnum 0 180)(change_list)")
      (action_tile "a2" "(#isnum 0 180)(change_list)")
      (action_tile 
        "accept"
        "(setq what -8 data_l (change_list))(done_dialog 0)"
      )
      (action_tile 
        "cancel"
        "(done_dialog 0)(setq what -2 data_l nil)"
      )
      (action_tile "help" "(help \"Tssd\" \"ldmh\")")
      (start_dialog)
    )
    (unload_dialog dia)
    (setvar "LUPREC" unit)
    data_l
  )
  (defun findbeam (p1 p2 / lay vct vsz ss en i j flag p10 p11 r qi zh e ent flg pt10 
                   pt11 r1 qi1 zh1 an ang dis dist enl d ee
                  ) 
    (setq lay (strcat 
                (&LJIG "平面主梁,平面主梁实线,平面次梁,平面次梁实线,平面过梁,平面过梁实线,平面连梁,平面连梁实线")
                ","
                (&LJIG "平面砼墙,平面砼墙虚线,平面砖墙,平面砖墙虚线")
              )
    )
    (setq vct (getvar "viewctr")
          vsz (getvar "viewsize")
    )
    (@zoome 0 (list p1 p2))
    (if (setq ss (@ssgetf lay "LINE,ARC" p1 p2)) 
      (progn 
        (setq i 0)
        (while (setq en (ssname ss i)) 
          (setq i    (1+ i)
                flag (&DRAG en 0)
                p10  (&DRAG en 10)
                p11  (&DRAG 11)
                r    (&DRAG 40)
                qi   (&DRAG 50)
                zh   (&DRAG 51)
                j    1
                e    nil
                dis  nil
          )
          (while (setq ent (ssname ss j)) 
            (setq j    (1+ j)
                  flg  (&DRAG ent 0)
                  pt10 (&DRAG ent 10)
                  pt11 (&DRAG 11)
                  r1   (&DRAG 40)
                  qi1  (&DRAG 50)
                  zh1  (&DRAG 51)
            )
            (if (and (wcmatch flag flg) (not (eq en ent))) 
              (if (wcmatch flag "LINE") 
                (progn 
                  (setq an  (angle p10 p11)
                        ang (angle pt10 pt11)
                  )
                  (if (or (equal an pi 0.01) (equal an (+ pi pi) 0.01)) 
                    (setq an 0)
                  )
                  (while (> an pi) (setq an (- an pi)))
                  (if (or (equal ang pi 0.01) (equal ang (+ pi pi) 0.01)) 
                    (setq ang 0)
                  )
                  (while (> ang pi) (setq ang (- ang pi)))
                  (if (equal an ang 0.01) 
                    (progn 
                      (setq dist (distance 
                                   p10
                                   (inters p10 
                                           (polar p10 (+ an _pi2) 100)
                                           pt10
                                           pt11
                                           nil
                                   )
                                 )
                      )
                      (if (not dis) (setq dis dist))
                      (if (and (<= dist dis) (< dist (* 1000 &sp))) 
                        (setq e   ent
                              dis dist
                              d   (distance 
                                    p1
                                    (inters p10 
                                            p11
                                            p1
                                            (polar p1 (+ an _pi2) 100)
                                            nil
                                    )
                                  )
                              d   (/ 
                                    (+ 
                                      d
                                      (distance 
                                        p1
                                        (inters pt10 
                                                pt11
                                                p1
                                                (polar p1 (+ an _pi2) 100)
                                                nil
                                        )
                                      )
                                    )
                                    2
                                  )
                        )
                      )
                    )
                  )
                )
                (if (equal p10 pt10 (* 0.01 &sp)) 
                  (progn 
                    (setq dist (abs (- r1 r)))
                    (if (not dis) (setq dis dist))
                    (if (and (<= dist dis) (< dist (* 1000 &sp))) 
                      (setq e   ent
                            dis dist
                            d   (/ 
                                  (+ 
                                    (distance p1 (car (&ORDR eee e)))
                                    (distance p1 (car (&ORDR eee en)))
                                  )
                                  2.0
                                )
                      )
                    )
                  )
                )
              )
            )
          )
          (if e 
            (progn 
              (setq pt1  (car (&ORDR eee e))
                    pt2  (car (&ORDR eee en))
                    dist (/ (+ (distance p1 pt1) (distance p1 pt2)) 2.0)
              )
              (ssdel e ss)
              (ssdel en ss)
              (if (< (distance p1 pt1) (distance p1 pt2)) 
                (setq ee en
                      en e
                      e  ee
                )
              )
              (setq i   (1- i)
                    enl (append enl (list (list dist (list en e dis d))))
              )
            )
          )
        )
      )
    )
    enl
  )
  (defun draw (data_l enl / draw_bg diml draw_first line len i data bg hig drw bl br 
               hl hr a1 a2 eee en ang p0 pt pt1 e1 e2 dis ptl bgn hign pl sshatch step
              ) 
    (defun draw_bg (pt str an / en s pt1 pt2 pt3 pt4 zg textl) 
      (setq en  (entlast)
            s   (ssadd)
            zg  (&INTS "标号文字" T)
            str (atof str)
      )
      (ssadd en s)
      (setq pt1 (polar pt an (* 8 &sp))
            pt3 (polar pt an (* 6 &sp))
            pt2 (polar pt3 (+ an (* 0.25 pi)) (* 3 (sqrt 2.0) &sp))
            pt4 (polar pt3 (+ an (* 0.75 pi)) (* 3 (sqrt 2.0) &sp))
      )
      (if (equal str 0 0.001) 
        (setq str "%%p0.000")
        (setq str (rtos str 2 3))
      )
      (&LJIG "详图楼板文字" T)
      (command 
        ".text"
        (polar pt2 (+ an _pi2) (/ zg 3.0))
        zg
        (/ (* 180 an) pi)
        str
      )
      (setq textl (textbox (list (cons 1 str)))
            textl (distance (nth 0 textl) (nth 1 textl))
      )
      (command 
        ".Line"
        pt2
        pt3
        pt4
        (polar pt2 an (+ &sp textl))
        ""
        ".Line"
        pt
        pt1
        ""
      )
      (while (entnext en) (ssadd (setq en (entnext en)) s))
      (&DGAR s)
    )
    (defun diml (pt0 pt1 ang /) 
      (&LJIG "详图楼板尺寸" t)
      (&GVAL)
      (command 
        ".dimaligned"
        pt0
        pt1
        (polar (&N2S pt0 pt1) ang (* 8 &sp))
      )
    )
    (defun line (ppl / ppp) 
      (&LJIG "详图楼板剖面" T)
      (command ".Line" (car ppl))
      (setq ppl (cdr ppl))
      (while (setq ppp (car ppl)) 
        (command ppp)
        (ssadd (entlast) sshatch)
        (setq ppl (cdr ppl))
      )
      (command "")
    )
    (defun BeamPdx (p1 p6 / a d p2 p3 p4 p5 pa pb sc) 
      (if (and p1 p6) 
        (progn 
          (&LJIG "详图楼板剖面" T)
          (setvar "plinewid" 0)
          (setq sc (* 1e-3 (distance p1 p6))
                d  (* 0.5 (distance p1 p6))
                a  (angle p1 p6)
                p2 (polar p1 a (- d (* sc 130)))
                p5 (polar p6 a (- (* sc 130) d))
                p3 (polar (polar p2 a (* sc 70)) (+ a _pi2) (* sc 220))
                p4 (polar (polar p5 a (* sc -70)) (+ a _pi2) (* sc -220))
                pa (polar p1 a (* sc -280))
                pb (polar p6 a (* sc 280))
          )
          (command ".pline" pa p2 p3 p4 p5 pb "" ".pline" p1 p2 p3 p4 p5 p6 "")
          (ssadd (entlast) sshatch)
        )
      )
    )
    (defun draw_first (pp1 pp2 aa / pf1 pf2 a dl) 
      (setq pf1 (car ptl)
            pf2 (cadr ptl)
            a   (caddr ptl)
            dl  (* 4 &sp)
      )
      (if (= drw "1") 
        (progn 
          (if pf1 (Line (list pf1 pp1)))
          (if pf2 (Line (list pf2 pp2)))
        )
        (progn 
          (if pf1 (Line (list pf1 (setq pf1 (polar pf1 a dl)))))
          (if pf2 (Line (list pf2 (setq pf2 (polar pf2 a dl)))))
          (if pf1 
            (progn 
              (setq step (1+ step))
              (BeamPdx pf1 pf2)
              (setq ldel (cons (entlast) ldel))
            )
          )
          (if (= 0 (rem step 2)) 
            (progn 
              (&LJIG "详图楼板剖面填充" T)
              (command ".bhatch" "A" "I" "Y" "S" "N" "R" "N" "A" "N" "" "P" "solid" 
                       "S" sshatch "" ""
              )
              (ssadd (entlast) ssbak)
              (setq sshatch nil
                    sshatch (ssadd)
              )
            )
          )
          (Line (list pp1 (setq pp1 (polar pp1 aa dl))))
          (Line (list pp2 (setq pp2 (polar pp2 aa dl))))
          (setq step (1+ step))
          (BeamPdx pp1 pp2)
          (setq ldel (cons (entlast) ldel))
        )
      )
    )
    (defun draw_ldm (pt pt1 ang / tan an d pt2 pt3 pt4 pt5 pt6 pt7 dh p) 
      (defun tan (a) 
        (if (equal a _pi2 0.01) 
          (setq a 0.0)
          (setq a (/ (cos a) (sin a)))
        )
        a
      )
      (setq an (angle pt pt1)
            d  (* 0.01 &sc)
      )
      (cond 
        ((and (equal br 0 d) (equal bl 0 d))
         (setq pt2 (polar pt1 ang hig)
               pt3 (polar pt ang hig)
               ptl nil
         )
         (line (list pt pt1 pt2 pt3 pt))
         (&LJIG "详图楼板剖面填充" T)
         (command ".bhatch" "A" "I" "Y" "S" "N" "R" "N" "A" "N" "" "P" "solid" "S" 
                  sshatch "" ""
         )
         (ssadd (entlast) ssbak)
         (setq sshatch nil
               sshatch (ssadd)
         )
         (draw_bg (&N2S pt2 pt3) bg an)
         (if (= dim "1") (diml pt1 pt2 (&N2S pt1 pt2) an))
        )
        ((and (not (equal bl 0 d)) (equal br 0 d))
         (setq dh (* 0.5 dis (tan a1)))
         (if (equal hl 0 d) 
           (setq pt4 (polar pt ang (- hig dh)))
           (setq pt6 (polar pt ang hig)
                 pt4 (polar pt6 (- ang pi) hl)
           )
         )
         (setq pt2 (polar pt4 (- ang pi) (/ bl (sin a1)))
               pt5 (polar pt1 ang (+ hig dh))
         )
         (draw_first pt4 pt2 (- (+ ang pi) a1))
         (if pt6 (line (list pt4 pt6)) (setq pt6 pt4))
         (line (list pt2 pt pt1 pt5 pt6))
         (draw_bg (polar (&N2S pt pt1) ang hig) bg an)
         (if (= dim "1") (diml pt1 pt5 an))
        )
        ((and (equal bl 0 d) (not (equal br 0 d)))
         (setq dh   (* 0.5 dis (tan (- pi a2)))
               step (1+ step)
         )
         (if (equal hr 0 d) 
           (setq pt5 (polar pt1 ang (- hig dh)))
           (setq pt7 (polar pt1 ang hig)
                 pt5 (polar pt7 (- ang pi) hr)
           )
         )
         (setq pt3 (polar pt5 (- ang pi) (/ br (sin a2)))
               pt4 (polar pt ang (- hig dh))
         )
         (if pt7 (line (list pt7 pt5)) (setq pt7 pt5))
         (line (list pt5 pt4 pt pt1 pt3))
         (setq ptl (list pt5 pt3 (+ ang pi a2)))
         (draw_bg (polar (&N2S pt pt1) ang hig) bg an)
         (if (= dim "1") (diml pt (polar pt ang hig) (- an pi)))
        )
        ((and (not (equal bl 0 d)) (not (equal br 0 d)))
         (setq dh  (* 0.5 dis (tan a1))
               pt6 nil
               pt7 nil
         )
         (if (equal hl 0 d) 
           (setq pt4 (polar pt ang (- hig dh)))
           (setq pt6 (polar pt ang hig)
                 pt4 (polar pt6 (- ang pi) hl)
           )
         )
         (setq pt2 (polar pt4 (- ang pi) (/ bl (sin a1))))
         (draw_first pt4 pt2 (- (+ ang pi) a1))
         (if (equal hr 0 d) 
           (setq pt5 (polar pt1 ang (+ hig dh)))
           (setq pt7 (polar pt1 ang hig)
                 pt5 (polar pt7 (- ang pi) hr)
           )
         )
         (setq pt3 (polar pt5 (- ang pi) (/ br (sin a2))))
         (if pt6 (line (list pt4 pt6)) (setq pt6 pt4))
         (if pt7 (line (list pt7 pt5)) (setq pt7 pt5))
         (line (list pt2 pt pt1 pt3))
         (line (list pt6 pt7))
         (setq ptl (list pt5 pt3 (+ ang pi a2)))
         (draw_bg (polar (&N2S pt pt1) ang hig) bg an)
        )
      )
      ptl
    )
    (Defun getang (a1) 
      (if (null ang) 
        (progn 
          (setq ang a1)
          (while (> ang pi) (setq ang (- ang pi)))
          (while (minusp ang) (setq ang (+ ang pi)))
          (if (< ang (* 0.2505 pi)) (setq ang (+ ang pi)))
        )
      )
    )
    (command ".Line" p1 p2 "")
    (setq eee (entlast))
    (setq i       0
          len     (length data_l)
          pt      (car (&ORDR eee (caadr (car enl))))
          sshatch (ssadd)
          step    0
    )
    (entdel eee)
    (while (> len i) 
      (setq data (nth i data_l)
            entl (nth i enl)
            entl (cadr entl)
            i    (1+ i)
            e1   (car entl)
            e2   (cadr entl)
            dis  (caddr entl)
            bg   (nth 2 data)
            hig  (* &sc (atof (nth 1 data)))
            bl   (* &sc (atof (nth 5 data)))
            br   (* &sc (atof (nth 6 data)))
            hl   (* &sc (atof (nth 7 data)))
            hr   (* &sc (atof (nth 8 data)))
            a1   (/ (* pi (atof (nth 9 data))) 180)
            a2   (/ (* pi (atof (nth 10 data))) 180)
      )
      (if (> i 1) (setq drw (nth 4 (nth (- i 2) data_l))))
      (if (= i 1) (setq drw "0"))
      (if (= "LINE" (&DRAG e1 0)) 
        (progn 
          (getang (angle (&DRAG 10) (&DRAG 11)))
          (setq pt1 (inters 
                      pt
                      (polar pt (+ ang _pi2) 100)
                      (&DRAG e2 10)
                      (&DRAG 11)
                      nil
                    )
          )
          (if (not (equal (distance pt pt1) dis 0.01)) 
            (setq p0  (&N2S pt pt1)
                  pt  (polar p0 (angle p0 pt) (* 0.5 dis))
                  pt1 (polar p0 (angle p0 pt1) (* 0.5 dis))
            )
          )
        )
        (progn 
          (setq p0 (&DRAG 10))
          (getang (+ (angle p0 pt) _pi2))
          (setq pt1 (polar pt (- ang _pi2) dis))
        )
      )
      (if (equal (sin (- (angle pt pt1) ang)) 1 0.01) 
        (&PMLAY "pt" "pt1")
      )
      (setq ptl (draw_ldm pt pt1 ang))
      (if (/= i len) 
        (progn 
          (setq e1   (caadr (nth i enl))
                data (nth i data_l)
                bgn  (nth 2 data)
                hign (* &sc (atof (nth 1 data)))
          )
          (command ".Line" pt pt1 "")
          (setq eee (entlast)
                pl  (&ORDR 3 eee e1)
          )
          (if (= (length pl) 2) 
            (if (> (distance (car pl) pt1) (distance (cadr pl) pt1)) 
              (setq pt (cadr pl))
              (setq pt (car pl))
            )
            (setq pt (car pl))
          )
          (entdel eee)
          (if 
            (or 
              (not (equal (atof bgn) (atof bg) 0.001))
              (not (equal hign hig 0.001))
            )
            (progn 
              (setq pt1 (polar 
                          pt
                          ang
                          (+ (- hig hign) (* &sc 1000 (- (atof bgn) (atof bg))))
                        )
              )
              (command ".Line" pt1 (polar pt1 (- ang _pi2) 100) "")
              (setq eee (entlast)
                    pl  (&ORDR 3 eee e1)
              )
              (if (= (length pl) 2) 
                (if (> (distance (car pl) pt1) (distance (cadr pl) pt1)) 
                  (setq pt (cadr pl))
                  (setq pt (car pl))
                )
                (setq pt (car pl))
              )
              (entdel eee)
            )
          )
        )
      )
      (if (not pt) (setq i (1+ i)))
    )
    (if ptl 
      (progn 
        (setq pt  (car ptl)
              pt1 (cadr ptl)
              a2  (caddr ptl)
              ptl nil
              drw "0"
        )
        (draw_first pt pt1 a2)
        (&LJIG "详图楼板剖面填充" T)
        (command ".bhatch" "A" "I" "Y" "S" "N" "R" "N" "A" "N" "" "P" "solid" "S" 
                 sshatch "" ""
        )
        (ssadd (entlast) ssbak)
      )
    )
  )
  (if 
    (and 
      (> (&UTXT) -1)
      (setq p1 (&OSNP "\n点取梁断面号起始点<退出>："))
      (setq p2 (&OSNP p1 "\t结束点<退出>："))
    )
    (progn 
      (if 
        (and 
          (> (angle p1 p2) (* 0.75 pi))
          (< (angle p1 p2) (* 1.75 pi))
        )
        (setq p  p1
              p1 p2
              p2 p
        )
      )
      (command ".Line" p1 p2 "")
      (setq eee   (entlast)
            ssbak (ssadd)
            ldel  nil
      )
      (if (setq enl (findbeam p1 p2)) 
        (progn 
          (entdel eee)
          (redraw)
          (setq enl  (@ran4 enl)
                data (dcl_chs enl)
          )
          (if data (draw data enl))
          (if (> (sslength ssbak) 0) 
            (progn 
              (foreach e ldel (entdel e))
              (command ".draworder" ssbak "" "b")
            )
          )
        )
        (entdel eee)
      )
    )
  )
  (command ".zoom" "c" vct vsz)
  (&TSTY)
)
(setfunhelp "c:Hzhbd" "Tssd" "Hzhbd")
(defun c:Hzhbd (/ wid wide pt1 pt2 ang) 
  (if (< (&UTXT) 0) (exit))
  (setq wid (&GPTS "Tssd/Dcl_Hzh/Hzhbd"))
  (if (or (not wid) (= wid "")) 
    (setq wid 3600)
    (setq wid (fix (atof wid)))
  )
  (initget (+ 2 4))
  (setq wide (getint (strcat "\n输入板带的宽度<" (itoa wid) ">: ")))
  (if (not wide) (setq wide wid))
  (if 
    (and 
      (setq pt1 (&OSNP "\n点取板带的起点<退出>: "))
      (setq pt2 (&OSNP pt1 "\n点取板带的结束点<退出>: "))
    )
    (progn 
      (&LJIG "平面楼板虚线" T)
      (setq ang (angle pt1 pt2)
            wid (* 0.5 wide &sc)
      )
      (command 
        ".Line"
        (polar pt1 (+ ang _pi2) wid)
        (polar pt2 (+ ang _pi2) wid)
        ""
      )
      (command 
        ".Line"
        (polar pt1 (- ang _pi2) wid)
        (polar pt2 (- ang _pi2) wid)
        ""
      )
    )
  )
  (&GLAY "Tssd/Dcl_Hzh/Hzhbd" (itoa (fix wide)))
  (&TSTY)
)
 
